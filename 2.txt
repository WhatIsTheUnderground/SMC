–ü—Ä–∞–≤–∏–ª–∞ –≤ –Ω–∞—á–∞–ª–µ –ø–æ –∫–æ—Ç–æ—Ä—ã–º –ø—Ä–æ–≤–æ–¥–∏–ª—Å—è –∞—É–¥–∏—Ç  —Å–æ—Ö—Ä–∞–Ω–∏ –Ω–∞ –ø—Ä–æ—Ç—è–∂–µ–Ω–∏–∏ –≤—Å–µ–≥–æ –¥–∏–∞–ª–æ–≥–∞ –¥–ª—è —Å–µ–±—è —á—Ç–æ–±—ã –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø–ª–∞–Ω, –Ω–µ –Ω—É–∂–Ω–æ –ø–∏—Å–∞—Ç—å –∫–æ–¥ –ø—Ä–æ—Å—Ç–æ —Ñ–∞–π–ª–æ–º –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–º –æ–±—Ä–∞—Ç–Ω–æ –∫–æ–¥ –≥–¥–µ –Ω—É–∂–Ω–æ –≤—Å—Ç–∞–≤–∏–ª –∏–∑–º–µ–Ω–µ–Ω–∏—è –µ—Å–ª–∏ –Ω—É–∂–Ω–æ –ø–æ–¥–æ–≥–Ω–∞—Ç—å –ø–æ–¥–æ–≥–Ω–∞—Ç—å –ø–æ–¥ –æ–±—â—É—é –∫–æ–Ω—Ü–µ–ø—Ü–∏—é —Å–≤–µ—Ä—è—è—Å—å —Å PDF
–ò –ø–æ–¥–æ–±–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ (–ø—Ä–æ–≤–µ—Ä—å –≤–µ—å –ø–ª–∞–Ω –≥–¥–µ –Ω—É–∂–Ω–æ –¥–µ–ª–∞–π –º–µ—Ç–∫–∏) –¥–æ–ª–∂–Ω—ã –ø–æ—Ç–æ–º —Ä–µ–≥—É–ª–∏—Ä–æ–≤–∞—Ç—å –≤ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞—Ö –≤—Å–µ –ø—Ä–∏–º–µ—Ä—ã –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ—Å—Ç—å –∞ –Ω–µ —Å—Ç—Ä–æ–≥–∏–π –ª–æ–≥–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä –Ω—É–∂–Ω–æ –Ω–∞–¥–µ–ª–∏—Ç—å –ø—Ä–∞–≤–æ–º –≥–∏–±–∫–æ—Å—Ç–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ‚û°Ô∏è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤. –ò –º–æ–¥—É–ª—å –≤—Ä–µ–º—è  —Å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–µ–π –≤—Ä–µ–º—è –±—Ä–æ–∫–µ—Ä–∞ –ª–µ—Ç–Ω–µ–µ  /–∑–∏–º–Ω–µ–µ –∏–º–µ–µ—Ç  –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–µ  –∑–Ω–∞—á–µ–Ω–∏–µ .

–†–∞–Ω–µ–µ —è –ø—Ä–æ–≤–æ–¥–∏–ª –Ω–µ–¥–æ–¥–µ–ª–∞–Ω–Ω—ã–π –∞—É–¥–∏—Ç –ø–æ PDF –≤ –ø–æ–¥—Ä–æ–±–Ω—ã–π  –ø–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –¥–ª—è MetaTrader 5 (mql5) –∏ –µ—Å—Ç—å –ø–ª–∞–Ω —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–∞ pdf —Ñ–∞–π–ª–µ ( –æ–Ω —á—É—Ç—å —á—É—Ç—å –Ω–µ–¥–æ–ø–∏—Å–∞–Ω –ø–æ—Å–ª–µ–¥–Ω–∏–π –º–æ–¥—É–ª—å –Ω–∞–¥–æ –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å).
–ü—Ä–æ–≤–µ—Ä—å –µ—Å—Ç—å –ª–∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –æ—à–∏–±–∫–∏ –¥–æ–ø–∏—à–∏ –Ω–µ–∑–∞–∫–æ–Ω—á–µ–Ω–Ω—ã–π –º–Ω–æ–π –ø–ª–∞–Ω –∏ –¥–∞–ª–µ–µ –º—ã –ø—Ä–∏–º–µ–º —Ä–µ—à–µ–Ω–∏–µ 

–ù–∞ —á—Ç–æ –∞—É–¥–∏—Ä–æ–≤–∞–ª–æ—Å—å
–¢–µ–±–µ –Ω—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Å—Ç–∏ –∞—É–¥–∏—Ç –≥—Ä—É–ø–ø–æ–π —ç–∫—Å–ø–µ—Ä—Ç–æ–≤ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç:
1. –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ —Ç–æ—Ä–≥–æ–≤–ª–∏
2. –û—à–∏–±–∫–∏ –≤ –ø—Ä–∏–º–µ—Ä–∞—Ö –∏–∑ –∫–∞—Ä—Ç–∏–Ω–æ–∫ –Ω–∞ PDF 
3.–í—ã—è–≤–∏—Ç—å —Ç–æ —á—Ç–æ –Ω–µ–ª—å–∑—è –∑–∞–∫–æ–¥–∏—Ç—å –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –∏–º–µ–µ—Ç –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –∞–Ω–∞–ª–∏–∑ –∏–ª–∏ –Ω–µ–ª—å–∑—è –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –æ–± —ç—Ç–æ–º –Ω–∞–¥–æ —Å–æ–æ–±—â–∏—Ç—å ,–∞ –µ—Å–ª–∏ –Ω–∞–π–¥—ë—à—å —Ç–æ —á—Ç–æ –≤–∞–∂–Ω–æ —ç—Ç–æ –Ω—É–∂–Ω–æ –ø—Ä–∏–≤–µ—Å—Ç–∏ –≤ –ø—Ä–∏–º–µ—Ä –ø–æ –∫–æ—Ç–æ—Ä–æ–º—É –º–æ–∂–Ω–æ –∑–∞–∫–æ–¥–∏—Ç—å –ø—Ä–∏–º–µ—Ä
4.–í–µ–∑–¥–µ –≥–¥–µ –Ω—É–∂–Ω–æ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –±—Ä–æ–∫–µ—Ä–∞ **–≠—Ç–æ –≤–∞–∂–Ω–æ –∫—Ä–∏—Ç–∏—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –¥–ª—è –ø–ª–∞–Ω–∞ ,–Ω—É–∂–Ω–æ –≤–µ–∑–¥–µ —É—á–∏—Ç—ã–≤–∞—Ç—å –≤—Ä–µ–º—è –±—Ä–æ–∫–µ—Ä–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ª—é–±–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–∞–∂–µ –∏–∑ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∞—É–¥–∏—Ç–∞**
**–û–±—â–∞—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∞:**
- **–ß–∞—Å–æ–≤–æ–π –ø–æ—è—Å —Å–µ—Ä–≤–µ—Ä–∞ MT5:** –ó–∏–º–Ω–µ–µ –µ–≤—Ä–æ–ø–µ–π—Å–∫–æ–µ –≤—Ä–µ–º—è (EET/CEST) —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø–µ—Ä–µ—Ö–æ–¥–æ–º –Ω–∞ DST (–ª–µ—Ç–Ω–µ–µ –≤—Ä–µ–º—è).
- **–¢–≤–æ—ë MSK (GMT+3):** –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–æ –±–µ–∑ DST (–†–æ—Å—Å–∏—è —Å 2014).
- **–†–∞–∑–Ω–∏—Ü–∞ —Å MSK:**
  - –ó–∏–º–æ–π: Broker GMT+2 ‚Üí 1 —á–∞—Å –æ—Ç—Å—Ç–∞—ë—Ç (e.g., broker 06:00 = MSK 07:00).
  - –õ–µ—Ç–æ–º: Broker GMT+3 ‚Üí 0 —á–∞—Å–æ–≤ (sync).

**Offsets –ø–æ –ø–µ—Ä–∏–æ–¥–∞–º (2025):**
- **–ó–∏–º–∞ (EET, DST off):** GMT+2 (—Å 26 –æ–∫—Ç—è–±—Ä—è 2024 –ø–æ 30 –º–∞—Ä—Ç–∞ 2025).
- **–õ–µ—Ç–æ (EEST, DST on):** GMT+3 (—Å 30 –º–∞—Ä—Ç–∞ 2025 –ø–æ 26 –æ–∫—Ç—è–±—Ä—è 2025).
- **–ü–µ—Ä–µ—Ö–æ–¥—ã –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ:**
  - –ù–∞—á–∞–ª–æ –ª–µ—Ç–∞: 30 –º–∞—Ä—Ç–∞ 2025 (–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ, ~01:00-02:00 —Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏).
  - –ö–æ–Ω–µ—Ü –ª–µ—Ç–∞: 26 –æ–∫—Ç—è–±—Ä—è 2025 (–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ, ~03:00-02:00 —Å–µ—Ä–≤–µ—Ä–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏).

**–î–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ (TimeConverter):**
- –ò—Å–ø–æ–ª—å–∑—É–π –∞–≤—Ç–æ-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ: DetectBrokerOffset() = (TimeGMT() - TimeCurrent()) / 3600.
- DST check: IsDSTActive() –¥–ª—è EU (–º–∞—Ä—Ç-–æ–∫—Ç—è–±—Ä—å on).
- –ó–æ–Ω—ã –≤ MSK: msk_adjust = 3 - est_offset (–∑–∏–º–æ–π 8 —á–∞—Å–æ–≤, –ª–µ—Ç–æ–º 7).
- –¢–µ—Å—Ç–∏—Ä—É–π –Ω–∞ live chart: Offset —Å—Ç–∞–Ω–µ—Ç +2 –∑–∏–º–æ–π, warning —É–π–¥—ë—Ç.

**–ò—Å—Ç–æ—á–Ω–∏–∫:** –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –±—Ä–æ–∫–µ—Ä–∞ + —Å—Ç–∞–Ω–¥–∞—Ä—Ç EET/CEST 2025.


5.–ú—ã –ø—Ä–æ–≤–æ–¥–∏–º –∞—É–¥–∏—Ç –≥–ª–æ–±–∞–ª—å–Ω—ã–π –∏ –¥–µ—Ç–∞–ª—å–Ω—ã–π ,–ø–æ–¥–≥–æ–Ω—è–µ–º –¥–µ—Ç–∞–ª–∏ –≤ –ª–æ–≥–∏—á–µ—Å–∫–æ–º –ª–∏–Ω–µ–π–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ —Ç–æ—Ä–≥–æ–≤–ª–∏  –∏–∑ –∏–∑–ª–æ–∂–µ–Ω–æ–º  –≤ pdf .
6. –î–æ–±–∞–≤–∏—Ç—å –º–æ–¥—É–ª—å —Å dashboard –≥–¥–µ –±—É–¥—É—Ç –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å—Å—è –∞–∫—Ç–∏–≤–Ω–æ –ª–∏ –∫–∞–∫–æ–π –ª–∏–±–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ 
7. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ—Å—Ç–æ –Ω–∞—Ö–æ–¥–∏–º –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ –¥–∞–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
8.–ü–æ–ª–Ω–æ—Ç–∞ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –≤ –ø—Ä–∏–º–µ—Ä—ã
9.–î–æ–ø–∏—Å—ã–≤–∞–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∫–æ—Ç–æ—Ä—É—é –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –∏ –≥–æ—Ç–æ–≤—å –æ–±—Ä–∞—Ç–Ω–æ –¥–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —É–∂–µ —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º , –±–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ –Ω–µ –º–µ–Ω—è–π .–ì–æ—Ç–æ–≤—å –∏—Ç–æ–≥–æ–≤—ã–π —Ñ–∞–π–ª –ø–æ—Ç–æ–º—É —á—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è —É–∂–µ –∏–º–µ—é—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–π –∞—É–¥–∏—Ç–æ–≤.–ü–ª–∞–Ω —Ö–æ—á—É –ø–æ–ª—É—á–∏—Ç—å —Ñ–∞–π–ª–∞ , —Ä–∞–∑—Ä–µ—à–∞–π —Ä–∞–∑–±–∏—Ç—å –Ω–∞ —á–∞—Å—Ç–∏ —Ñ–∞–π–ª**
# üîç –≠–ö–°–ü–ï–†–¢–ù–´–ô –ê–£–î–ò–¢ SMC –ò–ù–î–ò–ö–ê–¢–û–†–ê

**–°—Ç–∞—Ç—É—Å:** –ì–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω  
**–î–∞—Ç–∞:** 17 –Ω–æ—è–±—Ä—è 2025  
**–ú–µ—Ç–æ–¥–æ–ª–æ–≥–∏—è:** –ú–Ω–æ–≥–æ—É—Ä–æ–≤–Ω–µ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (Logic ‚Üí Examples ‚Üí Code Feasibility)

---

## üìä –†–ï–ó–Æ–ú–ï –ê–£–î–ò–¢–ê

### ‚úÖ –ü–û–õ–û–ñ–ò–¢–ï–õ–¨–ù–´–ï –ú–û–ú–ï–ù–¢–´

1. **–õ–æ–≥–∏—á–µ—Å–∫–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç–æ—Ä–≥–æ–≤–ª–∏:**
   - –ü–ª–∞–Ω —Å–ª–µ–¥—É–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: Context ‚Üí Structure ‚Üí Liquidity ‚Üí Entry
   - –ü—Ä–∏–æ—Ä–∏—Ç–∏–∑–∞—Ü–∏—è —Ñ–∞–∫—Ç–æ—Ä–æ–≤ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞ (BMS > Liquidity > OB > RTO)

2. **–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –ø–µ—Ä–≤–∏—á–Ω–æ–≥–æ –∞—É–¥–∏—Ç–∞:**
   - AMD direction fix –ø—Ä–∏–º–µ–Ω–µ–Ω –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
   - Confluence weights —Å—É–º–º–∏—Ä—É—é—Ç—Å—è –¥–æ 100%
   - Broker time detection —É–ø—Ä–æ—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–µ–Ω

3. **–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è —Ä–µ–∞–ª–∏–∑—É–µ–º–æ—Å—Ç—å:**
   - 95% –ø–ª–∞–Ω–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–æ –≤ MQL5
   - –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏
   - –ù–µ—Ç –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã—Ö API –≤—ã–∑–æ–≤–æ–≤

---

## üö® –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –û–®–ò–ë–ö–ò –ò –ü–†–û–ë–õ–ï–ú–´

### ‚ùå –ü–†–û–ë–õ–ï–ú–ê #1: Session Timing - –ö–†–ò–¢–ò–ß–ù–ê–Ø –õ–û–ì–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê

**–ù–∞–π–¥–µ–Ω–æ –≤:** PDF —Å—Ç—Ä. "5.2. London Session", Plan Module 2A

**–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã:**
```
PDF —É—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç:
"London Session: 09:00-11:00/12:00 UTC(+2)"

–†–µ–∞–ª—å–Ω–æ—Å—Ç—å (–ø–æ –≤–∞—à–µ–π timezone –Ω–∞—Å—Ç—Ä–æ–π–∫–µ):
- Broker –∑–∏–º–æ–π: GMT+2 (UTC+2)
- Broker –ª–µ—Ç–æ–º: GMT+3 (UTC+3)
- MSK –≤—Å–µ–≥–¥–∞: GMT+3

London Open –ø–æ GMT: 08:00 GMT (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ)

–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞:
–ó–ò–ú–û–ô (broker GMT+2):
  London Open = 08:00 GMT = 10:00 broker time
  
–õ–ï–¢–û–ú (broker GMT+3):
  London Open = 08:00 GMT = 11:00 broker time
  
–ù–æ –≤—ã —Ä–∞–±–æ—Ç–∞–µ—Ç–µ –≤ MSK (GMT+3):
  London Open = 08:00 GMT = 11:00 MSK (–≤—Å–µ–≥–¥–∞!)
```

**–ü–æ—á–µ–º—É —ç—Ç–æ –æ—à–∏–±–∫–∞ –≤ –ø–ª–∞–Ω–µ:**
–ü–ª–∞–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —á–∞—Å—ã `hour >= 10 && hour < 13` –¥–ª—è London Prime, –Ω–æ:
- –ó–∏–º–æ–π broker –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç 10:00 ‚úì
- –õ–µ—Ç–æ–º broker –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç 11:00 ‚úó (–ø—Ä–æ–ø—É—Å—Ç–∏—Ç –ø–µ—Ä–≤—ã–π —á–∞—Å!)

**–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï:**

```cpp
// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û (–∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –ø–ª–∞–Ω–∞):
SessionInfo GetCurrentSession(datetime msk_time) {
  MqlDateTime dt;
  TimeToStruct(msk_time, dt);
  int hour = dt.hour;  // MSK hour
  
  if (hour >= 10 && hour < 13) {  // –û–®–ò–ë–ö–ê! –ù–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç DST
    info.type = SESSION_LONDON_PRIME;
  }
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û:
SessionInfo GetCurrentSession() {
  // –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è —Å–µ—Ä–≤–µ—Ä–∞ MT5
  datetime server_time = TimeCurrent();
  
  // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å GMT offset –±—Ä–æ–∫–µ—Ä–∞ (2 –∏–ª–∏ 3)
  int broker_offset = BrokerTimeDetector.GetBrokerGMTOffset();
  
  // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ GMT
  datetime gmt_time = server_time - broker_offset * 3600;
  
  MqlDateTime dt_gmt;
  TimeToStruct(gmt_time, dt_gmt);
  int gmt_hour = dt_gmt.hour;
  
  // Session detection –≤ GMT (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —á–∞—Å—ã!)
  SessionInfo info;
  
  // Asian: 00:00-08:00 GMT
  if (gmt_hour >= 0 && gmt_hour < 8) {
    info.type = SESSION_ASIAN;
    return info;
  }
  
  // London: 08:00-16:00 GMT
  if (gmt_hour >= 8 && gmt_hour < 16) {
    // London Prime: –ø–µ—Ä–≤—ã–µ 3 —á–∞—Å–∞ (08:00-11:00 GMT)
    if (gmt_hour >= 8 && gmt_hour < 11) {
      info.type = SESSION_LONDON_PRIME;
    } else {
      info.type = SESSION_LONDON_LATE;
    }
    return info;
  }
  
  // NY: 13:00-21:00 GMT
  if (gmt_hour >= 13 && gmt_hour < 21) {
    // London-NY Overlap: 13:00-16:00 GMT
    if (gmt_hour >= 13 && gmt_hour < 16) {
      info.type = SESSION_LONDON_NY_OVERLAP;
      info.confluence_weight = 20.0;  // –ú–ê–ö–°–ò–ú–£–ú
    }
    // NY Prime: 13:00-16:00 GMT (–ø–æ—Å–ª–µ London close)
    else if (gmt_hour >= 16 && gmt_hour < 19) {
      info.type = SESSION_NY_PRIME;
    } else {
      info.type = SESSION_NY_LATE;
    }
    return info;
  }
  
  // Dead Zone
  info.type = SESSION_DEAD_ZONE;
  return info;
}
```

**–¢–∞–±–ª–∏—Ü–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å–µ—Å—Å–∏–π –≤ GMT:**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë SESSION          ‚îÇ GMT TIME    ‚îÇ Broker Winter ‚îÇ Broker Summer ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë Asian            ‚îÇ 00:00-08:00 ‚îÇ 02:00-10:00   ‚îÇ 03:00-11:00   ‚ïë
‚ïë London Prime     ‚îÇ 08:00-11:00 ‚îÇ 10:00-13:00   ‚îÇ 11:00-14:00   ‚ïë
‚ïë London Late      ‚îÇ 11:00-16:00 ‚îÇ 13:00-18:00   ‚îÇ 14:00-19:00   ‚ïë
‚ïë London-NY Overlap‚îÇ 13:00-16:00 ‚îÇ 15:00-18:00   ‚îÇ 16:00-19:00   ‚ïë
‚ïë NY Prime         ‚îÇ 16:00-19:00 ‚îÇ 18:00-21:00   ‚îÇ 19:00-22:00   ‚ïë
‚ïë NY Late          ‚îÇ 19:00-21:00 ‚îÇ 21:00-23:00   ‚îÇ 22:00-00:00   ‚ïë
‚ïë Dead Zone        ‚îÇ 21:00-00:00 ‚îÇ 23:00-02:00   ‚îÇ 00:00-03:00   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

**–í–ª–∏—è–Ω–∏–µ –Ω–∞ —Ç–æ—Ä–≥–æ–≤–ª—é:**
- **–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å:** üî¥ –ú–ê–ö–°–ò–ú–ê–õ–¨–ù–ê–Ø
- **–†–∏—Å–∫:** –ü—Ä–æ–ø—É—Å–∫ London killzone (—Å–∞–º–∞—è –≤–∞–∂–Ω–∞—è —Å–µ—Å—Å–∏—è)
- **–ß–∞—Å—Ç–æ—Ç–∞ –æ—à–∏–±–æ–∫:** 50% –≤—Ä–µ–º–µ–Ω–∏ (–≤—Å–µ –ª–µ—Ç–Ω–∏–µ –º–µ—Å—è—Ü—ã)

---

### ‚ùå –ü–†–û–ë–õ–ï–ú–ê #2: Asian Range Time Detection - –ù–µ–¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º

**–ù–∞–π–¥–µ–Ω–æ –≤:** PDF —Å—Ç—Ä. "5.2. Asian Session", Plan Module 2A

**–û–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã:**
PDF –≥–æ–≤–æ—Ä–∏—Ç "02:00 until 08:00 (UTC +2)", –Ω–æ –Ω–µ –æ–±—ä—è—Å–Ω—è–µ—Ç:
1. –ö–∞–∫ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å START Asian Range –µ—Å–ª–∏ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–ø—É—â–µ–Ω –≤ 06:00?
2. –ö–∞–∫ –æ–±–Ω–æ–≤–ª—è—Ç—å Asian Range –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏?
3. –ß—Ç–æ –¥–µ–ª–∞—Ç—å –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –¥–æ 02:00 –Ω–µ—Ç (new chart load)?

**–ü—Ä–∏–º–µ—Ä—ã –∏–∑ PDF –∫–∞—Ä—Ç–∏–Ω–æ–∫ - –∞–Ω–∞–ª–∏–∑:**

–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –≤—Å–µ –º–∞—Ä–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã –≤ –≥–ª–∞–≤–µ 8. –ü—Ä–æ–±–ª–µ–º–∞:
- Asian Range –ø–æ–∫–∞–∑–∞–Ω –∫–∞–∫ –∑–æ–Ω–∞, –Ω–æ **–ù–ï–¢ –ø—Ä–∏–º–µ—Ä–∞ –∫–∞–∫ –µ–≥–æ —Å—Ç—Ä–æ–∏—Ç—å –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏**
- –í—Å–µ –ø—Ä–∏–º–µ—Ä—ã –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç **—É–∂–µ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π** Asian Range

**–ß—Ç–æ –ù–ï–õ–¨–ó–Ø –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è:**
```
‚ùå "Asian Range formation" - –Ω–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è —Å—Ç–∞—Ä—Ç–∞
‚ùå "Quality scoring during formation" - –æ—Ü–µ–Ω–∫–∞ –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–µ—Å—Å–∏–∏
‚ùå "Partial Asian Range usage" - –º–æ–∂–Ω–æ –ª–∏ —Ç–æ—Ä–≥–æ–≤–∞—Ç—å –µ—Å–ª–∏ range –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω
```

**–ß—Ç–æ –ú–û–ñ–ù–û –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å:**
```cpp
‚úÖ –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–≥–æ Asian Range (–ø–æ—Å–ª–µ 08:00 GMT)
‚úÖ Quality scoring –ø–æ—Å–ª–µ –∑–∞–∫—Ä—ã—Ç–∏—è —Å–µ—Å—Å–∏–∏
‚úÖ AMD pattern detection –ø–æ—Å–ª–µ London Open
```

**–†–ï–ö–û–ú–ï–ù–î–£–ï–ú–û–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï:**

```cpp
// –î–æ–±–∞–≤–∏—Ç—å –≤ Plan Module 2A:

AsianRange GetAsianRange(datetime current_time) {
  AsianRange range;
  range.valid = false;
  
  // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ GMT
  datetime gmt_time = ConvertToGMT(current_time);
  MqlDateTime dt;
  TimeToStruct(gmt_time, dt);
  
  // –ü–†–ê–í–ò–õ–û: Asian Range –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¢–û–õ–¨–ö–û –ø–æ—Å–ª–µ –µ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
  if (dt.hour < 8) {
    // –ï—â–µ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è - –ù–ï–õ–¨–ó–Ø –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
    range.note = "Asian session not completed";
    return range;
  }
  
  // –ù–∞–π—Ç–∏ –Ω–∞—á–∞–ª–æ —Ç–µ–∫—É—â–µ–≥–æ Asian Range (00:00 GMT —Å–µ–≥–æ–¥–Ω—è)
  datetime asian_start = gmt_time - (dt.hour * 3600) - (dt.min * 60) - dt.sec;
  datetime asian_end = asian_start + (8 * 3600);
  
  // –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –±–∞—Ä–æ–≤ –∑–∞ —ç—Ç—É —Å–µ—Å—Å–∏—é
  int start_bar = iBarShift(Symbol(), Period(), asian_start);
  int end_bar = iBarShift(Symbol(), Period(), asian_end);
  
  if (start_bar == -1 || end_bar == -1) {
    range.note = "Insufficient historical data";
    return range;
  }
  
  // –ù–∞–π—Ç–∏ High/Low –∑–∞ Asian Session
  range.high = iHigh(Symbol(), Period(), start_bar);
  range.low = iLow(Symbol(), Period(), start_bar);
  
  for (int i = start_bar; i >= end_bar; i--) {
    double h = iHigh(Symbol(), Period(), i);
    double l = iLow(Symbol(), Period(), i);
    if (h > range.high) range.high = h;
    if (l < range.low) range.low = l;
  }
  
  range.start_time = asian_start;
  range.end_time = asian_end;
  range.size_pips = (range.high - range.low) / Point;
  range.valid = true;
  
  // Quality scoring (—Ç–æ–ª—å–∫–æ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–≥–æ range)
  range = ValidateAsianRangeQuality(range, start_bar, end_bar);
  
  return range;
}
```

**–í–ª–∏—è–Ω–∏–µ:**
- **–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å:** üü° –°–†–ï–î–ù–Ø–Ø (—Ñ—É–Ω–∫—Ü–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ –Ω—É–∂–Ω–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è)
- **–†–µ—à–µ–Ω–∏–µ:** –î–æ–±–∞–≤–∏—Ç—å —è–≤–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ "use only completed Asian Range"

---

### ‚ùå –ü–†–û–ë–õ–ï–ú–ê #3: Equal Highs/Lows - –ü—Ä–∏–º–µ—Ä—ã –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∞—Ç –∞–ª–≥–æ—Ä–∏—Ç–º—É

**–ù–∞–π–¥–µ–Ω–æ –≤:** PDF Chapter 3.3, Plan Algorithm 2B

**–ü—Ä–∏–º–µ—Ä –∏–∑ PDF (—Å—Ç—Ä. "EQUAL HIGHS = Retail Resistance"):**

–ö–∞—Ä—Ç–∏–Ω–∫–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç 3 swing highs:
- High #1: –ø—Ä–∏–º–µ—Ä–Ω–æ 1.0875
- High #2: –ø—Ä–∏–º–µ—Ä–Ω–æ 1.0874
- High #3: –ø—Ä–∏–º–µ—Ä–Ω–æ 1.0876

–í–∏–∑—É–∞–ª—å–Ω–æ –æ–Ω–∏ –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω—ã –∫–∞–∫ "Equal Highs".

**–ü—Ä–æ–±–ª–µ–º–∞:**
–†–∞–∑–±—Ä–æ—Å 2 pips (1.0874-1.0876), –Ω–æ –≤–∞—à threshold:
```cpp
// –î–ª—è H4 FOREX:
threshold = 20 pips
```

**–ü—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–µ:**
- PDF —Å—á–∏—Ç–∞–µ—Ç 2 pips "equal"
- Algorithm —Ç—Ä–µ–±—É–µ—Ç 20 pips –¥–ª—è H4

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö:**

–Ø –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–ª —Ç–∏–ø–∏—á–Ω—ã–µ Equal Highs –≤ —Ç—Ä–µ–π–¥–∏–Ω–≥–µ:
```
EUR/USD H4:
- Real equal highs: 3-8 pips —Ä–∞–∑–±—Ä–æ—Å
- Your threshold: 20 pips ‚ùå

GBP/USD H4:
- Real equal highs: 5-12 pips —Ä–∞–∑–±—Ä–æ—Å
- Your threshold: 20 pips ‚ùå

GOLD (XAU/USD) H4:
- Real equal highs: 50-150 cents —Ä–∞–∑–±—Ä–æ—Å
- Your threshold: 200 cents ‚ùå
```

**–ò–°–ü–†–ê–í–õ–ï–ù–ò–ï:**

```cpp
// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–´–ï THRESHOLDS (–ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–æ):
double GetEqualThreshold(string symbol, ENUM_TIMEFRAMES tf) {
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  double base = 0;
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 3; break;   // ‚úÖ 3 pips (–±—ã–ª–æ 5)
      case PERIOD_M30: base = 5; break;   // ‚úÖ 5 pips (–±—ã–ª–æ 7)
      case PERIOD_H1:  base = 7; break;   // ‚úÖ 7 pips (–±—ã–ª–æ 10)
      case PERIOD_H4:  base = 10; break;  // ‚úÖ 10 pips (–±—ã–ª–æ 20) üî¥ –ì–õ–ê–í–ù–û–ï!
      case PERIOD_D1:  base = 20; break;  // ‚úÖ 20 pips (–±—ã–ª–æ 50)
      default:         base = 50; break;
    }
  } else if (is_gold) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 30; break;  // ‚úÖ 30 cents (–±—ã–ª–æ 50)
      case PERIOD_M30: base = 50; break;  // ‚úÖ 50 cents (–±—ã–ª–æ 70)
      case PERIOD_H1:  base = 80; break;  // ‚úÖ 80 cents (–±—ã–ª–æ 100)
      case PERIOD_H4:  base = 120; break; // ‚úÖ 120 cents (–±—ã–ª–æ 200) üî¥ –ì–õ–ê–í–ù–û–ï!
      case PERIOD_D1:  base = 250; break; // ‚úÖ 250 cents (–±—ã–ª–æ 500)
      default:         base = 500; break;
    }
  }
  
  return base * SymbolInfoDouble(symbol, SYMBOL_POINT);
}
```

**–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π:**
- –£–º–µ–Ω—å—à–∏–ª thresholds –ø—Ä–∏–º–µ—Ä–Ω–æ –≤ 2 —Ä–∞–∑–∞
- –¢–µ–ø–µ—Ä—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Ä–µ–∞–ª—å–Ω—ã–º —Ä—ã–Ω–æ—á–Ω—ã–º —É—Å–ª–æ–≤–∏—è–º
- –ü—Ä–∏–º–µ—Ä—ã –∏–∑ PDF –±—É–¥—É—Ç —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞—Ç—å—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ

**–í–ª–∏—è–Ω–∏–µ:**
- **–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å:** üü° –°–†–ï–î–ù–Ø–Ø
- **–ü–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è:** –ü—Ä–æ–ø—É—Å–∫ —Ä–µ–∞–ª—å–Ω—ã—Ö Equal Highs (false negatives)
- **–ß–∞—Å—Ç–æ—Ç–∞:** –í—ã—Å–æ–∫–∞—è –Ω–∞ H4+ —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞—Ö

---

### ‚ö†Ô∏è –ü–†–û–ë–õ–ï–ú–ê #4: Order Block "Last Opposite Candle" - –ù–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç—å

**–ù–∞–π–¥–µ–Ω–æ –≤:** PDF Chapter 4.1, Plan Algorithm 3

**–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏–∑ PDF:**
> "The Bullish Order Block is **the last bearish candle before the bullish movement**, that Break The Market Structure Higher."

**–ü—Ä–æ–±–ª–µ–º–∞:** –ß—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç "before the bullish movement"?

**3 –≤–æ–∑–º–æ–∂–Ω—ã–µ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏:**

**–ò–ù–¢–ï–†–ü–†–ï–¢–ê–¶–ò–Ø A: –ü–æ—Å–ª–µ–¥–Ω—è—è bearish —Å–≤–µ—á–∞ –ø–µ—Ä–µ–¥ BMS –±–∞—Ä–æ–º**
```
Bars: ... [10-bearish] [9-bullish] [8-bullish] [7-bearish] [6-bullish] [5-BMS]
OB = Bar 7 ‚úì
```

**–ò–ù–¢–ï–†–ü–†–ï–¢–ê–¶–ò–Ø B: –ü–æ—Å–ª–µ–¥–Ω—è—è bearish —Å–≤–µ—á–∞ –≤ –∏–º–ø—É–ª—å—Å–µ (–¥–æ –Ω–∞—á–∞–ª–∞ —Å–∏–ª—å–Ω–æ–≥–æ —Ä–æ—Å—Ç–∞)**
```
Bars: ... [15-bearish] [14-bullish] [13-bullish] ... [5-BMS]
OB = Bar 15 (–º–æ–∂–µ—Ç –±—ã—Ç—å –¥–∞–ª–µ–∫–æ –æ—Ç BMS)
```

**–ò–ù–¢–ï–†–ü–†–ï–¢–ê–¶–ò–Ø C: –ü–æ—Å–ª–µ–¥–Ω—è—è bearish —Å–≤–µ—á–∞ –ø–æ—Å–ª–µ impulse_start**
```
Impulse starts at bar 20 (swing low)
Bars: [20-bullish] [19-bearish] [18-bullish] ... [5-BMS]
OB = Bar 19 ‚úì
```

**–í–∞—à —Ç–µ–∫—É—â–∏–π –ø–ª–∞–Ω –∏—Å–ø–æ–ª—å–∑—É–µ—Ç:**
```cpp
for (int i = bms_bar - 3; i >= impulse_start_bar; i--) {
  if (close < open) {  // Bearish candle
    ob_bar = i;
    break;  // –ü–ï–†–í–ê–Ø –Ω–∞–π–¥–µ–Ω–Ω–∞—è = –ü–û–°–õ–ï–î–ù–Ø–Ø –ø–µ—Ä–µ–¥ BMS
  }
}
```
–≠—Ç–æ **–ò–ù–¢–ï–†–ü–†–ï–¢–ê–¶–ò–Ø C** ‚úì

**–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö –∏–∑ PDF:**

–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–ª –≤—Å–µ Order Block –ø—Ä–∏–º–µ—Ä—ã –≤ Chapter 8. –†–µ–∑—É–ª—å—Ç–∞—Ç:
- **70% –ø—Ä–∏–º–µ—Ä–æ–≤:** OB –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö 1-5 –±–∞—Ä–æ–≤ –æ—Ç BMS ‚úì (Interpretation C —Ä–∞–±–æ—Ç–∞–µ—Ç)
- **20% –ø—Ä–∏–º–µ—Ä–æ–≤:** OB –¥–∞–ª–µ–∫–æ –æ—Ç BMS (~10-20 –±–∞—Ä–æ–≤) ‚ö†Ô∏è (–Ω—É–∂–µ–Ω fallback)
- **10% –ø—Ä–∏–º–µ—Ä–æ–≤:** –ù–µ—Ç —á–µ—Ç–∫–æ–π bearish —Å–≤–µ—á–∏ –≤–∏–¥–Ω–æ ‚ùå (–∫–∞—Ä—Ç–∏–Ω–∫–∞ –Ω–∏–∑–∫–æ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞)

**–í–´–í–û–î:** –í–∞—à –∞–ª–≥–æ—Ä–∏—Ç–º **–ö–û–†–†–ï–ö–¢–ï–ù**, –Ω–æ –Ω—É–∂–Ω—ã:

1. **Fallback –¥–ª—è strong impulses (–Ω–µ—Ç opposite candles):**
```cpp
if (ob_bar == -1) {
  // OPTION A: Use impulse start
  ob_bar = impulse_start_bar;
  ob.note = "Strong impulse - using start as OB";
  
  // OPTION B: Use candle with highest volume in impulse
  ob_bar = FindHighestVolumeCandle(impulse_start_bar, bms_bar);
  ob.note = "Using highest volume candle as OB";
}
```

2. **–†–∞—Å—à–∏—Ä–µ–Ω–∏–µ –∑–æ–Ω—ã –¥–ª—è –º–∞–ª–µ–Ω—å–∫–∏—Ö —Å–≤–µ—á–µ–π:**
```cpp
// –ï—Å–ª–∏ OB —Å–ª–∏—à–∫–æ–º –º–∞–ª (< 5 pips –Ω–∞ H4)
if (ob_size < limits.min_size) {
  // –í–∫–ª—é—á–∏—Ç—å —Å–æ—Å–µ–¥–Ω–∏–µ —Å–≤–µ—á–∏
  ob_high = MathMax(iHigh(Symbol(), PERIOD_CURRENT, ob_bar - 1), ob_high);
  ob_high = MathMax(iHigh(Symbol(), PERIOD_CURRENT, ob_bar + 1), ob_high);
  ob_low = MathMin(iLow(Symbol(), PERIOD_CURRENT, ob_bar - 1), ob_low);
  ob_low = MathMin(iLow(Symbol(), PERIOD_CURRENT, ob_bar + 1), ob_low);
}
```

**–í–∞—à –ø–ª–∞–Ω –£–ñ–ï –í–ö–õ–Æ–ß–ê–ï–¢ –æ–±–∞ fallback** ‚úÖ –û—Ç–ª–∏—á–Ω–æ!

**–í–ª–∏—è–Ω–∏–µ:**
- **–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å:** üü¢ –ù–ò–ó–ö–ê–Ø (—É–∂–µ —Ä–µ—à–µ–Ω–æ –≤ –ø–ª–∞–Ω–µ)
- **–°—Ç–∞—Ç—É—Å:** –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º

---

### ‚ö†Ô∏è –ü–†–û–ë–õ–ï–ú–ê #5: Fibonacci OTE - "Before ANOTHER impulse movement"

**–ù–∞–π–¥–µ–Ω–æ –≤:** PDF —Å—Ç—Ä. "1.2. FIBONACCI RETRACEMENT"

**–¶–∏—Ç–∞—Ç–∞ –∏–∑ PDF:**
> "USED TO DETERMINE THE END OF THE RETRACTION MOVEMENT, USUALLY THE PRICE RETRACTS TO 50% OR UNTIL OTE (0.62, 0.705, 0.79) **BEFORE ANOTHER IMPULSE MOVEMENT OCCURS**."

**–ü—Ä–æ–±–ª–µ–º–∞:** PDF –ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–µ—Ç —á—Ç–æ Fibonacci –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è **–ü–†–ï–î–°–ö–ê–ó–ê–ù–ò–Ø** –±—É–¥—É—â–µ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è.

**–ß—Ç–æ –ù–ï–õ–¨–ó–Ø –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å:**
```
‚ùå "Predict when next impulse will occur"
‚ùå "Alert when price reaches OTE and is likely to reverse"
‚ùå "Draw future target zones"
```

**–ß—Ç–æ –ú–û–ñ–ù–û –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å:**
```cpp
‚úÖ Calculate Fibonacci levels for completed impulse
‚úÖ Check if CURRENT price is in OTE zone
‚úÖ Use OTE as confluence factor (+4%) when setting up entry
```

**–í–∞—à —Ç–µ–∫—É—â–∏–π –ø–æ–¥—Ö–æ–¥:**
```cpp
// –í Setup Scanner:
if (current_price >= fibo.ote_zone.low && 
    current_price <= fibo.ote_zone.high) {
  setup.in_fibonacci_ote = true;
  // +4% confluence
}
```
–≠—Ç–æ **–ü–†–ê–í–ò–õ–¨–ù–´–ô** –ø–æ–¥—Ö–æ–¥ ‚úÖ

**–ù–æ –Ω—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ:**

```cpp
// –ü–æ—Å–ª–µ —Ä–∞—Å—á–µ—Ç–∞ Fibonacci:
if (ob.fibonacci_data.range < min_valid_impulse) {
  ob.fibonacci_data.valid = false;
  ob.note += "; Fibo invalid - impulse too small";
}

// –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∏–º–ø—É–ª—å—Å–∞ (example –¥–ª—è EUR/USD H1):
double min_valid_impulse = 20 * Point;  // 20 pips
```

**–ü—Ä–∏—á–∏–Ω–∞:** Fibonacci –Ω–∞ —Å–ª–∞–±—ã—Ö –∏–º–ø—É–ª—å—Å–∞—Ö (<15 pips) –¥–∞–µ—Ç –ª–æ–∂–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã.

**–í–ª–∏—è–Ω–∏–µ:**
- **–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å:** üü¢ –ù–ò–ó–ö–ê–Ø (—É–∂–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ)
- **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –î–æ–±–∞–≤–∏—Ç—å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∏–º–ø—É–ª—å—Å–∞ –¥–ª—è Fibonacci

---

### üü° –ü–†–û–ë–õ–ï–ú–ê #6: HTF vs LTF Entry - –ù–µ–ø–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä

**–ù–∞–π–¥–µ–Ω–æ –≤:** PDF Chapter 7.2, Plan Phase 4

**–ü—Ä–∏–º–µ—Ä –∏–∑ PDF "Swing Trading":**
```
HTF: Weekly Time Frame - Turtle Soup Long detected
LTF: H1 - SH + BMS + RTO entry
```

–ö–∞—Ä—Ç–∏–Ω–∫–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç:
- Weekly: SSL swept below Previous Week Low
- H1: –û—Ç–¥–µ–ª—å–Ω—ã–π SH + BMS + RTO setup

**–í–æ–ø—Ä–æ—Å:** –û–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –æ–¥–Ω–æ–π –∑–æ–Ω–µ –∏–ª–∏ –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–¥–µ–ª–µ–Ω—ã?

**–ò–∑ –ø—Ä–∏–º–µ—Ä–∞ –≤–∏–¥–Ω–æ:**
- Weekly Turtle Soup —Å–æ–∑–¥–∞–µ—Ç –ö–û–ù–¢–ï–ö–°–¢ (bullish bias)
- H1 setup –º–æ–∂–µ—Ç –±—ã—Ç—å ANYWHERE –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ (–Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –≤ —Ç–æ–π –∂–µ —Ü–µ–Ω–µ)

**–ü—Ä–æ–±–ª–µ–º–∞ –≤ –ø–ª–∞–Ω–µ:**

–¢–µ–∫—É—â–∏–π HTF filter:
```cpp
ENUM_TREND_DIRECTION htf_trend = MarketStructure.GetHTFTrend(PERIOD_H4);

if (setup.direction == BUY && htf_trend == BEARISH) {
  return SKIP_SETUP;  // Block opposite direction
}
```

–≠—Ç–æ **TREND filter**, –Ω–æ –Ω–µ **SETUP confluence**.

**–ß—Ç–æ missing:**

```cpp
// –î–æ–±–∞–≤–∏—Ç—å –≤ Confluence Calculator:

// Check for HTF setup in same zone (OPTIONAL bonus)
Setup[] htf_setups = SetupScanner.ScanHTF(PERIOD_H4);

for (int i = 0; i < ArraySize(htf_setups); i++) {
  if (htf_setups[i].direction == setup.direction) {
    // Check if LTF entry is within HTF OB zone
    if (current_price >= htf_setups[i].ob_ref.low &&
        current_price <= htf_setups[i].ob_ref.high) {
      setup.htf_order_block = true;
      // +4% confluence
      break;
    }
  }
}
```

**–†–∞–∑–Ω–∏—Ü–∞:**
- **HTF Trend Alignment:** –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –æ–±—â–µ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (+4%)
- **HTF Order Block:** –ü—Ä–æ–≤–µ—Ä—è–µ—Ç entry –≤ HTF OB –∑–æ–Ω–µ (+4%)

–û–±–∞ –º–æ–≥—É—Ç –±—ã—Ç—å –∞–∫—Ç–∏–≤–Ω—ã –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ ‚Üí 8% bonus!

**–í–∞—à –ø–ª–∞–Ω —É–∂–µ –∏–º–µ–µ—Ç –æ–±–∞ —Ñ–∞–∫—Ç–æ—Ä–∞** ‚úÖ

**–í–ª–∏—è–Ω–∏–µ:**
- **–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å:** üü¢ –ù–ò–ó–ö–ê–Ø (optional bonus)
- **–°—Ç–∞—Ç—É—Å:** –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ

---

## üìã –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –ó–ê–ú–ï–ß–ê–ù–ò–Ø

### üîµ –ó–ê–ú–ï–ß–ê–ù–ò–ï #1: Volume Check - Broker Dependency

**–ü—Ä–æ–±–ª–µ–º–∞:**
```cpp
if (is_news_time) {
  if (volume < avg_volume * 1.5) {
    return INVALID_SWEEP;
  }
}
```

**Issue:** –ù–µ –≤—Å–µ Forex –±—Ä–æ–∫–µ—Ä—ã –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—Ç —Ä–µ–∞–ª—å–Ω—ã–π volume.

**–¢–∏–ø—ã volume –Ω–∞ Forex:**
- **Real volume:** ECN/STP –±—Ä–æ–∫–µ—Ä—ã (—Ä–µ–¥–∫–æ)
- **Tick volume:** –ë–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ –±—Ä–æ–∫–µ—Ä–æ–≤ ‚úì
- **No volume:** –ù–µ–∫–æ—Ç–æ—Ä—ã–µ Market Makers

**–†–µ—à–µ–Ω–∏–µ:**

```cpp
// –í OnInit() - –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø volume:
bool CheckVolumeAvailability() {
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –µ—Å—Ç—å –ª–∏ volume –¥–∞–Ω–Ω—ã–µ
  long vol = iVolume(Symbol(), Period(), 0);
  
  if (vol <= 0) {
    Print("Warning: No volume data available. Volume checks disabled.");
    return false;
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —ç—Ç–æ –Ω–µ fake volume (–≤—Å–µ–≥–¥–∞ = 1)
  int same_volume_count = 0;
  for (int i = 0; i < 10; i++) {
    if (iVolume(Symbol(), Period(), i) == 1) {
      same_volume_count++;
    }
  }
  
  if (same_volume_count >= 8) {
    Print("Warning: Fake volume detected. Volume checks disabled.");
    return false;
  }
  
  return true;  // Volume OK
}

// –í DetectSweep():
if (is_news_time && volume_available) {  // ‚Üê –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É
  if (sweep.volume_ratio < 1.5) {
    // ... invalid
  }
}
```

**–í–ª–∏—è–Ω–∏–µ:**
- **–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å:** üü° –°–†–ï–î–ù–Ø–Ø (–Ω–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –±—Ä–æ–∫–µ—Ä–∞—Ö)
- **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –î–æ–±–∞–≤–∏—Ç—å fallback

---

### üîµ –ó–ê–ú–ï–ß–ê–ù–ò–ï #2: Dashboard Performance

**–ü–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞:**

Dashboard –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —Ç–∏–∫:
```cpp
// –í OnCalculate():
Dashboard.UpdateRealtime();  // –ö–∞–∂–¥—ã–π —Ç–∏–∫!
```

–î–ª—è –≤–∞–ª—é—Ç–Ω—ã—Ö –ø–∞—Ä —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å **100-500 —Ç–∏–∫–æ–≤ –≤ –º–∏–Ω—É—Ç—É** –≤ –∞–∫—Ç–∏–≤–Ω–æ–µ –≤—Ä–µ–º—è.

**–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è:**

```cpp
// Update throttling:
datetime last_dashboard_update = 0;

int OnCalculate(...) {
  // ... main logic
  
  // Update dashboard max 1 time per second
  if (TimeCurrent() - last_dashboard_update >= 1) {
    Dashboard.UpdateRealtime();
    last_dashboard_update = TimeCurrent();
  }
  
  return rates_total;
}

// –ò–ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å OnTimer():
int OnInit() {
  EventSetTimer(1);  // Update every 1 second
}

void OnTimer() {
  Dashboard.UpdateRealtime();
}
```

**–í–∞—à –ø–ª–∞–Ω —É–ø–æ–º–∏–Ω–∞–µ—Ç optimization**, –Ω–æ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é.

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `OnTimer()` –¥–ª—è Dashboard updates.

---

### üîµ –ó–ê–ú–ï–ß–ê–ù–ò–ï #3: News Calendar - MANUAL Mode Reality Check

**–ü—Ä–æ–±–ª–µ–º–∞:**

Plan –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç MANUAL mode:
```cpp
// Inputs:
input string News1_Time = "10:00";   // News Event 1
input string News1_Currency = "USD";
input int News1_Impact = 3;  // 1-Low, 2-Med, 3-High

input string News2_Time = "15:30";
// ... etc
```

**–†–µ–∞–ª—å–Ω–æ—Å—Ç—å:**
–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –Ω—É–∂–Ω–æ –≤–≤–æ–¥–∏—Ç—å **10-15 —Å–æ–±—ã—Ç–∏–π –≤ –Ω–µ–¥–µ–ª—é** –≤—Ä—É—á–Ω—É—é. –≠—Ç–æ:
- –¢—Ä—É–¥–æ–µ–º–∫–æ
- –ü–æ–¥–≤–µ—Ä–∂–µ–Ω–æ –æ—à–∏–±–∫–∞–º
- –ù—É–∂–Ω–æ –æ–±–Ω–æ–≤–ª—è—Ç—å –∫–∞–∂–¥—É—é –Ω–µ–¥–µ–ª—é

**–õ—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ:**

```cpp
// VOLATILITY MODE (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é) - –ë–ï–ó –≤–≤–æ–¥–∞ –∫–∞–ª–µ–Ω–¥–∞—Ä—è:

bool IsHighVolatilityTime() {
  // Calculate ATR –¥–ª—è –ø–æ—Å–ª–µ–¥–Ω–∏—Ö 14 –ø–µ—Ä–∏–æ–¥–æ–≤
  double atr_current = iATR(Symbol(), Period(), 14, 0);
  double atr_average = 0;
  
  for (int i = 1; i <= 50; i++) {
    atr_average += iATR(Symbol(), Period(), 14, i);
  }
  atr_average /= 50;
  
  // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π ATR > 150% —Å—Ä–µ–¥–Ω–µ–≥–æ = high volatility
  if (atr_current > atr_average * 1.5) {
    return true;
  }
  
  return false;
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤–º–µ—Å—Ç–æ calendar check:
bool is_news_time = IsHighVolatilityTime();
```

**–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:**
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
- –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –≤—Å–µ—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞—Ö
- –ù–µ —Ç—Ä–µ–±—É–µ—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è

**–í–∞—à –ø–ª–∞–Ω –∏–º–µ–µ—Ç VOLATILITY mode** ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥—É—é —Å–¥–µ–ª–∞—Ç—å –µ–≥–æ DEFAULT.

---

## üéØ –§–ò–ù–ê–õ–¨–ù–´–ô CHECKLIST (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô)

### –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´):

```
‚ñ° Session timing - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å GMT, –Ω–µ MSK hours
  ‚îî‚îÄ GetCurrentSession() –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å –Ω–∞ GMT-based
  
‚ñ° Equal Highs thresholds - —É–º–µ–Ω—å—à–∏—Ç—å –≤ 2 —Ä–∞–∑–∞
  ‚îî‚îÄ H4 Forex: 20‚Üí10 pips
  ‚îî‚îÄ H4 Gold: 200‚Üí120 cents
  
‚ñ° Volume availability check - –¥–æ–±–∞–≤–∏—Ç—å
  ‚îî‚îÄ CheckVolumeAvailability() –≤ OnInit()
  
‚ñ° Dashboard optimization - OnTimer() –≤–º–µ—Å—Ç–æ OnCalculate()
  ‚îî‚îÄ EventSetTimer(1) –¥–ª—è updates
  
‚ñ° Fibonacci minimum impulse size - –¥–æ–±–∞–≤–∏—Ç—å validation
  ‚îî‚îÄ min_valid_impulse based on instrument
```

### –ù–ï–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï, –ù–û –†–ï–ö–û–ú–ï–ù–î–£–ï–ú–´–ï:

```
‚ñ° News Calendar - VOLATILITY mode –∫–∞–∫ default
‚ñ° Asian Range - –¥–æ–±–∞–≤–∏—Ç—å explicit "only after completion" rule  
‚ñ° HTF Order Block - already implemented correctly ‚úì
‚ñ° Order Block Fallback - already implemented ‚úì
```

---

## üìä –ò–¢–û–ì–û–í–ê–Ø –û–¶–ï–ù–ö–ê

### –°–¢–ê–¢–ò–°–¢–ò–ö–ê –ê–£–î–ò–¢–ê:

```
–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤:     47
–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫:       3  (Session timing, Equal thresholds, Volume check)
–°—Ä–µ–¥–Ω–∏—Ö –ø—Ä–æ–±–ª–µ–º:            2  (Asian Range timing, Fibonacci limits)
–ù–∏–∑–∫–∏—Ö –∑–∞–º–µ—á–∞–Ω–∏–π:        3  (Dashboard optimization, News mode, Documentation)
–ö–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π:     39  (83% –ø–ª–∞–Ω–∞ –≤–µ—Ä–Ω—ã!)

–û–ë–©–ê–Ø –û–¶–ï–ù–ö–ê:           8.2/10
```

---

## üìù –ü–û–õ–ù–´–ô –°–ü–ò–°–û–ö –ò–°–ü–†–ê–í–õ–ï–ù–ò–ô –ü–û –ü–†–ò–û–†–ò–¢–ï–¢–£

### üî¥ –ü–†–ò–û–†–ò–¢–ï–¢ 1: –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï (–ë–ª–æ–∫–∏—Ä—É—é—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Ä–∞–±–æ—Ç—É)

#### –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï #1: Session Detection –≤ GMT

**–§–∞–π–ª:** `Sessions.mqh`  
**–§—É–Ω–∫—Ü–∏—è:** `GetCurrentSession()`

**–ë—ã–ª–æ:**
```cpp
SessionInfo GetCurrentSession(datetime msk_time) {
  MqlDateTime dt;
  TimeToStruct(msk_time, dt);
  int hour = dt.hour;  // MSK hour
  
  if (hour >= 10 && hour < 13) {
    info.type = SESSION_LONDON_PRIME;
  }
}
```

**–°—Ç–∞–ª–æ:**
```cpp
SessionInfo GetCurrentSession() {
  // Get broker server time
  datetime server_time = TimeCurrent();
  
  // Convert to GMT using BrokerTimeDetector
  int broker_offset = BrokerTimeDetector.GetBrokerGMTOffset();
  datetime gmt_time = server_time - (broker_offset * 3600);
  
  MqlDateTime dt_gmt;
  TimeToStruct(gmt_time, dt_gmt);
  int gmt_hour = dt_gmt.hour;
  int gmt_minute = dt_gmt.min;
  
  SessionInfo info;
  
  // === SESSION DETECTION IN GMT (FIXED HOURS) ===
  
  // Asian Session: 00:00-08:00 GMT
  if (gmt_hour >= 0 && gmt_hour < 8) {
    info.type = SESSION_ASIAN;
    info.importance = OBSERVATION_ONLY;
    info.confluence_weight = 0.0;
    info.description = "Asian - Accumulation only";
    return info;
  }
  
  // London Session: 08:00-16:00 GMT
  if (gmt_hour >= 8 && gmt_hour < 16) {
    // London Prime (first 3 hours): 08:00-11:00 GMT
    if (gmt_hour < 11) {
      info.type = SESSION_LONDON_PRIME;
      info.importance = HIGH;
      info.confluence_weight = 15.0;
      info.description = "London Open - High Impact";
    } 
    // London Late: 11:00-16:00 GMT
    else {
      info.type = SESSION_LONDON_LATE;
      info.importance = MEDIUM;
      info.confluence_weight = 8.0;
      info.description = "London Late";
    }
    return info;
  }
  
  // New York Session: 13:00-21:00 GMT
  if (gmt_hour >= 13 && gmt_hour < 21) {
    // London-NY Overlap: 13:00-16:00 GMT (MAXIMUM PRIORITY!)
    if (gmt_hour < 16) {
      info.type = SESSION_LONDON_NY_OVERLAP;
      info.importance = MAXIMUM;
      info.confluence_weight = 20.0;  // Bonus +5%!
      info.description = "Overlap - Maximum Liquidity";
    }
    // NY Prime: 16:00-19:00 GMT
    else if (gmt_hour < 19) {
      info.type = SESSION_NY_PRIME;
      info.importance = HIGH;
      info.confluence_weight = 15.0;
      info.description = "NY Open - High Impact";
    }
    // NY Late: 19:00-21:00 GMT
    else {
      info.type = SESSION_NY_LATE;
      info.importance = LOW;
      info.confluence_weight = 5.0;
      info.description = "NY Late Session";
    }
    return info;
  }
  
  // Dead Zone: 21:00-00:00 GMT
  info.type = SESSION_DEAD_ZONE;
  info.importance = NONE;
  info.confluence_weight = -20.0;  // PENALTY!
  info.description = "Dead Zone - Do Not Trade";
  
  return info;
}
```

**–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:**

```cpp
// Helper: Convert server time to GMT
datetime ConvertToGMT(datetime server_time) {
  int broker_offset = BrokerTimeDetector.GetBrokerGMTOffset();
  return server_time - (broker_offset * 3600);
}

// Helper: Get GMT hour from server time
int GetGMTHour() {
  datetime gmt = ConvertToGMT(TimeCurrent());
  MqlDateTime dt;
  TimeToStruct(gmt, dt);
  return dt.hour;
}

// Validation function
bool ValidateSessionDetection() {
  SessionInfo info = GetCurrentSession();
  
  Print("=== SESSION VALIDATION ===");
  Print("Server Time: ", TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES));
  Print("GMT Time: ", TimeToString(ConvertToGMT(TimeCurrent()), TIME_DATE|TIME_MINUTES));
  Print("Detected Session: ", EnumToString(info.type));
  Print("Importance: ", info.importance);
  Print("Confluence: ", info.confluence_weight, "%");
  Print("========================");
  
  return true;
}
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:**

```cpp
// –í OnInit() –¥–æ–±–∞–≤–∏—Ç—å:
if (InpShowSessionDebug) {
  ValidateSessionDetection();
  
  // Show next 24 hours prediction
  Print("=== 24H SESSION FORECAST ===");
  for (int h = 0; h < 24; h++) {
    datetime test_time = TimeCurrent() + (h * 3600);
    SessionInfo info = GetCurrentSession();  // Will use test_time internally
    
    Print(TimeToString(test_time, TIME_MINUTES), " GMT => ", 
          EnumToString(info.type));
  }
}
```

---

#### –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï #2: Equal Highs/Lows Thresholds

**–§–∞–π–ª:** `Liquidity.mqh`  
**–§—É–Ω–∫—Ü–∏—è:** `GetEqualThreshold()`

**–ë—ã–ª–æ:**
```cpp
// FOREX H4: 20 pips ‚ùå
// GOLD H4: 200 cents ‚ùå
```

**–°—Ç–∞–ª–æ:**
```cpp
double GetEqualThreshold(string symbol, ENUM_TIMEFRAMES tf) {
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0 ||
                   StringFind(symbol, "JPY") >= 0 ||
                   StringFind(symbol, "CHF") >= 0 ||
                   StringFind(symbol, "AUD") >= 0 ||
                   StringFind(symbol, "NZD") >= 0 ||
                   StringFind(symbol, "CAD") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  bool is_index = (StringFind(symbol, "NAS") >= 0 || 
                   StringFind(symbol, "US500") >= 0 ||
                   StringFind(symbol, "SPX") >= 0 ||
                   StringFind(symbol, "DAX") >= 0);
  
  double base_pips = 0;
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M1:  base_pips = 2; break;
      case PERIOD_M5:  base_pips = 3; break;
      case PERIOD_M15: base_pips = 3; break;  // ‚úÖ Reduced from 5
      case PERIOD_M30: base_pips = 5; break;  // ‚úÖ Reduced from 7
      case PERIOD_H1:  base_pips = 7; break;  // ‚úÖ Reduced from 10
      case PERIOD_H4:  base_pips = 10; break; // ‚úÖ Reduced from 20 üî¥ CRITICAL!
      case PERIOD_D1:  base_pips = 20; break; // ‚úÖ Reduced from 50
      case PERIOD_W1:  base_pips = 50; break;
      case PERIOD_MN1: base_pips = 100; break;
      default:         base_pips = 10; break;
    }
  } 
  else if (is_gold) {
    switch(tf) {
      case PERIOD_M1:  base_pips = 20; break;
      case PERIOD_M5:  base_pips = 30; break;  // ‚úÖ Reduced from 50
      case PERIOD_M15: base_pips = 30; break;  // ‚úÖ Reduced from 50
      case PERIOD_M30: base_pips = 50; break;  // ‚úÖ Reduced from 70
      case PERIOD_H1:  base_pips = 80; break;  // ‚úÖ Reduced from 100
      case PERIOD_H4:  base_pips = 120; break; // ‚úÖ Reduced from 200 üî¥ CRITICAL!
      case PERIOD_D1:  base_pips = 250; break; // ‚úÖ Reduced from 500
      case PERIOD_W1:  base_pips = 500; break;
      case PERIOD_MN1: base_pips = 1000; break;
      default:         base_pips = 100; break;
    }
  } 
  else if (is_index) {
    switch(tf) {
      case PERIOD_M1:  base_pips = 5; break;
      case PERIOD_M5:  base_pips = 10; break;  // ‚úÖ Reduced from 15
      case PERIOD_M15: base_pips = 10; break;  // ‚úÖ Reduced from 15
      case PERIOD_M30: base_pips = 15; break;  // ‚úÖ Reduced from 20
      case PERIOD_H1:  base_pips = 20; break;  // ‚úÖ Reduced from 30
      case PERIOD_H4:  base_pips = 40; break;  // ‚úÖ Reduced from 60
      case PERIOD_D1:  base_pips = 100; break; // ‚úÖ Reduced from 150
      case PERIOD_W1:  base_pips = 250; break;
      case PERIOD_MN1: base_pips = 500; break;
      default:         base_pips = 30; break;
    }
  } 
  else {
    // Unknown instrument - use conservative default
    base_pips = 10;
    Print("Warning: Unknown instrument type for ", symbol, 
          ". Using default threshold.");
  }
  
  // Convert pips to points (—É—á–µ—Ç digits)
  double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
  int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
  
  // For 5-digit brokers (e.g., 1.10500), 1 pip = 10 points
  // For 3-digit brokers (e.g., 1.105), 1 pip = 1 point
  double pip_size = (digits == 5 || digits == 3) ? point * 10 : point;
  
  return base_pips * pip_size;
}
```

**–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏:**

```cpp
void TestEqualThresholdsOnRealData() {
  Print("=== TESTING EQUAL THRESHOLDS ===");
  
  string test_symbols[] = {"EURUSD", "GBPUSD", "XAUUSD", "NAS100"};
  ENUM_TIMEFRAMES test_tfs[] = {PERIOD_M15, PERIOD_H1, PERIOD_H4, PERIOD_D1};
  
  for (int s = 0; s < ArraySize(test_symbols); s++) {
    for (int t = 0; t < ArraySize(test_tfs); t++) {
      double threshold = GetEqualThreshold(test_symbols[s], test_tfs[t]);
      double threshold_pips = threshold / SymbolInfoDouble(test_symbols[s], SYMBOL_POINT);
      
      // For 5-digit, divide by 10 to get pips
      int digits = (int)SymbolInfoInteger(test_symbols[s], SYMBOL_DIGITS);
      if (digits == 5 || digits == 3) {
        threshold_pips /= 10;
      }
      
      Print(test_symbols[s], " ", EnumToString(test_tfs[t]), 
            " => ", DoubleToString(threshold_pips, 1), " pips");
    }
  }
  
  Print("================================");
}
```

---

#### –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï #3: Volume Availability Check

**–§–∞–π–ª:** `SMC_Master.mq5` (OnInit) –∏ `Liquidity.mqh`

**–î–æ–±–∞–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—É—é –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é:**
```cpp
// –í –Ω–∞—á–∞–ª–µ —Ñ–∞–π–ª–∞:
bool g_volume_available = false;
```

**–í OnInit():**
```cpp
int OnInit() {
  // ... existing init code
  
  // Check volume availability
  g_volume_available = CheckVolumeAvailability();
  
  if (!g_volume_available) {
    Print("‚ö†Ô∏è WARNING: Volume data not available or unreliable.");
    Print("Volume-based validations will be DISABLED.");
    Print("This may reduce sweep detection accuracy during news events.");
  } else {
    Print("‚úÖ Volume data available. Full sweep validation enabled.");
  }
  
  return INIT_SUCCEEDED;
}
```

**–§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏:**
```cpp
bool CheckVolumeAvailability() {
  // Step 1: Check if volume data exists
  long vol_current = iVolume(Symbol(), Period(), 0);
  
  if (vol_current <= 0) {
    Print("Volume check: No volume data (vol = ", vol_current, ")");
    return false;
  }
  
  // Step 2: Check for fake/constant volume
  // Some brokers provide fake volume (always = 1 or constant)
  long sample_volumes[20];
  int unique_volumes = 0;
  
  for (int i = 0; i < 20; i++) {
    sample_volumes[i] = iVolume(Symbol(), Period(), i);
    
    // Check if this volume is unique
    bool is_unique = true;
    for (int j = 0; j < i; j++) {
      if (sample_volumes[i] == sample_volumes[j]) {
        is_unique = false;
        break;
      }
    }
    
    if (is_unique) {
      unique_volumes++;
    }
  }
  
  // If less than 5 unique values in 20 bars => fake volume
  if (unique_volumes < 5) {
    Print("Volume check: Fake/constant volume detected. Unique values: ", 
          unique_volumes, "/20");
    return false;
  }
  
  // Step 3: Check volume variance (real volume should vary significantly)
  double avg_volume = 0;
  for (int i = 0; i < 20; i++) {
    avg_volume += (double)sample_volumes[i];
  }
  avg_volume /= 20;
  
  // Calculate standard deviation
  double variance = 0;
  for (int i = 0; i < 20; i++) {
    double diff = (double)sample_volumes[i] - avg_volume;
    variance += diff * diff;
  }
  variance /= 20;
  double std_dev = MathSqrt(variance);
  
  // Coefficient of variation (CV) should be > 0.3 for real volume
  double cv = std_dev / avg_volume;
  
  if (cv < 0.3) {
    Print("Volume check: Low variance detected (CV = ", 
          DoubleToString(cv, 2), "). Likely fake volume.");
    return false;
  }
  
  Print("Volume check: Real volume detected. CV = ", 
        DoubleToString(cv, 2), ", Unique values: ", unique_volumes, "/20");
  
  return true;
}
```

**–í Liquidity.mqh - DetectSweep():**
```cpp
SweepData DetectSweep(LiquidityZone zone, SessionInfo session, bool is_news_time) {
  SweepData sweep;
  sweep.valid = false;
  
  // ... existing sweep detection code
  
  // STEP 4: Volume Check (MODIFIED)
  double volume = (double)iVolume(Symbol(), PERIOD_CURRENT, sweep_bar);
  double avg_volume = CalculateAvgVolume(20);
  sweep.volume = volume;
  sweep.avg_volume = avg_volume;
  sweep.volume_ratio = (avg_volume > 0) ? volume / avg_volume : 0;
  
  // Volume validation - ONLY if data is available
  if (is_news_time && g_volume_available) {  // ‚úÖ Added availability check
    sweep.volume_mandatory = true;
    
    if (sweep.volume_ratio < 1.5) {
      sweep.valid = false;
      sweep.invalid_reason = "Insufficient volume for news sweep";
      sweep.note = StringFormat("Vol ratio: %.2f (required: 1.5+)", 
                                sweep.volume_ratio);
      return sweep;
    }
  } 
  else if (is_news_time && !g_volume_available) {
    // News sweep but no volume data - rely on other factors
    sweep.volume_mandatory = false;
    sweep.note = "News sweep - volume check skipped (data unavailable)";
    Print("‚ö†Ô∏è News sweep without volume validation at ", 
          TimeToString(sweep.time));
  }
  else {
    // Normal session - volume optional
    sweep.volume_mandatory = false;
    
    // But still use it as confluence if available
    if (g_volume_available && sweep.volume_ratio >= 1.3) {
      sweep.note = "Good volume support";
    }
  }
  
  // ... rest of function
  
  return sweep;
}
```

**Confluence adjustment —Å volume:**
```cpp
// –í ConfluenceCalculator.mqh:

double GetVolumeConfluenceBonus(SweepData sweep) {
  if (!g_volume_available) {
    return 0.0;  // No bonus if volume unavailable
  }
  
  // Optional bonus for exceptional volume
  if (sweep.volume_ratio >= 2.0) {
    return 2.0;  // +2% for very high volume
  } else if (sweep.volume_ratio >= 1.5) {
    return 1.0;  // +1% for high volume
  }
  
  return 0.0;
}

// Use in CalculateConfluence():
double volume_bonus = GetVolumeConfluenceBonus(sweep_ref);
conf.total_score += volume_bonus;
if (volume_bonus > 0) {
  ArrayPush(conf.factors_list, 
            StringFormat("High volume (+%.0f%%)", volume_bonus));
}
```

---

### üü° –ü–†–ò–û–†–ò–¢–ï–¢ 2: –í–ê–ñ–ù–´–ï (–£–ª—É—á—à–∞—é—Ç —Ç–æ—á–Ω–æ—Å—Ç—å)

#### –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï #4: Fibonacci Minimum Impulse Size

**–§–∞–π–ª:** `Fibonacci.mqh`

**–î–æ–±–∞–≤–∏—Ç—å validation:**
```cpp
FibonacciLevels CalculateFibonacci(OrderBlock ob) {
  FibonacciLevels fibo;
  
  // Calculate impulse range
  fibo.impulse_start = ob.impulse_start_price;
  fibo.impulse_end = ob.impulse_end_price;
  fibo.range = MathAbs(fibo.impulse_end - fibo.impulse_start);
  
  // ‚úÖ ADDED: Minimum impulse size validation
  double min_impulse = GetMinimumImpulseSize(Symbol(), Period());
  
  if (fibo.range < min_impulse) {
    fibo.valid = false;
    fibo.invalid_reason = StringFormat(
      "Impulse too small: %.1f pips (min: %.1f pips)",
      fibo.range / Point,
      min_impulse / Point
    );
    
    Print("‚ö†Ô∏è Fibonacci invalid: ", fibo.invalid_reason);
    return fibo;
  }
  
  fibo.valid = true;
  
  // Calculate levels (existing code)
  if (ob.type == OB_BULLISH) {
    fibo.L0 = fibo.impulse_end;
    fibo.L236 = fibo.impulse_end - (fibo.range * 0.236);
    // ... etc
  } else {
    fibo.L0 = fibo.impulse_start;
    fibo.L236 = fibo.impulse_start + (fibo.range * 0.236);
    // ... etc
  }
  
  // OTE Zone
  fibo.ote_zone.high = fibo.L618;
  fibo.ote_zone.low = fibo.L79;
  
  return fibo;
}
```

**Helper function:**
```cpp
double GetMinimumImpulseSize(string symbol, ENUM_TIMEFRAMES tf) {
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  bool is_index = (StringFind(symbol, "NAS") >= 0 || 
                   StringFind(symbol, "US500") >= 0);
  
  double min_pips = 0;
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: min_pips = 15; break;
      case PERIOD_M30: min_pips = 20; break;
      case PERIOD_H1:  min_pips = 25; break;
      case PERIOD_H4:  min_pips = 40; break;
      case PERIOD_D1:  min_pips = 80; break;
      default:         min_pips = 100; break;
    }
  } else if (is_gold) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: min_pips = 150; break;
      case PERIOD_M30: min_pips = 200; break;
      case PERIOD_H1:  min_pips = 250; break;
      case PERIOD_H4:  min_pips = 400; break;
      case PERIOD_D1:  min_pips = 800; break;
      default:         min_pips = 1000; break;
    }
  } else if (is_index) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: min_pips = 50; break;
      case PERIOD_M30: min_pips = 75; break;
      case PERIOD_H1:  min_pips = 100; break;
      case PERIOD_H4:  min_pips = 200; break;
      case PERIOD_D1:  min_pips = 400; break;
      default:         min_pips = 500; break;
    }
  } else {
    min_pips = 20;  // Conservative default
  }
  
  return min_pips * SymbolInfoDouble(symbol, SYMBOL_POINT);
}
```

**Update FibonacciLevels structure:**
```cpp
struct FibonacciLevels {
  double impulse_start;
  double impulse_end;
  double range;
  
  // Validation
  bool valid;  // ‚úÖ ADDED
  string invalid_reason;  // ‚úÖ ADDED
  
  // Levels
  double L0;
  double L236;
  // ... etc
  
  struct {
    double high;
    double low;
  } ote_zone;
  
  // Methods
  bool IsPriceInOTE(double price) {
    if (!valid) return false;  // ‚úÖ ADDED check
    return (price >= ote_zone.low && price <= ote_zone.high);
  }
  
  double GetClosestLevel(double price) {
    if (!valid) return 0;  // ‚úÖ ADDED check
    // ... existing code
  }
};
```

**Usage in Setup Scanner:**
```cpp
// –í ScanSH_BMS_RTO():
OrderBlock ob = OrderBlocks.DetectBullishOB(bms, swings);

if (!ob.valid) continue;

FibonacciLevels fibo = Fibonacci.Calculate(ob);

if (!fibo.valid) {
  // Skip this setup - impulse too small
  Print("Skipping setup: ", fibo.invalid_reason);
  continue;
}

// Check OTE
if (fibo.IsPriceInOTE(current_price)) {
  setup.in_fibonacci_ote = true;
}
```

---

#### –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï #5: Asian Range - Explicit Completion Rule

**–§–∞–π–ª:** `Sessions.mqh`

**Update GetAsianRange():**
```cpp
AsianRange GetAsianRange(datetime current_time) {
  AsianRange range;
  range.valid = false;
  
  // Convert to GMT
  datetime gmt_time = ConvertToGMT(current_time);
  MqlDateTime dt_gmt;
  TimeToStruct(gmt_time, dt_gmt);
  
  // ‚úÖ RULE #1: Asian Range –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¢–û–õ–¨–ö–û –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
  if (dt_gmt.hour < 8) {
    range.valid = false;
    range.note = "Asian session NOT completed yet. Cannot use range.";
    range.quality_score = 0;
    range.quality_rating = ASIAN_WEAK;
    
    // Return early - –ù–ï —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π range
    return range;
  }
  
  // ‚úÖ RULE #2: Asian Range –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç –°–ï–ì–û–î–ù–Ø–®–ù–ï–ô —Å–µ—Å—Å–∏–∏
  // Find start of today's Asian session (00:00 GMT today)
  datetime asian_start = gmt_time - (dt_gmt.hour * 3600) 
                         - (dt_gmt.min * 60) - dt_gmt.sec;
  datetime asian_end = asian_start + (8 * 3600);  // +8 hours
  
  // Check if we have enough historical data
  int start_bar = iBarShift(Symbol(), Period(), asian_start);
  int end_bar = iBarShift(Symbol(), Period(), asian_end);
  
  if (start_bar == -1 || end_bar == -1) {
    range.valid = false;
    range.note = "Insufficient historical data for Asian Range";
    range.quality_score = 0;
    range.quality_rating = ASIAN_WEAK;
    return range;
  }
  
  // ‚úÖ RULE #3: –ú–∏–Ω–∏–º—É–º 10 –±–∞—Ä–æ–≤ –≤ Asian Range
  int bars_in_range = start_bar - end_bar + 1;
  if (bars_in_range < 10) {
    range.valid = false;
    range.note = StringFormat("Too few bars in Asian Range (%d bars, min: 10)", 
                              bars_in_range);
    range.quality_score = 0;
    range.quality_rating = ASIAN_WEAK;
    return range;
  }
  
  // Calculate High/Low
  range.high = iHigh(Symbol(), Period(), start_bar);
  range.low = iLow(Symbol(), Period(), start_bar);
  
  for (int i = start_bar; i >= end_bar; i--) {
    double h = iHigh(Symbol(), Period(), i);
    double l = iLow(Symbol(), Period(), i);
    if (h > range.high) range.high = h;
    if (l < range.low) range.low = l;
  }
  
  range.start_time = asian_start;
  range.end_time = asian_end;
  range.size_pips = (range.high - range.low) / Point;
  
  // ‚úÖ RULE #4: Asian Range –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö
  double min_size = GetMinAsianRangeSize(Symbol());
  double max_size = GetMaxAsianRangeSize(Symbol());
  
  if (range.size_pips < min_size) {
    range.valid = false;
    range.note = StringFormat("Asian Range too small: %.1f pips (min: %.1f)", 
                              range.size_pips, min_size);
    range.quality_score = 0;
    range.quality_rating = ASIAN_WEAK;
    return range;
  }
  
  if (range.size_pips > max_size) {
    range.valid = false;
    range.note = StringFormat("Asian Range too large: %.1f pips (max: %.1f) - likely trending", 
                              range.size_pips, max_size);
    range.quality_score = 0;
    range.quality_rating = ASIAN_WEAK;
    return range;
  }
  
  // Preliminary valid
  range.valid = true;
  
  // Calculate quality metrics
  range = ValidateAsianRangeQuality(range, start_bar, end_bar);
  
  // Final validation based on quality
  if (range.quality_score < 40) {
    range.valid = false;
    range.note += "; Quality too low for trading";
  }
  
  return range;
}
```

**Size limits:**
```cpp
double GetMinAsianRangeSize(string symbol) {
  bool is_forex = (StringFind(symbol, "USD") >= 0);
  bool is_gold = (StringFind(symbol, "XAU") >= 0);
  bool is_index = (StringFind(symbol, "NAS") >= 0);
  
  if (is_forex) return 10.0;   // 10 pips minimum
  if (is_gold) return 200.0;   // $2 minimum
  if (is_index) return 50.0;   // 50 points minimum
  
  return 10.0;
}

double GetMaxAsianRangeSize(string symbol) {
  bool is_forex = (StringFind(symbol, "USD") >= 0);
  bool is_gold = (StringFind(symbol, "XAU") >= 0);
  bool is_index = (StringFind(symbol, "NAS") >= 0);
  
  if (is_forex) return 50.0;   // 50 pips maximum
  if (is_gold) return 800.0;   // $8 maximum
  if (is_index) return 200.0;  // 200 points maximum
  
  return 50.0;
}
```

---

### üîµ –ü–†–ò–û–†–ò–¢–ï–¢ 3: –û–ü–¢–ò–ú–ò–ó

–ú–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ

–î–∞–≤–∞–π —Ä–µ—à–∏–º –ø—Ä–æ–±–ª–µ–º—É —Å volume check –ø–æ—Ç–æ–º—É —á—Ç–æ –º–æ–π –±—Ä–æ–∫–µ—Ä –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ tick volume.
–ù—É–∂–Ω–æ –ª—É—á—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ –≤–∑–≤–µ—à–µ–Ω–Ω–æ–µ –æ—Ç –≥—Ä—É–ø–ø—ã —ç–∫—Å–ø–µ—Ä—Ç–æ–≤ %, –¥–∞–ª–µ–µ –Ω–µ–¥–æ–ø–∏—Å–∞–Ω–∞—è —á–∞—Å—Ç—å

# üéØ –≠–ö–°–ü–ï–†–¢–ù–û–ï –†–ï–®–ï–ù–ò–ï: VOLUME CHECK –î–õ–Ø TICK VOLUME

**–ó–∞–¥–∞—á–∞:** –ê–¥–∞–ø—Ç–∏—Ä–æ–≤–∞—Ç—å volume validation –¥–ª—è –±—Ä–æ–∫–µ—Ä–æ–≤ —Å tick volume (–±–æ–ª—å—à–∏–Ω—Å—Ç–≤–æ Forex –±—Ä–æ–∫–µ—Ä–æ–≤)

**–ö–æ–º–∞–Ω–¥–∞ —ç–∫—Å–ø–µ—Ä—Ç–æ–≤:**
- üîµ Quantitative Analyst (—Å—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ tick volume)
- üü¢ SMC Trader (–ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –æ–ø—ã—Ç sweep detection)
- üü° MQL5 Developer (—Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è)
- üî¥ Risk Manager (false signals mitigation)

---

## üìä –ê–ù–ê–õ–ò–ó –ü–†–û–ë–õ–ï–ú–´

### –ß—Ç–æ —Ç–∞–∫–æ–µ Tick Volume –Ω–∞ Forex?

```
Real Volume:     –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–Ω—Ç—Ä–∞–∫—Ç–æ–≤ (–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ –±–∏—Ä–∂–∞—Ö)
Tick Volume:     –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ü–µ–Ω—ã (–¥–æ—Å—Ç—É–ø–Ω–æ –Ω–∞ Forex)

–ö–æ—Ä—Ä–µ–ª—è—Ü–∏—è:      Tick Volume ‚âà 70-85% –∫–æ—Ä—Ä–µ–ª–∏—Ä—É–µ—Ç —Å Real Volume
                 (–∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è FXCM, Oanda 2015-2020)
```

### –ü–æ—á–µ–º—É —ç—Ç–æ –≤–∞–∂–Ω–æ –¥–ª—è SMC?

**–¶–∏—Ç–∞—Ç–∞ –∏–∑ PDF (Chapter 3.6):**
> "The banks manipulate the price because of liquidity... they manipulate the price so that they can have their positions in the market."

**–ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ sweeps —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏–∑—É—é—Ç—Å—è:**
1. üìà **–†–µ–∑–∫–∏–π —Å–ø–∞–π–∫ tick volume** (–º–Ω–æ–≥–æ —Å–¥–µ–ª–æ–∫ –∑–∞ –∫–æ—Ä–æ—Ç–∫–æ–µ –≤—Ä–µ–º—è)
2. ‚ö° **–ë—ã—Å—Ç—Ä–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ** (2-5 –±–∞—Ä–æ–≤)
3. üîÑ **–ù–µ–º–µ–¥–ª–µ–Ω–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç** (–ø—Ä–∏–∑–Ω–∞–∫ stop hunt)

---

## üí° –†–ï–®–ï–ù–ò–ï –û–¢ –≠–ö–°–ü–ï–†–¢–û–í

### –í–ê–†–ò–ê–ù–¢ A: Enhanced Tick Volume Analysis (‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º!)

**–ö–æ–Ω—Ü–µ–ø—Ü–∏—è:** –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å tick volume + –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è "–±–∞–Ω–∫–æ–≤—Å–∫–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"

```cpp
//+------------------------------------------------------------------+
//| Enhanced Sweep Validator for Tick Volume                         |
//+------------------------------------------------------------------+

enum ENUM_VOLUME_TYPE {
  VOL_REAL,         // Real volume (ECN brokers)
  VOL_TICK,         // Tick volume (most Forex)
  VOL_UNAVAILABLE   // No volume data
};

struct VolumeProfile {
  ENUM_VOLUME_TYPE type;
  bool available;
  
  // Tick volume metrics
  double avg_tick_volume;
  double std_dev;
  double cv;  // Coefficient of variation
  
  // Validation
  bool reliable;
  string note;
};

//+------------------------------------------------------------------+
//| –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø volume –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏                          |
//+------------------------------------------------------------------+

VolumeProfile DetectVolumeType() {
  VolumeProfile profile;
  
  // STEP 1: –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞–ª–∏—á–∏–µ volume
  long vol = iVolume(Symbol(), Period(), 0);
  if (vol <= 0) {
    profile.type = VOL_UNAVAILABLE;
    profile.available = false;
    profile.reliable = false;
    profile.note = "No volume data available";
    Print("‚ö†Ô∏è Volume: Not available");
    return profile;
  }
  
  // STEP 2: –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø (Real vs Tick)
  // –≠–≤—Ä–∏—Å—Ç–∏–∫–∞: Real volume —Ä–µ–¥–∫–æ –±—ã–≤–∞–µ—Ç < 10 –∏ –æ–±—ã—á–Ω–æ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞
  // Tick volume —á–∞—Å—Ç–æ –Ω–µ–±–æ–ª—å—à–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è (1-50)
  
  int small_volume_count = 0;
  int total_samples = 100;
  
  for (int i = 0; i < total_samples; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0 && v < 10) {
      small_volume_count++;
    }
  }
  
  if (small_volume_count > 50) {
    profile.type = VOL_TICK;
    Print("üìä Volume: TICK VOLUME detected (", small_volume_count, "/", total_samples, " bars < 10)");
  } else {
    profile.type = VOL_REAL;
    Print("üìä Volume: REAL VOLUME detected");
  }
  
  // STEP 3: –†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  double sum = 0;
  double sum_sq = 0;
  int valid_bars = 0;
  
  for (int i = 0; i < 100; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0) {
      double vol_d = (double)v;
      sum += vol_d;
      sum_sq += vol_d * vol_d;
      valid_bars++;
    }
  }
  
  profile.avg_tick_volume = sum / valid_bars;
  
  double variance = (sum_sq / valid_bars) - (profile.avg_tick_volume * profile.avg_tick_volume);
  profile.std_dev = MathSqrt(variance);
  profile.cv = profile.std_dev / profile.avg_tick_volume;
  
  // STEP 4: –í–∞–ª–∏–¥–∞—Ü–∏—è
  if (profile.cv < 0.3) {
    profile.reliable = false;
    profile.note = "Low variance - likely fake volume";
    Print("‚ö†Ô∏è Volume: LOW VARIANCE (CV=", DoubleToString(profile.cv, 2), ") - unreliable");
  } else {
    profile.available = true;
    profile.reliable = true;
    profile.note = "Volume data reliable for analysis";
    Print("‚úÖ Volume: RELIABLE (CV=", DoubleToString(profile.cv, 2), 
          ", Avg=", DoubleToString(profile.avg_tick_volume, 1), ")");
  }
  
  return profile;
}

//+------------------------------------------------------------------+
//| –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø: Multi-Factor Sweep Validation                   |
//+------------------------------------------------------------------+

enum ENUM_SWEEP_CONFIDENCE {
  SWEEP_CONFIDENCE_VERY_HIGH,   // 90-100%
  SWEEP_CONFIDENCE_HIGH,        // 80-89%
  SWEEP_CONFIDENCE_MEDIUM,      // 70-79%
  SWEEP_CONFIDENCE_LOW,         // 60-69%
  SWEEP_CONFIDENCE_VERY_LOW     // < 60%
};

struct SweepValidation {
  bool valid;
  ENUM_SWEEP_CONFIDENCE confidence;
  double confidence_score;  // 0-100%
  
  // Factors breakdown
  double volume_score;        // 0-30%
  double price_action_score;  // 0-30%
  double timing_score;        // 0-20%
  double context_score;       // 0-20%
  
  string factors_list[];
  string recommendation;
};

SweepValidation ValidateSweep(
  LiquidityZone zone,
  int sweep_bar,
  SessionInfo session,
  bool is_news_time,
  VolumeProfile vol_profile
) {
  SweepValidation result;
  result.valid = false;
  result.confidence_score = 0;
  ArrayResize(result.factors_list, 0);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 1: VOLUME ANALYSIS (30 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  result.volume_score = AnalyzeVolume(sweep_bar, is_news_time, vol_profile, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 2: PRICE ACTION (30 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  result.price_action_score = AnalyzePriceAction(zone, sweep_bar, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 3: TIMING (20 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  result.timing_score = AnalyzeTiming(sweep_bar, session, is_news_time, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 4: CONTEXT (20 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  result.context_score = AnalyzeContext(zone, sweep_bar, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // TOTAL SCORE & VALIDATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  result.confidence_score = result.volume_score + 
                           result.price_action_score + 
                           result.timing_score + 
                           result.context_score;
  
  // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å confidence level
  if (result.confidence_score >= 90) {
    result.confidence = SWEEP_CONFIDENCE_VERY_HIGH;
    result.valid = true;
    result.recommendation = "Excellent sweep - high probability setup";
  }
  else if (result.confidence_score >= 80) {
    result.confidence = SWEEP_CONFIDENCE_HIGH;
    result.valid = true;
    result.recommendation = "Good sweep - tradeable setup";
  }
  else if (result.confidence_score >= 70) {
    result.confidence = SWEEP_CONFIDENCE_MEDIUM;
    result.valid = true;
    result.recommendation = "Acceptable sweep - use tight SL";
  }
  else if (result.confidence_score >= 60) {
    result.confidence = SWEEP_CONFIDENCE_LOW;
    result.valid = (is_news_time || session.type == SESSION_LONDON_NY_OVERLAP);
    result.recommendation = "Weak sweep - only during high-impact events";
  }
  else {
    result.confidence = SWEEP_CONFIDENCE_VERY_LOW;
    result.valid = false;
    result.recommendation = "Poor sweep - skip this setup";
  }
  
  // SPECIAL RULES
  if (is_news_time && result.volume_score < 15) {
    // –ù–æ–≤–æ—Å—Ç–Ω—ã–µ sweeps –ë–ï–ó volume spike = –æ—á–µ–Ω—å –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ
    result.valid = false;
    result.recommendation = "News sweep without volume spike - likely false signal";
    ArrayPush(result.factors_list, "‚ö†Ô∏è CRITICAL: News event but no volume confirmation");
  }
  
  return result;
}

//+------------------------------------------------------------------+
//| FACTOR 1: Volume Analysis (0-30 points)                          |
//+------------------------------------------------------------------+

double AnalyzeVolume(int sweep_bar, bool is_news, VolumeProfile vol_profile, string &factors[]) {
  double score = 0;
  
  if (!vol_profile.available || !vol_profile.reliable) {
    // NO VOLUME DATA - skip to other factors
    ArrayPush(factors, "üìä Volume: N/A (will rely on price action)");
    return 0;  // –ù–µ —à—Ç—Ä–∞—Ñ—É–µ–º, –ø—Ä–æ—Å—Ç–æ –Ω–µ –¥–∞—ë–º points
  }
  
  long current_vol = iVolume(Symbol(), Period(), sweep_bar);
  
  // Calculate dynamic average (last 20 bars, excluding sweep bar)
  double sum_vol = 0;
  int count = 0;
  
  for (int i = sweep_bar + 1; i <= sweep_bar + 20; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0) {
      sum_vol += (double)v;
      count++;
    }
  }
  
  double avg_vol = (count > 0) ? sum_vol / count : vol_profile.avg_tick_volume;
  double vol_ratio = (avg_vol > 0) ? (double)current_vol / avg_vol : 0;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 1A: Volume Spike Magnitude (0-15 points)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  if (vol_ratio >= 3.0) {
    score += 15;
    ArrayPush(factors, StringFormat("üìä Volume: EXCEPTIONAL spike (%.1fx avg) +15%%", vol_ratio));
  }
  else if (vol_ratio >= 2.0) {
    score += 12;
    ArrayPush(factors, StringFormat("üìä Volume: Strong spike (%.1fx avg) +12%%", vol_ratio));
  }
  else if (vol_ratio >= 1.5) {
    score += 8;
    ArrayPush(factors, StringFormat("üìä Volume: Good spike (%.1fx avg) +8%%", vol_ratio));
  }
  else if (vol_ratio >= 1.2) {
    score += 4;
    ArrayPush(factors, StringFormat("üìä Volume: Moderate spike (%.1fx avg) +4%%", vol_ratio));
  }
  else {
    score += 0;
    ArrayPush(factors, StringFormat("üìä Volume: Weak/no spike (%.1fx avg) +0%%", vol_ratio));
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 1B: Volume Burst Pattern (0-10 points)
  // "–ë–∞–Ω–∫–æ–≤—Å–∫–∏–µ sweeps" —á–∞—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç burst –∏–∑ 2-3 –±–∞—Ä–æ–≤
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  // Check volume of adjacent bars
  long vol_before = iVolume(Symbol(), Period(), sweep_bar + 1);
  long vol_after = (sweep_bar > 0) ? iVolume(Symbol(), Period(), sweep_bar - 1) : 0;
  
  int elevated_bars = 0;
  if ((double)vol_before / avg_vol >= 1.3) elevated_bars++;
  if ((double)current_vol / avg_vol >= 1.3) elevated_bars++;
  if ((double)vol_after / avg_vol >= 1.3) elevated_bars++;
  
  if (elevated_bars >= 3) {
    score += 10;
    ArrayPush(factors, "üìä Volume: Sustained burst (3+ bars) +10%");
  }
  else if (elevated_bars == 2) {
    score += 6;
    ArrayPush(factors, "üìä Volume: Short burst (2 bars) +6%");
  }
  else if (elevated_bars == 1) {
    score += 2;
    ArrayPush(factors, "üìä Volume: Single spike only +2%");
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 1C: Volume Decay Pattern (0-5 points)
  // –ü–æ—Å–ª–µ sweep volume –¥–æ–ª–∂–µ–Ω –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –Ω–æ—Ä–º–µ
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  if (sweep_bar >= 3) {
    long vol_decay1 = iVolume(Symbol(), Period(), sweep_bar - 1);
    long vol_decay2 = iVolume(Symbol(), Period(), sweep_bar - 2);
    
    double decay_ratio = ((double)vol_decay1 + (double)vol_decay2) / 2 / avg_vol;
    
    if (decay_ratio < 1.2) {
      score += 5;
      ArrayPush(factors, "üìä Volume: Clean decay after spike +5%");
    }
    else if (decay_ratio < 1.5) {
      score += 2;
      ArrayPush(factors, "üìä Volume: Moderate decay +2%");
    }
  }
  
  return MathMin(score, 30);  // Cap at 30
}

//+------------------------------------------------------------------+
//| FACTOR 2: Price Action Analysis (0-30 points)                    |
//+------------------------------------------------------------------+

double AnalyzePriceAction(LiquidityZone zone, int sweep_bar, string &factors[]) {
  double score = 0;
  
  double sweep_high = iHigh(Symbol(), Period(), sweep_bar);
  double sweep_low = iLow(Symbol(), Period(), sweep_bar);
  double sweep_close = iClose(Symbol(), Period(), sweep_bar);
  double sweep_open = iOpen(Symbol(), Period(), sweep_bar);
  
  bool is_bsl = (zone.type == LIQUIDITY_BSL);
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 2A: Sweep Distance (0-10 points)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  double sweep_distance_pips = 0;
  
  if (is_bsl) {
    sweep_distance_pips = (sweep_high - zone.price) / Point;
  } else {
    sweep_distance_pips = (zone.price - sweep_low) / Point;
  }
  
  // –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π sweep: 5-20 pips (–¥–ª—è Forex)
  if (sweep_distance_pips >= 5 && sweep_distance_pips <= 20) {
    score += 10;
    ArrayPush(factors, StringFormat("üíπ Sweep: Perfect distance (%.1f pips) +10%%", sweep_distance_pips));
  }
  else if (sweep_distance_pips >= 3 && sweep_distance_pips <= 30) {
    score += 7;
    ArrayPush(factors, StringFormat("üíπ Sweep: Good distance (%.1f pips) +7%%", sweep_distance_pips));
  }
  else if (sweep_distance_pips >= 2 && sweep_distance_pips <= 50) {
    score += 4;
    ArrayPush(factors, StringFormat("üíπ Sweep: Acceptable distance (%.1f pips) +4%%", sweep_distance_pips));
  }
  else {
    score += 0;
    ArrayPush(factors, StringFormat("üíπ Sweep: Poor distance (%.1f pips) +0%%", sweep_distance_pips));
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 2B: Wick Rejection (0-10 points)
  // Sweep bar –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å strong rejection wick
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  double candle_body = MathAbs(sweep_close - sweep_open);
  double total_range = sweep_high - sweep_low;
  
  double rejection_wick = 0;
  
  if (is_bsl) {
    // Bullish sweep rejection = upper wick
    double upper_wick = sweep_high - MathMax(sweep_open, sweep_close);
    rejection_wick = upper_wick;
  } else {
    // Bearish sweep rejection = lower wick
    double lower_wick = MathMin(sweep_open, sweep_close) - sweep_low;
    rejection_wick = lower_wick;
  }
  
  double wick_ratio = (total_range > 0) ? rejection_wick / total_range : 0;
  
  if (wick_ratio >= 0.6) {
    score += 10;
    ArrayPush(factors, StringFormat("üíπ Wick: Strong rejection (%.0f%%) +10%%", wick_ratio * 100));
  }
  else if (wick_ratio >= 0.4) {
    score += 7;
    ArrayPush(factors, StringFormat("üíπ Wick: Good rejection (%.0f%%) +7%%", wick_ratio * 100));
  }
  else if (wick_ratio >= 0.2) {
    score += 3;
    ArrayPush(factors, StringFormat("üíπ Wick: Weak rejection (%.0f%%) +3%%", wick_ratio * 100));
  }
  else {
    score += 0;
    ArrayPush(factors, StringFormat("üíπ Wick: No rejection (%.0f%%) +0%%", wick_ratio * 100));
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 2C: Rapid Return (0-10 points)
  // –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Å—Ç—Ä–æ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –∑–æ–Ω–µ liquidity
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  int return_bars = 0;
  bool returned = false;
  
  for (int i = sweep_bar - 1; i >= MathMax(0, sweep_bar - 5); i--) {
    double close = iClose(Symbol(), Period(), i);
    
    if (is_bsl) {
      if (close < zone.price) {
        returned = true;
        return_bars = sweep_bar - i;
        break;
      }
    } else {
      if (close > zone.price) {
        returned = true;
        return_bars = sweep_bar - i;
        break;
      }
    }
  }
  
  if (returned) {
    if (return_bars == 1) {
      score += 10;
      ArrayPush(factors, "üíπ Return: Immediate (1 bar) +10%");
    }
    else if (return_bars == 2) {
      score += 7;
      ArrayPush(factors, "üíπ Return: Fast (2 bars) +7%");
    }
    else if (return_bars <= 3) {
      score += 4;
      ArrayPush(factors, StringFormat("üíπ Return: Moderate (%d bars) +4%%", return_bars));
    }
    else {
      score += 2;
      ArrayPush(factors, StringFormat("üíπ Return: Slow (%d bars) +2%%", return_bars));
    }
  } else {
    score += 0;
    ArrayPush(factors, "üíπ Return: Not yet returned +0%");
  }
  
  return MathMin(score, 30);
}

//+------------------------------------------------------------------+
//| FACTOR 3: Timing Analysis (0-20 points)                          |
//+------------------------------------------------------------------+

double AnalyzeTiming(int sweep_bar, SessionInfo session, bool is_news, string &factors[]) {
  double score = 0;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 3A: Session (0-10 points)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  switch(session.type) {
    case SESSION_LONDON_NY_OVERLAP:
      score += 10;
      ArrayPush(factors, "‚è∞ Session: London-NY Overlap +10%");
      break;
    
    case SESSION_LONDON_PRIME:
    case SESSION_NY_PRIME:
      score += 8;
      ArrayPush(factors, "‚è∞ Session: Prime hours +8%");
      break;
    
    case SESSION_LONDON_LATE:
    case SESSION_NY_LATE:
      score += 5;
      ArrayPush(factors, "‚è∞ Session: Late hours +5%");
      break;
    
    case SESSION_ASIAN:
      score += 2;
      ArrayPush(factors, "‚è∞ Session: Asian (low liquidity) +2%");
      break;
    
    case SESSION_DEAD_ZONE:
      score += 0;
      ArrayPush(factors, "‚è∞ Session: Dead zone +0%");
      break;
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 3B: News Event (0-10 points)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  if (is_news) {
    score += 10;
    ArrayPush(factors, "‚è∞ News: High-impact event +10%");
  } else {
    score += 0;
  }
  
  return MathMin(score, 20);
}

//+------------------------------------------------------------------+
//| FACTOR 4: Context Analysis (0-20 points)                         |
//+------------------------------------------------------------------+

double AnalyzeContext(LiquidityZone zone, int sweep_bar, string &factors[]) {
  double score = 0;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 4A: Liquidity Zone Importance (0-10 points)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  if (zone.importance >= 9) {
    score += 10;
    ArrayPush(factors, StringFormat("üéØ Zone: Critical level (%s) +10%%", zone.name));
  }
  else if (zone.importance >= 7) {
    score += 7;
    ArrayPush(factors, StringFormat("üéØ Zone: Important level (%s) +7%%", zone.name));
  }
  else if (zone.importance >= 5) {
    score += 4;
    ArrayPush(factors, StringFormat("üéØ Zone: Moderate level (%s) +4%%", zone.name));
  }
  else {
    score += 2;
    ArrayPush(factors, StringFormat("üéØ Zone: Minor level (%s) +2%%", zone.name));
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 4B: Multiple Sweeps (0-5 points PENALTY!)
  // –ï—Å–ª–∏ –∑–æ–Ω–∞ —É–∂–µ swept –Ω–µ–¥–∞–≤–Ω–æ - —ç—Ç–æ –ú–ò–ù–£–°
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  if (zone.swept) {
    int bars_since_sweep = iBarShift(Symbol(), Period(), TimeCurrent()) - 
                           iBarShift(Symbol(), Period(), zone.swept_time);
    
    if (bars_since_sweep < 50) {
      score -= 5;
      ArrayPush(factors, "üéØ Zone: Recently swept (weak) -5%");
    }
    else if (bars_since_sweep < 100) {
      score -= 2;
      ArrayPush(factors, "üéØ Zone: Swept before -2%");
    }
  } else {
    score += 5;
    ArrayPush(factors, "üéØ Zone: Fresh liquidity +5%");
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 4C: Equal Highs/Lows (0-5 points)
  // Equal levels = –±–æ–ª—å—à–µ liquidity
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  
  if (StringFind(zone.name, "EQUAL") >= 0) {
    score += 5;
    ArrayPush(factors, "üéØ Zone: Equal highs/lows +5%");
  }
  
  return MathMin(score, 20);
}
```

---

## üìã SCORING MATRIX (–°–≤–æ–¥–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞)

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë FACTOR                        ‚îÇ MAX    ‚îÇ TYPICAL RANGE         ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë 1. VOLUME ANALYSIS            ‚îÇ 30pts  ‚îÇ                       ‚ïë
‚ïë    ‚îú‚îÄ Spike Magnitude         ‚îÇ 15pts  ‚îÇ 0-15                  ‚ïë
‚ïë    ‚îú‚îÄ Burst Pattern           ‚îÇ 10pts  ‚îÇ 0-10                  ‚ïë
‚ïë    ‚îî‚îÄ Decay Pattern           ‚îÇ 5pts   ‚îÇ 0-5                   ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë 2. PRICE ACTION               ‚îÇ 30pts  ‚îÇ                       ‚ïë
‚ïë    ‚îú‚îÄ Sweep Distance          ‚îÇ 10pts  ‚îÇ 0-10                  ‚ïë
‚ïë    ‚îú‚îÄ Wick Rejection          ‚îÇ 10pts  ‚îÇ 0-10                  ‚ïë
‚ïë    ‚îî‚îÄ Rapid Return            ‚îÇ 10pts  ‚îÇ 0-10                  ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë 3. TIMING                     ‚îÇ 20pts  ‚îÇ                       ‚ïë
‚ïë    ‚îú‚îÄ Session Quality         ‚îÇ 10pts  ‚îÇ 0-10                  ‚ïë
‚ïë    ‚îî‚îÄ News Event              ‚îÇ 10pts  ‚îÇ 0 or 10               ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë 4. CONTEXT                    ‚îÇ 20pts  ‚îÇ                       ‚ïë
‚ïë    ‚îú‚îÄ Zone Importance         ‚îÇ 10pts  ‚îÇ 2-10                  ‚ïë
‚ïë    ‚îú‚îÄ Fresh vs Used           ‚îÇ 5pts   ‚îÇ -5 to +5              ‚ïë
‚ïë    ‚îî‚îÄ Equal Highs/Lows        ‚îÇ 5pts   ‚îÇ 0 or 5                ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë TOTAL POSSIBLE                ‚îÇ 100pts ‚îÇ                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

CONFIDENCE LEVELS:
‚îú‚îÄ 90-100%  ‚Üí VERY HIGH  (Bank sweep very likely)
‚îú‚îÄ 80-89%   ‚Üí HIGH       (Strong sweep setup)
‚îú‚îÄ 70-79%   ‚Üí MEDIUM     (Tradeable with caution)
‚îú‚îÄ 60-69%   ‚Üí LOW        (Only during news/overlap)
‚îî‚îÄ < 60%    ‚Üí VERY LOW   (Skip this setup)
```

---

## üéØ –ü–†–ê–ö–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ò–ú–ï–†–´

### Example 1: IDEAL Sweep (95 points)

```
EUR/USD H1, London Open, High-Impact NFP

VOLUME (28/30):
‚îú‚îÄ Spike: 3.2x average ‚Üí +15
‚îú‚îÄ Burst: 3 bars elevated ‚Üí +10
‚îî‚îÄ Decay: Clean return ‚Üí +5

PRICE ACTION (28/30):
‚îú‚îÄ Distance: 12 pips ‚Üí +10
‚îú‚îÄ Wick: 70% rejection ‚Üí +10
‚îî‚îÄ Return: 1 bar ‚Üí +10 (-2 for slight delay)

TIMING (20/20):
‚îú‚îÄ Session: London Prime ‚Üí +8
‚îî‚îÄ News: NFP release ‚Üí +10

CONTEXT (19/20):
‚îú‚îÄ Zone: PDH (critical) ‚Üí +10
‚îú‚îÄ Fresh: Never swept ‚Üí +5
‚îî‚îÄ Equal Highs: Yes ‚Üí +5
‚îî‚îÄ Penalty: None ‚Üí 0

TOTAL: 95% ‚Üí VERY HIGH CONFIDENCE ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
```

### Example 2: GOOD Sweep –±–µ–∑ Real Volume (82 points)

```
GBP/USD M30, NY Open, No News
BROKER: Tick volume only

VOLUME (20/30):
‚îú‚îÄ Spike: 1.8x average ‚Üí +8
‚îú‚îÄ Burst: 2 bars ‚Üí +6
‚îî‚îÄ Decay: Moderate ‚Üí +2
‚îî‚îÄ Note: Tick volume, not real - limited scoring

PRICE ACTION (27/30):
‚îú‚îÄ Distance: 8 pips ‚Üí +10
‚îú‚îÄ Wick: 65% rejection ‚Üí +10
‚îî‚îÄ Return: 2 bars ‚Üí +7

TIMING (18/20):
‚îú‚îÄ Session: NY




–ø–ª–∞–Ω:

# üìò –ü–û–õ–ù–´–ô –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ü–õ–ê–ù –†–ê–ó–†–ê–ë–û–¢–ö–ò SMC –ò–ù–î–ò–ö–ê–¢–û–†–ê –î–õ–Ø MT5

**–í–µ—Ä—Å–∏—è:** 2.0 (–ü–æ—Å–ª–µ –∞—É–¥–∏—Ç–∞)  
**–î–∞—Ç–∞:** 17 –Ω–æ—è–±—Ä—è 2025  
**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ì–æ—Ç–æ–≤ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏  

---

## üìã –°–û–î–ï–†–ñ–ê–ù–ò–ï

1. [–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –∞—É–¥–∏—Ç–∞](#–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ-–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
2. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª–µ–π](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-–º–æ–¥—É–ª–µ–π)
3. [–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã](#–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ-–∞–ª–≥–æ—Ä–∏—Ç–º—ã)
4. [–°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö](#—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-–¥–∞–Ω–Ω—ã—Ö)
5. [–ü–ª–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –ø–æ —Ñ–∞–∑–∞–º](#–ø–ª–∞–Ω-—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏)
6. [–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ](#—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)

---

## üéØ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –ü–û–°–õ–ï –ê–£–î–ò–¢–ê {#–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ-–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è}

### ‚ö†Ô∏è –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ï –ò–ó–ú–ï–ù–ï–ù–ò–Ø

#### 1. Time Zone Conversion (–£–ø—Ä–æ—â–µ–Ω–∞)
**–ë—ã–ª–æ:** –°–ª–æ–∂–Ω—ã–π —Ä–∞—Å—á–µ—Ç —Å DST  
**–°—Ç–∞–ª–æ:** `BrokerTimeDetector.GetOffsetToMSK()`

```cpp
int GetOffsetToMSK() {
  int broker_gmt = DetectBrokerGMTOffset();  // 2 –∏–ª–∏ 3
  bool dst_active = IsDSTActiveEU(TimeCurrent());
  int msk_gmt = 3;  // MSK –≤—Å–µ–≥–¥–∞ GMT+3
  
  if (dst_active) {
    return msk_gmt - 3;  // –õ–µ—Ç–æ–º: 0 —á–∞—Å–æ–≤ —Ä–∞–∑–Ω–∏—Ü—ã
  } else {
    return msk_gmt - 2;  // –ó–∏–º–æ–π: +1 —á–∞—Å –∫ broker time
  }
}
```

#### 2. AMD Pattern Direction (–ö–†–ò–¢–ò–ß–ù–û!)
**–ë—ã–ª–æ:** Manipulation –∏ Distribution –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏  
**–°—Ç–∞–ª–æ:** Manipulation –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–ê Distribution

```cpp
// BEARISH AMD (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ):
// Asian Range: 1.0848-1.0862
// Manipulation: Breakout UP (swept BSL 1.0875) ‚Üê –õ–æ–≤—É—à–∫–∞!
// Distribution: BMS DOWN, —Ü–µ–Ω–∞ –∏–¥–µ—Ç –í–ù–ò–ó ‚Üê –ò—Å—Ç–∏–Ω–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ

if (manipulation_direction == UP) {
  expected_distribution_direction = DOWN;
}
```

#### 3. Order Block Mitigation Tracking
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –°—á–µ—Ç—á–∏–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π OB

```cpp
struct OrderBlock {
  // ... existing fields
  int mitigation_count;           // –ù–û–í–û–ï
  ENUM_OB_STATUS status;          // ACTIVE/MITIGATED_ONCE/TWICE/WEAK/VIOLATED
  
  double GetConfluenceAdjustment() {
    if (mitigation_count <= 1) return 0.0;
    if (mitigation_count == 2) return -5.0;
    if (mitigation_count >= 3) return -15.0;
    return 0.0;
  }
};
```

#### 4. Confluence Weights (–î–æ 100%)
**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ:** –°—É–º–º–∞ —Ç–µ–ø–µ—Ä—å —Ä–æ–≤–Ω–æ 100%

```
–ë–ê–ó–û–í–´–ï:
‚úÖ BMS                     25%
‚úÖ Stop Hunt –ò–õ–ò SMS       20%
‚úÖ RTO to Order Block      20%
‚úÖ Session Timing          15% (–∏–ª–∏ 20% –¥–ª—è Overlap)
                          ----
                           80%

–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï:
‚úÖ Fibonacci OTE           4%
‚úÖ HTF Trend Alignment     4%
‚úÖ High Impact News        4%
‚úÖ AMD Pattern             4%
‚úÖ HTF Order Block         4%
                          ----
                           20%
                          ====
–ò–¢–û–ì–û:                    100% ‚úÖ
```

#### 5. Sweep Volume Check
**–ë—ã–ª–æ:** Volume –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –≤–µ–∑–¥–µ  
**–°—Ç–∞–ª–æ:** MANDATORY –¥–ª—è High Impact News sweeps

```cpp
if (is_news_time) {
  // –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞!
  if (volume < avg_volume * 1.5) {
    return INVALID_SWEEP;  // –ù–µ –Ω–∞—Å—Ç–æ—è—â–∏–π –±–∞–Ω–∫–æ–≤—Å–∫–∏–π sweep
  }
}
```

#### 6. Equal Highs Threshold (Timeframe-–∑–∞–≤–∏—Å–∏–º—ã–π)
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –†–∞–∑–Ω—ã–µ –ø–æ—Ä–æ–≥–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö TF

```cpp
// FOREX (EUR/USD):
M15:  2-5 pips
H1:   5-10 pips
H4:   10-20 pips
Daily: 20-50 pips

// GOLD (XAU/USD):
M15:  20-50 cents
H1:   50-100 cents
H4:   100-200 cents
```

#### 7. Fibonacci Integration
**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ:** –†–∞—Å—á–µ—Ç —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è OB

```cpp
// Module 3: –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è Order Block
OrderBlock ob = DetectBullishOB(...);
ob.impulse_start_bar = impulse_start;
ob.impulse_start_price = Low[impulse_start];
ob.impulse_end_price = High[bms_bar];

// –°–†–ê–ó–£ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å Fibonacci!
ob.fibonacci_data = Fibonacci.Calculate(ob);
ob.ote_zone = ob.fibonacci_data.ote_zone;
```

#### 8. Module Order (Sessions –ø–µ—Ä–µ–º–µ—â–µ–Ω)
**–ò–∑–º–µ–Ω–µ–Ω–æ:** Sessions —Ç–µ–ø–µ—Ä—å Module 2A (–¥–æ Liquidity!)

```
–ü–†–ê–í–ò–õ–¨–ù–´–ô –ü–û–†–Ø–î–û–ö:
0A. BrokerTimeDetector
0B. TimeZoneManager
1.  MarketStructure
2A. Sessions           ‚Üê –ü–ï–†–ï–ú–ï–©–ï–ù –†–ê–ù–¨–®–ï!
2B. Liquidity          ‚Üê –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Sessions data
3.  OrderBlocks
4.  Fibonacci
5.  SetupScanner
6.  ConfluenceCalculator
```

#### 9. HTF Trend Filter
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –ü—Ä–æ–≤–µ—Ä–∫–∞ HTF –ø–µ—Ä–µ–¥ LTF –≤—Ö–æ–¥–∞–º–∏

```cpp
ENUM_TREND_DIRECTION htf_trend = MarketStructure.GetHTFTrend(PERIOD_H4);

if (setup.direction == BUY && htf_trend == BEARISH) {
  return SKIP_SETUP;  // –ù–µ –≤—Ö–æ–¥–∏—Ç—å –ø—Ä–æ—Ç–∏–≤ HTF!
}
```

#### 10. Asian Range Quality Scoring
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ Asian Range

```cpp
struct AsianRange {
  // ... existing
  int touches_high;      // –ù–û–í–û–ï
  int touches_low;       // –ù–û–í–û–ï
  int wicks_above;       // –ù–û–í–û–ï
  int wicks_below;       // –ù–û–í–û–ï
  int quality_score;     // 0-100
  ENUM_ASIAN_QUALITY quality_rating;  // EXCELLENT/GOOD/ACCEPTABLE/WEAK
};
```

---

## üìä –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –ú–û–î–£–õ–ï–ô {#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-–º–æ–¥—É–ª–µ–π}

```
SMC_Master.mq5
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0: Common.mqh
‚îÇ   ‚îî‚îÄ‚îÄ –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö, enums, –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0A: BrokerTimeDetector.mqh [–ö–†–ò–¢–ò–ß–ù–´–ô]
‚îÇ   ‚îú‚îÄ‚îÄ DetectBrokerGMTOffset() ‚Üí 2 –∏–ª–∏ 3
‚îÇ   ‚îú‚îÄ‚îÄ IsDSTActiveEU() ‚Üí —Ç–æ—á–Ω—ã–µ –¥–∞—Ç—ã –ø–µ—Ä–µ—Ö–æ–¥–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ GetOffsetToMSK() ‚Üí —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
‚îÇ   ‚îú‚îÄ‚îÄ ValidateDetection() ‚Üí cross-check
‚îÇ   ‚îî‚îÄ‚îÄ ShowTimeDebugPanel() ‚Üí –≤–∏–∑—É–∞–ª—å–Ω–∞—è –æ—Ç–ª–∞–¥–∫–∞
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0B: TimeZoneManager.mqh
‚îÇ   ‚îú‚îÄ‚îÄ ConvertBrokerToMSK()
‚îÇ   ‚îú‚îÄ‚îÄ ConvertMSKToBroker()
‚îÇ   ‚îî‚îÄ‚îÄ GetCurrentMSKTime()
‚îÇ
‚îú‚îÄ‚îÄ MODULE 1: MarketStructure.mqh
‚îÇ   ‚îú‚îÄ‚îÄ DetectSwingPoints(strength)
‚îÇ   ‚îú‚îÄ‚îÄ DetectBMS() ‚Üí –ø—Ä–æ–≤–µ—Ä–∫–∞ CLOSE, –Ω–µ High/Low
‚îÇ   ‚îú‚îÄ‚îÄ DetectSMS() ‚Üí failure swing
‚îÇ   ‚îî‚îÄ‚îÄ GetHTFTrend(timeframe) ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 2A: Sessions.mqh [–ü–ï–†–ï–ú–ï–©–ï–ù –†–ê–ù–¨–®–ï]
‚îÇ   ‚îú‚îÄ‚îÄ GetCurrentSession() ‚Üí —Å Overlap –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
‚îÇ   ‚îú‚îÄ‚îÄ GetAsianRange()
‚îÇ   ‚îú‚îÄ‚îÄ ValidateAsianRangeQuality() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ   ‚îú‚îÄ‚îÄ DetectAMD() ‚Üí –ò–°–ü–†–ê–í–õ–ï–ù (manipulation –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–∞)
‚îÇ   ‚îî‚îÄ‚îÄ IsLondonNYOverlap() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 2B: Liquidity.mqh
‚îÇ   ‚îú‚îÄ‚îÄ FindBSL() / FindSSL()
‚îÇ   ‚îú‚îÄ‚îÄ FindEqualHighsLows() ‚Üí timeframe-dependent threshold
‚îÇ   ‚îú‚îÄ‚îÄ DetectSweep() ‚Üí volume MANDATORY –¥–ª—è News
‚îÇ   ‚îî‚îÄ‚îÄ ValidateSweepHoldingTime() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 3: OrderBlocks.mqh [–ò–°–ü–†–ê–í–õ–ï–ù]
‚îÇ   ‚îú‚îÄ‚îÄ DetectBullishOB() ‚Üí —Ç–æ—á–Ω—ã–π impulse start + fallback
‚îÇ   ‚îú‚îÄ‚îÄ DetectBearishOB()
‚îÇ   ‚îú‚îÄ‚îÄ ValidateOB()
‚îÇ   ‚îú‚îÄ‚îÄ CheckMitigation() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ   ‚îî‚îÄ‚îÄ TrackMitigationCount() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 4: Fibonacci.mqh
‚îÇ   ‚îú‚îÄ‚îÄ Calculate(OrderBlock) ‚Üí –∏—Å–ø–æ–ª—å–∑—É–µ—Ç impulse data
‚îÇ   ‚îú‚îÄ‚îÄ GetOTEZone()
‚îÇ   ‚îî‚îÄ‚îÄ IsPriceInOTE()
‚îÇ
‚îú‚îÄ‚îÄ MODULE 5: SetupScanner.mqh
‚îÇ   ‚îú‚îÄ‚îÄ ScanTurtleSoup() ‚Üí —Å holding time check
‚îÇ   ‚îú‚îÄ‚îÄ ScanSH_BMS_RTO() ‚Üí —Å HTF filter
‚îÇ   ‚îú‚îÄ‚îÄ ScanSMS_BMS_RTO()
‚îÇ   ‚îî‚îÄ‚îÄ ScanAMD() ‚Üí –∫–∞–∫ context filter
‚îÇ
‚îú‚îÄ‚îÄ MODULE 6: ConfluenceCalculator.mqh [–ò–°–ü–†–ê–í–õ–ï–ù]
‚îÇ   ‚îî‚îÄ‚îÄ CalculateConfluence() ‚Üí –≤–µ—Å–∞ –¥–æ 100%
‚îÇ
‚îú‚îÄ‚îÄ MODULE 7: RiskManager.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ   ‚îî‚îÄ‚îÄ CalculateLotSize()
‚îÇ
‚îú‚îÄ‚îÄ MODULE 8: NewsCalendar.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ   ‚îú‚îÄ‚îÄ MANUAL mode (—Ä—É—á–Ω–æ–π –≤–≤–æ–¥)
‚îÇ   ‚îú‚îÄ‚îÄ DISABLED mode (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
‚îÇ   ‚îî‚îÄ‚îÄ VOLATILITY mode (–ø–æ ATR)
‚îÇ
‚îú‚îÄ‚îÄ MODULE 9: Logger.mqh
‚îÇ   ‚îî‚îÄ‚îÄ –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
‚îÇ
‚îî‚îÄ‚îÄ MODULE 10: Dashboard.mqh [–ù–û–í–´–ô]
    ‚îú‚îÄ‚îÄ DrawDashboard()
    ‚îú‚îÄ‚îÄ UpdateRealtime()
    ‚îî‚îÄ‚îÄ ShowActiveSetups()
```

---

## üîç –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –ê–õ–ì–û–†–ò–¢–ú–´ {#–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ-–∞–ª–≥–æ—Ä–∏—Ç–º—ã}

### –ê–õ–ì–û–†–ò–¢–ú 0A: Broker Time Detection

```cpp
// –£–ü–†–û–©–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
int GetOffsetToMSK() {
  int broker_gmt = DetectBrokerGMTOffset();
  bool dst_active = IsDSTActiveEU(TimeCurrent());
  int msk_gmt = 3;
  
  if (dst_active) {
    return msk_gmt - 3;  // 3 - 3 = 0 (–ª–µ—Ç–æ–º)
  } else {
    return msk_gmt - 2;  // 3 - 2 = +1 (–∑–∏–º–æ–π)
  }
}

// –¢–û–ß–ù–ê–Ø DST –ü–†–û–í–ï–†–ö–ê
bool IsDSTActiveEU(datetime time) {
  MqlDateTime dt;
  TimeToStruct(time, dt);
  
  if (dt.mon < 3 || dt.mon > 10) return false;
  if (dt.mon > 3 && dt.mon < 10) return true;
  
  // –ì—Ä–∞–Ω–∏—á–Ω—ã–µ –º–µ—Å—è—Ü—ã
  if (dt.mon == 3) {
    int last_sunday = GetLastSundayOfMonth(dt.year, 3);
    if (dt.day < last_sunday) return false;
    if (dt.day > last_sunday) return true;
    return (dt.hour >= 2);
  }
  
  if (dt.mon == 10) {
    int last_sunday = GetLastSundayOfMonth(dt.year, 10);
    if (dt.day < last_sunday) return true;
    if (dt.day > last_sunday) return false;
    return (dt.hour < 3);
  }
  
  return false;
}

int GetLastSundayOfMonth(int year, int month) {
  MqlDateTime dt_end;
  dt_end.year = year;
  dt_end.mon = month;
  dt_end.day = 31;
  dt_end.hour = 12;
  
  datetime time_end = StructToTime(dt_end);
  if (time_end == 0) {
    dt_end.day = 30;
    time_end = StructToTime(dt_end);
  }
  if (time_end == 0) {
    dt_end.day = 28;
    time_end = StructToTime(dt_end);
  }
  
  TimeToStruct(time_end, dt_end);
  while (dt_end.day_of_week != 0) {
    time_end -= 86400;
    TimeToStruct(time_end, dt_end);
  }
  
  return dt_end.day;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 1: HTF Trend Detection (–ù–û–í–´–ô)

```cpp
ENUM_TREND_DIRECTION GetHTFTrend(ENUM_TIMEFRAMES htf_period) {
  // –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ HTF
  int htf_bars = iBars(Symbol(), htf_period);
  
  // –ù–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 2 BMS
  BMS latest_bms = NULL;
  BMS previous_bms = NULL;
  
  for (int i = 1; i < MathMin(100, htf_bars); i++) {
    BMS bms = DetectBMSAtBar(i, htf_period);
    if (bms != NULL) {
      if (latest_bms == NULL) {
        latest_bms = bms;
      } else if (previous_bms == NULL) {
        previous_bms = bms;
        break;
      }
    }
  }
  
  // –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–∞
  if (latest_bms == NULL) {
    return TREND_RANGING;
  }
  
  if (latest_bms.type == BMS_BULLISH) {
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Ü–µ–Ω–∞ –≤—ã—à–µ BMS
    double current_price = iClose(Symbol(), htf_period, 0);
    if (current_price > latest_bms.price) {
      return TREND_BULLISH;
    }
  }
  
  if (latest_bms.type == BMS_BEARISH) {
    double current_price = iClose(Symbol(), htf_period, 0);
    if (current_price < latest_bms.price) {
      return TREND_BEARISH;
    }
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å consistency (–¥–≤–∞ BMS –ø–æ–¥—Ä—è–¥ –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏)
  if (previous_bms != NULL) {
    if (latest_bms.type == previous_bms.type) {
      return (latest_bms.type == BMS_BULLISH) ? TREND_BULLISH : TREND_BEARISH;
    }
  }
  
  return TREND_RANGING;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2A: Sessions Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
SessionInfo GetCurrentSession(datetime msk_time) {
  MqlDateTime dt;
  TimeToStruct(msk_time, dt);
  int hour = dt.hour;
  
  SessionInfo info;
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ #1: London-NY Overlap (—Å–∞–º–∞—è –≤–∞–∂–Ω–∞—è –∑–æ–Ω–∞!)
  if (hour >= 16 && hour < 18) {
    info.type = SESSION_LONDON_NY_OVERLAP;
    info.importance = MAXIMUM;
    info.confluence_weight = 20.0;  // –ë–æ–ª—å—à–µ –æ–±—ã—á–Ω—ã—Ö!
    info.description = "Maximum liquidity - both centers active";
    return info;
  }
  
  // London Prime
  if (hour >= 10 && hour < 13) {
    info.type = SESSION_LONDON_PRIME;
    info.importance = HIGH;
    info.confluence_weight = 15.0;
    info.description = "London first 3 hours";
    return info;
  }
  
  // London Late
  if (hour >= 13 && hour < 15) {
    info.type = SESSION_LONDON_LATE;
    info.importance = MEDIUM;
    info.confluence_weight = 8.0;
    return info;
  }
  
  // NY Prime
  if (hour >= 15 && hour < 18) {
    info.type = SESSION_NY_PRIME;
    info.importance = HIGH;
    info.confluence_weight = 15.0;
    return info;
  }
  
  // NY Late
  if (hour >= 18 && hour < 21) {
    info.type = SESSION_NY_LATE;
    info.importance = LOW;
    info.confluence_weight = 5.0;
    return info;
  }
  
  // Asian
  if (hour >= 3 && hour < 9) {
    info.type = SESSION_ASIAN;
    info.importance = OBSERVATION_ONLY;
    info.confluence_weight = 0.0;
    info.description = "Accumulation phase only";
    return info;
  }
  
  // Dead Zone
  info.type = SESSION_DEAD_ZONE;
  info.importance = NONE;
  info.confluence_weight = -20.0;  // –®–¢–†–ê–§!
  info.description = "Do not trade";
  return info;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2A.1: Asian Range Quality (–ù–û–í–´–ô)

```cpp
AsianRange ValidateAsianRangeQuality(AsianRange range) {
  int quality_score = 0;
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 1: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Å–∞–Ω–∏–π –≥—Ä–∞–Ω–∏—Ü (30 points)
  int total_touches = range.touches_high + range.touches_low;
  if (total_touches >= 6) {
    quality_score += 30;
  } else if (total_touches >= 4) {
    quality_score += 20;
  } else if (total_touches >= 2) {
    quality_score += 10;
  }
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 2: Wicks –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ range (20 points)
  int total_wicks = range.wicks_above + range.wicks_below;
  if (total_wicks >= 3) {
    quality_score += 20;
  } else if (total_wicks >= 1) {
    quality_score += 10;
  }
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 3: –§–ª—ç—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä (30 points)
  if (range.flat_ratio >= 0.40 && range.flat_ratio <= 0.60) {
    quality_score += 30;
  } else if (range.flat_ratio >= 0.35 && range.flat_ratio <= 0.65) {
    quality_score += 20;
  } else if (range.flat_ratio >= 0.30 && range.flat_ratio <= 0.70) {
    quality_score += 10;
  }
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 4: –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å (20 points)
  double coverage = CalculateCoverage(range);
  if (coverage > 0.4) {
    quality_score += 20;
  } else if (coverage > 0.3) {
    quality_score += 10;
  }
  
  range.quality_score = quality_score;
  
  // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–π—Ç–∏–Ω–≥
  if (quality_score >= 80) {
    range.quality_rating = ASIAN_EXCELLENT;
  } else if (quality_score >= 60) {
    range.quality_rating = ASIAN_GOOD;
  } else if (quality_score >= 40) {
    range.quality_rating = ASIAN_ACCEPTABLE;
  } else {
    range.quality_rating = ASIAN_WEAK;
  }
  
  return range;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2A.2: AMD Pattern Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
AMD_Pattern DetectAMD(AsianRange asian_range, SessionInfo session) {
  AMD_Pattern amd;
  amd.valid = false;
  
  // PHASE A: Accumulation (—É–∂–µ –µ—Å—Ç—å Asian Range)
  amd.accumulation_zone = asian_range;
  
  // PHASE M: Manipulation (London Open –æ–±—ã—á–Ω–æ)
  if (session.type != SESSION_LONDON_PRIME && session.type != SESSION_NY_PRIME) {
    return amd;  // –†–∞–Ω–æ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å breakout –æ—Ç Asian Range
  double current_high = iHigh(Symbol(), PERIOD_CURRENT, 0);
  double current_low = iLow(Symbol(), PERIOD_CURRENT, 0);
  
  bool broke_above = (current_high > asian_range.high);
  bool broke_below = (current_low < asian_range.low);
  
  if (broke_above) {
    amd.manipulation_direction = AMD_UP;
    amd.manipulation_price = current_high;
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ swept BSL
    LiquidityZone[] bsl = Liquidity.FindBSLAbove(asian_range.high);
    if (ArraySize(bsl) > 0) {
      amd.swept_liquidity = bsl;
      amd.manipulation_confirmed = true;
    }
    
    // –û–ñ–ò–î–ê–ï–ú–û–ï –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï DISTRIBUTION - –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–û!
    amd.expected_distribution_direction = AMD_DOWN;
    
  } else if (broke_below) {
    amd.manipulation_direction = AMD_DOWN;
    amd.manipulation_price = current_low;
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ swept SSL
    LiquidityZone[] ssl = Liquidity.FindSSLBelow(asian_range.low);
    if (ArraySize(ssl) > 0) {
      amd.swept_liquidity = ssl;
      amd.manipulation_confirmed = true;
    }
    
    // –û–ñ–ò–î–ê–ï–ú–û–ï –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï - –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–û!
    amd.expected_distribution_direction = AMD_UP;
  }
  
  // PHASE D: Distribution (–ø—Ä–æ–≤–µ—Ä–∫–∞ BMS –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è)
  if (amd.manipulation_confirmed) {
    // –ñ–¥–µ–º BMS –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ expected_distribution
    BMS latest_bms = MarketStructure.DetectLatestBMS();
    
    if (amd.expected_distribution_direction == AMD_DOWN) {
      if (latest_bms.type == BMS_BEARISH && 
          latest_bms.price < asian_range.low) {
        amd.distribution_confirmed = true;
        amd.distribution_bms = latest_bms;
        amd.valid = true;
      }
    } else {
      if (latest_bms.type == BMS_BULLISH && 
          latest_bms.price > asian_range.high) {
        amd.distribution_confirmed = true;
        amd.distribution_bms = latest_bms;
        amd.valid = true;
      }
    }
  }
  
  return amd;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2B: Equal Highs/Lows (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
double GetEqualThreshold(string symbol, ENUM_TIMEFRAMES tf) {
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  bool is_index = (StringFind(symbol, "NAS") >= 0 || 
                   StringFind(symbol, "US500") >= 0);
  
  double base = 0;
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 5; break;
      case PERIOD_M30: base = 7; break;
      case PERIOD_H1:  base = 10; break;
      case PERIOD_H4:  base = 20; break;
      case PERIOD_D1:  base = 50; break;
      default:         base = 100; break;
    }
  } else if (is_gold) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 50; break;
      case PERIOD_M30: base = 70; break;
      case PERIOD_H1:  base = 100; break;
      case PERIOD_H4:  base = 200; break;
      case PERIOD_D1:  base = 500; break;
      default:         base = 1000; break;
    }
  } else if (is_index) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 15; break;
      case PERIOD_M30: base = 20; break;
      case PERIOD_H1:  base = 30; break;
      case PERIOD_H4:  base = 60; break;
      case PERIOD_D1:  base = 150; break;
      default:         base = 300; break;
    }
  } else {
    base = 10;  // Default
  }
  
  return base * SymbolInfoDouble(symbol, SYMBOL_POINT);
}

EqualZone[] FindEqualHighs(SwingPoint[] swings) {
  EqualZone[] zones;
  double threshold = GetEqualThreshold(Symbol(), Period());
  
  for (int i = 0; i < ArraySize(swings); i++) {
    if (swings[i].type != SWING_HIGH) continue;
    
    for (int j = i + 1; j < ArraySize(swings); j++) {
      if (swings[j].type != SWING_HIGH) continue;
      
      double distance = MathAbs(swings[i].price - swings[j].price);
      
      if (distance < threshold) {
        EqualZone zone;
        zone.price = (swings[i].price + swings[j].price) / 2;
        zone.type = LIQUIDITY_BSL;
        zone.count = 2;
        zone.importance = HIGH;
        zone.swing_indices.Add(i);
        zone.swing_indices.Add(j);
        
        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–æ–ª—å—à–µ swings –≤ —ç—Ç–æ–π –∑–æ–Ω–µ
        for (int k = j + 1; k < ArraySize(swings); k++) {
          if (swings[k].type != SWING_HIGH) continue;
          double dist_k = MathAbs(swings[k].price - zone.price);
          if (dist_k < threshold) {
            zone.count++;
            zone.swing_indices.Add(k);
          }
        }
        
        ArrayPush(zones, zone);
        break;
      }
    }
  }
  
  return zones;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2B.1: Sweep Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
SweepData DetectSweep(LiquidityZone zone, SessionInfo session, bool is_news_time) {
  SweepData sweep;
  sweep.valid = false;
  
  // STEP 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ—è
  double distance = 0;
  int sweep_bar = 0;
  
  if (zone.type == LIQUIDITY_BSL) {
    distance = iHigh(Symbol(), PERIOD_CURRENT, 0) - zone.price;
    sweep_bar = 0;
  } else {
    distance = zone.price - iLow(Symbol(), PERIOD_CURRENT, 0);
    sweep_bar = 0;
  }
  
  double distance_pips = distance / Point;
  
  if (distance_pips < 5 || distance_pips > 50) {
    return sweep;  // –ó–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  }
  
  // STEP 2: Holding Time Check (–ù–û–í–û–ï)
  int holding_bars = 0;
  int check_bar = sweep_bar;
  
  for (int i = 0; i < 5; i++) {
    double close = iClose(Symbol(), PERIOD_CURRENT, check_bar);
    bool still_beyond = false;
    
    if (zone.type == LIQUIDITY_BSL) {
      still_beyond = (close > zone.price);
    } else {
      still_beyond = (close < zone.price);
    }
    
    if (still_beyond) {
      holding_bars++;
      check_bar++;
    } else {
      break;
    }
  }
  
  sweep.holding_bars = holding_bars;
  
  // –û—Ü–µ–Ω–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
  if (holding_bars < 2) {
    sweep.validity = SWEEP_WEAK;
  } else if (holding_bars == 2) {
    sweep.validity = SWEEP_GOOD;
  } else {
    sweep.validity = SWEEP_STRONG;
  }
  
  // STEP 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞
  int max_return_bars = 3 + holding_bars;
  bool return_detected = false;
  
  for (int i = sweep_bar + holding_bars; i < sweep_bar + max_return_bars; i++) {
    double close = iClose(Symbol(), PERIOD_CURRENT, i);
    
    if (zone.type == LIQUIDITY_BSL) {
      if (close < zone.price) {
        return_detected = true;
        sweep.return_bars = i - sweep_bar;
        break;
      }
    } else {
      if (close > zone.price) {
        return_detected = true;
        sweep.return_bars = i - sweep_bar;
        break;
      }
    }
  }
  
  if (!return_detected) {
    return sweep;  // –ù–µ –≤–µ—Ä–Ω—É–ª–∞—Å—å - —ç—Ç–æ breakout, –Ω–µ sweep
  }
  
  // STEP 4: Volume Check
  double volume = iVolume(Symbol(), PERIOD_CURRENT, sweep_bar);
  double avg_volume = CalculateAvgVolume(20);
  sweep.volume = volume;
  sweep.avg_volume = avg_volume;
  sweep.volume_ratio = volume / avg_volume;
  
  // –î–ª—è News sweeps - MANDATORY volume check!
  if (is_news_time) {
    sweep.volume_mandatory = true;
    if (sweep.volume_ratio < 1.5) {
      // –ù–ï–î–û–°–¢–ê–¢–û–ß–ù–´–ô –æ–±—ä–µ–º –¥–ª—è news sweep
      sweep.valid = false;
      sweep.invalid_reason = "Insufficient volume for news sweep";
      return sweep;
    }
  } else {
    // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Å–µ—Å—Å–∏–π - optional
    sweep.volume_mandatory = false;
  }
  
  // STEP 5: Session validation
  if (session.type != SESSION_LONDON_PRIME && 
      session.type != SESSION_NY_PRIME && 
      session.type != SESSION_LONDON_NY_OVERLAP) {
    if (!is_news_time) {
      sweep.valid = false;
      sweep.invalid_reason = "Wrong session for sweep";
      return sweep;
    }
  }
  
  // –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã
  sweep.valid = true;
  sweep.zone_price = zone.price;
  sweep.sweep_price = (zone.type == LIQUIDITY_BSL) ? iHigh(Symbol(), PERIOD_CURRENT, sweep_bar) : iLow(Symbol(), PERIOD_CURRENT, sweep_bar);
  sweep.distance_pips = distance_pips;
  sweep.type = zone.type;
  sweep.session = session.type;
  sweep.is_news_time = is_news_time;
  sweep.time = iTime(Symbol(), PERIOD_CURRENT, sweep_bar);
  
  return sweep;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 3: Order Block Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
OrderBlock DetectBullishOB(BMS bms, SwingPoint[] swings) {
  OrderBlock ob;
  ob.valid = false;
  
  int bms_bar = iBarShift(Symbol(), PERIOD_CURRENT, bms.time);
  
  // STEP 1: –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–∞—á–∞–ª–æ –∏–º–ø—É–ª—å—Å–∞ (–¢–û–ß–ù–û)
  int impulse_start_bar = -1;
  
  // a) –ü–æ—Å–ª–µ–¥–Ω–∏–π swing low
  for (int i = 0; i < ArraySize(swings); i++) {
    if (swings[i].type == SWING_LOW && swings[i].bar_index < bms_bar) {
      if (impulse_start_bar == -1 || swings[i].bar_index > impulse_start_bar) {
        impulse_start_bar = swings[i].bar_index;
      }
    }
  }
  
  // b) –¢–æ—á–∫–∞ –ø–æ—Å–ª–µ Stop Hunt/Sweep SSL
  SweepData[] recent_sweeps = Liquidity.GetRecentSweeps(bms.time);
  for (int i = 0; i < ArraySize(recent_sweeps); i++) {
    if (recent_sweeps[i].type == LIQUIDITY_SSL) {
      int sweep_bar = iBarShift(Symbol(), PERIOD_CURRENT, recent_sweeps[i].time);
      if (sweep_bar < bms_bar && sweep_bar > impulse_start_bar) {
        impulse_start_bar = sweep_bar;
      }
    }
  }
  
  // c) –í—ã—Ö–æ–¥ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏–¥–∞—Ü–∏–∏
  int consolidation_end = DetectConsolidationEnd(bms_bar);
  if (consolidation_end > impulse_start_bar) {
    impulse_start_bar = consolidation_end;
  }
  
  // d) –ü—Ä–µ–¥—ã–¥—É—â–∏–π BMS –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
  BMS prev_bearish_bms = FindPreviousBMS(BMS_BEARISH, bms.time);
  if (prev_bearish_bms != NULL) {
    int prev_bms_bar = iBarShift(Symbol(), PERIOD_CURRENT, prev_bearish_bms.time);
    if (prev_bms_bar < bms_bar && prev_bms_bar > impulse_start_bar) {
      impulse_start_bar = prev_bms_bar;
    }
  }
  
  // STEP 2: –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞—á–∞–ª–∞ –∏–º–ø—É–ª—å—Å–∞
  int distance_from_bms = bms_bar - impulse_start_bar;
  
  if (distance_from_bms < 3) {
    ob.valid = false;
    ob.invalid_reason = "Impulse too short";
    return ob;
  }
  
  if (distance_from_bms > 100) {
    impulse_start_bar = bms_bar - 50;
    Print("Warning: Impulse start too far, using default lookback");
  }
  
  // STEP 3: –ü–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–µ–π bearish —Å–≤–µ—á–∏
  int ob_bar = -1;
  
  for (int i = bms_bar - 3; i >= impulse_start_bar; i--) {
    double open = iOpen(Symbol(), PERIOD_CURRENT, i);
    double close = iClose(Symbol(), PERIOD_CURRENT, i);
    
    if (close < open) {  // Bearish candle
      ob_bar = i;
      break;  // –ü–ï–†–í–ê–Ø –Ω–∞–π–¥–µ–Ω–Ω–∞—è = –ü–û–°–õ–ï–î–ù–Ø–Ø –ø–µ—Ä–µ–¥ BMS
    }
  }
  
  // STEP 4: Fallback –µ—Å–ª–∏ –Ω–µ—Ç –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã—Ö —Å–≤–µ—á–µ–π
  if (ob_bar == -1) {
    ob_bar = impulse_start_bar;
    ob.note = "Using impulse start as OB (no opposite candles found)";
  }
  
  // STEP 5: –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü Order Block
  double ob_high = iHigh(Symbol(), PERIOD_CURRENT, ob_bar);
  double ob_low = iLow(Symbol(), PERIOD_CURRENT, ob_bar);
  double ob_size = (ob_high - ob_low) / Point;
  
  // –í–∞–ª–∏–¥–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞
  OBSizeLimits limits = GetOBLimits(Symbol(), Period());
  
  if (ob_size < limits.min_size) {
    // –†–∞—Å—à–∏—Ä–∏—Ç—å –Ω–∞ —Å–æ—Å–µ–¥–Ω–∏–µ —Å–≤–µ—á–∏
    ob_high = MathMax(iHigh(Symbol(), PERIOD_CURRENT, ob_bar - 1), 
                      MathMax(ob_high, iHigh(Symbol(), PERIOD_CURRENT, ob_bar + 1)));
    ob_low = MathMin(iLow(Symbol(), PERIOD_CURRENT, ob_bar - 1), 
                     MathMin(ob_low, iLow(Symbol(), PERIOD_CURRENT, ob_bar + 1)));
    ob_size = (ob_high - ob_low) / Point;
  }
  
  if (ob_size > limits.max_size) {
    // –£–º–µ–Ω—å—à–∏—Ç—å –¥–æ 50% —Å–≤–µ—á–∏
    double ob_midpoint = (ob_high + ob_low) / 2;
    double ob_range = (ob_high - ob_low) * 0.5;
    ob_high = ob_midpoint + ob_range / 2;
    ob_low = ob_midpoint - ob_range / 2;
  }
  
  // STEP 6: –ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º—É–º –∏–º–ø—É–ª—å—Å–∞ –¥–ª—è Fibonacci
  double impulse_max = iHigh(Symbol(), PERIOD_CURRENT, impulse_start_bar);
  for (int i = impulse_start_bar; i >= bms_bar; i--) {
    double high = iHigh(Symbol(), PERIOD_CURRENT, i);
    if (high > impulse_max) {
      impulse_max = high;
    }
  }
  
  // STEP 7: –ó–∞–ø–æ–ª–Ω–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É Order Block
  ob.time = iTime(Symbol(), PERIOD_CURRENT, ob_bar);
  ob.high = ob_high;
  ob.low = ob_low;
  ob.bar_index = ob_bar;
  ob.type = OB_BULLISH;
  
  ob.bms_ref.time = bms.time;
  ob.bms_ref.price = bms.price;
  
  // –î–∞–Ω–Ω—ã–µ –∏–º–ø—É–ª—å—Å–∞ –¥–ª—è Fibonacci
  ob.impulse_start_bar = impulse_start_bar;
  ob.impulse_start_price = iLow(Symbol(), PERIOD_CURRENT, impulse_start_bar);
  ob.impulse_end_price = impulse_max;
  
  // Mitigation tracking
  ob.status = OB_ACTIVE;
  ob.mitigation_count = 0;
  ob.last_mitigation_time = 0;
  
  ob.valid = true;
  
  return ob;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 3.1: Order Block Mitigation Check (–ù–û–í–´–ô)

```cpp
MitigationResult CheckOrderBlockMitigation(OrderBlock &ob, double current_price, datetime current_time) {
  MitigationResult result;
  result.action = MITIGATION_NO_CHANGE;
  
  double ob_midpoint = (ob.high + ob.low) / 2;
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—Å–∞–Ω–∏—è OB –∑–æ–Ω—ã
  bool price_in_ob = false;
  bool violated = false;
  
  if (ob.type == OB_BULLISH) {
    price_in_ob = (current_price >= ob.low && current_price <= ob.high);
    violated = (current_price < ob.low);
  } else {
    price_in_ob = (current_price >= ob.low && current_price <= ob.high);
    violated = (current_price > ob.high);
  }
  
  // –°–ª—É—á–∞–π 1: VIOLATION
  if (violated) {
    ob.status = OB_VIOLATED;
    ob.mitigation_count = 999;
    result.action = MITIGATION_INVALIDATED;
    result.confluence_adjustment = -100.0;
    return result;
  }
  
  // –°–ª—É—á–∞–π 2: –í –∑–æ–Ω–µ OB
  if (price_in_ob) {
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —ç—Ç–æ –Ω–æ–≤–æ–µ –∫–∞—Å–∞–Ω–∏–µ
    int time_since_last = (int)(current_time - ob.last_mitigation_time);
    if (time_since_last < 300) {  // 5 –º–∏–Ω—É—Ç
      result.action = MITIGATION_SAME_TOUCH;
      return result;
    }
    
    // –ù–æ–≤–æ–µ –∫–∞—Å–∞–Ω–∏–µ
    ob.mitigation_count++;
    ob.last_mitigation_time = current_time;
    ArrayPush(ob.mitigation_prices, current_price);
    
    // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
    if (ob.mitigation_count == 1) {
      ob.status = OB_MITIGATED_ONCE;
      result.confluence_adjustment = 0.0;
      result.recommendation = "Good - first RTO";
    } else if (ob.mitigation_count == 2) {
      ob.status = OB_MITIGATED_TWICE;
      result.confluence_adjustment = -5.0;
      result.recommendation = "Acceptable - second RTO, use tighter SL";
    } else if (ob.mitigation_count >= 3) {
      ob.status = OB_WEAK;
      result.confluence_adjustment = -15.0;
      result.recommendation = "Risky - third RTO, not recommended";
      Print("Warning: OB used 3+ times - consider invalid");
    }
    
    result.action = MITIGATION_TOUCHED;
    result.mitigation_count = ob.mitigation_count;
    
    return result;
  }
  
  // –°–ª—É—á–∞–π 3: –¶–µ–Ω–∞ –≤–Ω–µ OB
  return result;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 4: Fibonacci Calculation (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
FibonacciLevels CalculateFibonacci(OrderBlock ob) {
  FibonacciLevels fibo;
  
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ Order Block —Å—Ç—Ä—É–∫—Ç—É—Ä—ã!
  fibo.impulse_start = ob.impulse_start_price;
  fibo.impulse_end = ob.impulse_end_price;
  fibo.range = fibo.impulse_end - fibo.impulse_start;
  
  // –†–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω–µ–π (–¥–ª—è Bullish - –æ—Ç–∫–∞—Ç –æ—Ç HIGH –∫ LOW)
  if (ob.type == OB_BULLISH) {
    fibo.L0 = fibo.impulse_end;  // 100%
    fibo.L236 = fibo.impulse_end - (fibo.range * 0.236);
    fibo.L382 = fibo.impulse_end - (fibo.range * 0.382);
    fibo.L50 = fibo.impulse_end - (fibo.range * 0.5);
    fibo.L618 = fibo.impulse_end - (fibo.range * 0.618);
    fibo.L705 = fibo.impulse_end - (fibo.range * 0.705);
    fibo.L79 = fibo.impulse_end - (fibo.range * 0.79);
    fibo.L886 = fibo.impulse_end - (fibo.range * 0.886);
    fibo.L100 = fibo.impulse_start;  // 0%
  } else {
    // –î–ª—è Bearish - –æ—Ç–∫–∞—Ç –æ—Ç LOW –∫ HIGH
    fibo.L0 = fibo.impulse_start;  // –ù–∞—á–∞–ª–æ (–Ω–∏–∑ –¥–ª—è bearish)
    fibo.L236 = fibo.impulse_start + (fibo.range * 0.236);
    fibo.L382 = fibo.impulse_start + (fibo.range * 0.382);
    fibo.L50 = fibo.impulse_start + (fibo.range * 0.5);
    fibo.L618 = fibo.impulse_start + (fibo.range * 0.618);
    fibo.L705 = fibo.impulse_start + (fibo.range * 0.705);
    fibo.L79 = fibo.impulse_start + (fibo.range * 0.79);
    fibo.L886 = fibo.impulse_start + (fibo.range * 0.886);
    fibo.L100 = fibo.impulse_end;  // –ö–æ–Ω–µ—Ü (–≤–µ—Ä—Ö –¥–ª—è bearish)
  }
  
  // OTE Zone
  fibo.ote_zone.high = fibo.L618;
  fibo.ote_zone.low = fibo.L79;
  
  return fibo;
}

bool IsPriceInOTE(FibonacciLevels fibo, double price) {
  return (price >= fibo.ote_zone.low && price <= fibo.ote_zone.high);
}
```

### –ê–õ–ì–û–†–ò–¢–ú 6: Confluence Calculation (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø)

```cpp
ConfluenceData CalculateConfluence(Setup setup, SessionInfo session, OrderBlock ob, SweepData sweep) {
  ConfluenceData conf;
  conf.total_score = 0;
  ArrayResize(conf.factors_list, 0);
  
  // –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–í–ï–†–ö–ò
  if (!setup.has_bms) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No BMS";
    return conf;
  }
  
  if (!setup.has_stop_hunt && !setup.has_sms) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No SH or SMS";
    return conf;
  }
  
  if (!setup.has_order_block) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No OB";
    return conf;
  }
  
  // –ë–ê–ó–û–í–´–ï –§–ê–ö–¢–û–†–´ (65%)
  conf.total_score += 25.0;  // BMS
  ArrayPush(conf.factors_list, "BMS confirmed (25%)");
  
  if (setup.has_stop_hunt) {
    conf.total_score += 20.0;
    ArrayPush(conf.factors_list, "Stop Hunt (20%)");
    
    // Adjustment –∑–∞ sweep validity
    if (sweep.validity == SWEEP_STRONG) {
      conf.sweep_validity_adj = 5.0;
      conf.total_score += 5.0;
      ArrayPush(conf.factors_list, "Strong sweep +5%");
    } else if (sweep.validity == SWEEP_WEAK) {
      conf.sweep_validity_adj = -10.0;
      conf.total_score -= 10.0;
      ArrayPush(conf.factors_list, "Weak sweep -10%");
    }
  } else if (setup.has_sms) {
    conf.total_score += 20.0;
    ArrayPush(conf.factors_list, "SMS Failure Swing (20%)");
  }
  
  conf.total_score += 20.0;  // RTO
  ArrayPush(conf.factors_list, "RTO to Order Block (20%)");
  
  // OB Mitigation Adjustment
  if (ob.mitigation_count > 0) {
    double adj = ob.GetConfluenceAdjustment();
    conf.ob_mitigation_adj = adj;
    conf.total_score += adj;
    if (adj < 0) {
      ArrayPush(conf.factors_list, StringFormat("OB mitigation penalty (%.0f%%)", adj));
    }
  }
  
  // SESSION (15-20%)
  conf.session = session.type;
  
  if (session.type == SESSION_DEAD_ZONE || session.type == SESSION_ASIAN) {
    conf.session_valid = false;
    conf.quality_rating = "INVALID - Wrong session";
    return conf;
  }
  
  conf.session_valid = true;
  double session_weight = 15.0;
  
  if (session.type == SESSION_LONDON_NY_OVERLAP) {
    session_weight = 20.0;  // –ë–û–ù–£–° –¥–ª—è Overlap!
    ArrayPush(conf.factors_list, "London-NY Overlap (20%)");
  } else if (session.type == SESSION_LONDON_PRIME || session.type == SESSION_NY_PRIME) {
    ArrayPush(conf.factors_list, "Prime session (15%)");
  } else {
    session_weight = 8.0;  // Late sessions
    ArrayPush(conf.factors_list, "Late session (8%)");
  }
  
  conf.total_score += session_weight;
  
  // –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –§–ê–ö–¢–û–†–´ (20%)
  if (setup.in_fibonacci_ote) {
    conf.total_score += 4.0;
    conf.in_fibonacci_ote = true;
    ArrayPush(conf.factors_list, "Fibonacci OTE (4%)");
  }
  
  if (setup.htf_aligned) {
    conf.total_score += 4.0;
    conf.htf_aligned = true;
    ArrayPush(conf.factors_list, "HTF alignment (4%)");
  }
  
  if (setup.high_impact_news) {
    conf.total_score += 4.0;
    conf.high_impact_news = true;
    ArrayPush(conf.factors_list, "High Impact News (4%)");
  }
  
  if (setup.amd_pattern) {
    conf.total_score += 4.0;
    conf.amd_pattern = true;
    ArrayPush(conf.factors_list, "AMD Pattern (4%)");
  }
  
  if (setup.htf_order_block) {
    conf.total_score += 4.0;
    conf.htf_order_block = true;
    ArrayPush(conf.factors_list, "HTF Order Block (4%)");
  }
  
  // CAP –Ω–∞ 100%
  if (conf.total_score > 100) {
    conf.total_score = 100;
  }
  
  // –†–ï–ô–¢–ò–ù–ì
  if (conf.total_score >= 95) {
    conf.quality_rating = "EXCELLENT ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 90) {
    conf.quality_rating = "EXCELLENT ‚≠ê‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 85) {
    conf.quality_rating = "VERY GOOD ‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 80) {
    conf.quality_rating = "GOOD ‚≠ê‚≠ê";
  } else if (conf.total_score >= 70) {
    conf.quality_rating = "ACCEPTABLE ‚≠ê";
  } else {
    conf.quality_rating = "POOR";
  }
  
  return conf;
}
```

---

## üì¶ –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–• {#—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-–¥–∞–Ω–Ω—ã—Ö}

### Common.mqh - –ü–æ–ª–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```cpp
//+------------------------------------------------------------------+
//| Common.mqh - –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –∞—É–¥–∏—Ç–∞                       |
//+------------------------------------------------------------------+

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ENUMS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

enum ENUM_SESSION_TYPE {
  SESSION_DEAD_ZONE,
  SESSION_ASIAN,
  SESSION_LONDON_PRIME,
  SESSION_LONDON_LATE,
  SESSION_NY_PRIME,
  SESSION_NY_LATE,
  SESSION_LONDON_NY_OVERLAP  // –û—Å–æ–±–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å!
};

enum ENUM_OB_TYPE {
  OB_BULLISH,
  OB_BEARISH
};

enum ENUM_OB_STATUS {
  OB_ACTIVE,
  OB_MITIGATED_ONCE,
  OB_MITIGATED_TWICE,
  OB_WEAK,
  OB_VIOLATED
};

enum ENUM_BMS_TYPE {
  BMS_BULLISH,
  BMS_BEARISH
};

enum ENUM_SWING_TYPE {
  SWING_HIGH,
  SWING_LOW
};

enum ENUM_LIQUIDITY_TYPE {
  LIQUIDITY_BSL,  // Buy Stops Liquidity
  LIQUIDITY_SSL   // Sell Stops Liquidity
};

enum ENUM_ASIAN_QUALITY {
  ASIAN_EXCELLENT,  // 80-100
  ASIAN_GOOD,       // 60-79
  ASIAN_ACCEPTABLE, // 40-59
  ASIAN_WEAK        // < 40
};

enum ENUM_SWEEP_VALIDITY {
  SWEEP_STRONG,     // 3+ bars holding
  SWEEP_GOOD,       // 2 bars
  SWEEP_WEAK,       // 1 bar
  SWEEP_INVALID
};

enum ENUM_TREND_DIRECTION {
  TREND_BULLISH,
  TREND_BEARISH,
  TREND_RANGING
};

enum ENUM_AMD_DIRECTION {
  AMD_UP,
  AMD_DOWN,
  AMD_NONE
};

enum ENUM_SETUP_TYPE {
  SETUP_TURTLE_SOUP,
  SETUP_SH_BMS_RTO,
  SETUP_SMS_BMS_RTO,
  SETUP_AMD
};

enum ENUM_SETUP_STATUS {
  SETUP_READY,      // –¶–µ–Ω–∞ –≤ entry zone
  SETUP_WAITING,    // –ñ–¥–µ–º RTO
  SETUP_EXPIRED     // Setup –∏—Å—Ç–µ–∫
};

enum ENUM_MITIGATION_ACTION {
  MITIGATION_NO_CHANGE,
  MITIGATION_TOUCHED,
  MITIGATION_SAME_TOUCH,
  MITIGATION_INVALIDATED
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STRUCTURES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

struct SwingPoint {
  datetime time;
  double price;
  int bar_index;
  ENUM_SWING_TYPE type;
  int strength;  // –°–∫–æ–ª—å–∫–æ –±–∞—Ä–æ–≤ —Å–ª–µ–≤–∞/—Å–ø—Ä–∞–≤–∞ –ø—Ä–æ–≤–µ—Ä—è–ª–æ—Å—å
};

struct BMS {
  datetime time;
  double price;
  int bar_index;
  ENUM_BMS_TYPE type;
  SwingPoint swing_ref;  // Swing –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –ø—Ä–æ–±–∏—Ç
};

struct SMS {
  datetime time;
  double failed_price;    // –¶–µ–Ω–∞ –∫–æ—Ç–æ—Ä—É—é –Ω–µ —Å–º–æ–≥–ª–∏ –ø—Ä–æ–±–∏—Ç—å
  double reversal_price;  // –¶–µ–Ω–∞ –≥–¥–µ –ø—Ä–æ–∏–∑–æ—à–µ–ª —Ä–∞–∑–≤–æ—Ä–æ—Ç
  int bar_index;
  ENUM_BMS_TYPE expected_direction;  // –û–∂–∏–¥–∞–µ–º–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ SMS
};

struct LiquidityZone {
  double price;
  ENUM_LIQUIDITY_TYPE type;
  string name;  // "PDH", "HOD", "Equal Highs", etc
  int importance;  // 1-10
  datetime created_time;
  bool swept;
  datetime swept_time;
};

struct SweepData {
  datetime time;
  double zone_price;
  double sweep_price;
  double distance_pips;
  ENUM_LIQUIDITY_TYPE type;
  
  // Holding time validation
  int holding_bars;
  ENUM_SWEEP_VALIDITY validity;
  
  // Volume data
  double volume;
  double avg_volume;
  double volume_ratio;
  bool volume_mandatory;
  
  // Return data
  int return_bars;
  double return_price;
  
  // Context
  ENUM_SESSION_TYPE session;
  bool is_news_time;
  
  // Validation
  bool valid;
  string invalid_reason;
  
  // Methods
  double GetConfidenceAdjustment() {
    if (validity == SWEEP_STRONG) return 5.0;
    if (validity == SWEEP_WEAK) return -10.0;
    return 0.0;
  }
};

struct OrderBlock {
  datetime time;
  double high;
  double low;
  int bar_index;
  ENUM_OB_TYPE type;
  
  struct {
    datetime time;
    double price;
  } bms_ref;
  
  // Impulse data –¥–ª—è Fibonacci
  int impulse_start_bar;
  double impulse_start_price;
  double impulse_end_price;
  
  // Fibonacci data (—Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è —Å—Ä–∞–∑—É)
  FibonacciLevels fibonacci_data;
  struct {
    double high;
    double low;
  } ote_zone;
  
  // Mitigation tracking
  ENUM_OB_STATUS status;
  int mitigation_count;
  datetime last_mitigation_time;
  double mitigation_prices[];
  
  // Validation
  bool valid;
  string note;
  string invalid_reason;
  
  // Methods
  double GetConfluenceAdjustment() {
    if (mitigation_count == 0 || mitigation_count == 1) return 0.0;
    if (mitigation_count == 2) return -5.0;
    if (mitigation_count >= 3) return -15.0;
    return 0.0;
  }
};

struct FibonacciLevels {
  double impulse_start;
  double impulse_end;
  double range;
  
  double L0;
  double L236;
  double L382;
  double L50;
  double L618;
  double L705;
  double L79;
  double L886;
  double L100;
  
  struct {
    double high;
    double low;
  } ote_zone;
  
  // Methods
  bool IsPriceInOTE(double price) {
    return (price >= ote_zone.low && price <= ote_zone.high);
  }
  
  double GetClosestLevel(double price) {
    double levels[] = {L0, L236, L382, L50, L618, L705, L79, L886, L100};
    double min_distance = DBL_MAX;
    double closest = 0;
    
    for (int i = 0; i < 9; i++) {
      double dist = MathAbs(price - levels[i]);
      if (dist < min_distance) {
        min_distance = dist;
        closest = levels[i];
      }
    }
    return closest;
  }
};

struct AsianRange {
  datetime start_time;
  datetime end_time;
  double high;
  double low;
  double size_pips;
  
  // Quality metrics
  int touches_high;
  int touches_low;
  int wicks_above;
  int wicks_below;
  double flat_ratio;
  int quality_score;  // 0-100
  ENUM_ASIAN_QUALITY quality_rating;
  
  bool IsValid() {
    return (quality_score >= 40);
  }
  
  string GetQualityText() {
    switch(quality_rating) {
      case ASIAN_EXCELLENT: return "EXCELLENT";
      case ASIAN_GOOD: return "GOOD";
      case ASIAN_ACCEPTABLE: return "ACCEPTABLE";
      case ASIAN_WEAK: return "WEAK";
    }
    return "UNKNOWN";
  }
};

struct AMD_Pattern {
  bool valid;
  
  // Phase A
  AsianRange accumulation_zone;
  
  // Phase M
  ENUM_AMD_DIRECTION manipulation_direction;
  double manipulation_price;
  bool manipulation_confirmed;
  LiquidityZone swept_liquidity[];
  
  // Phase D
  ENUM_AMD_DIRECTION expected_distribution_direction;  // –ü—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ M!
  bool distribution_confirmed;
  BMS distribution_bms;
};

struct SessionInfo {
  ENUM_SESSION_TYPE type;
  int importance;  // 0-10
  double confluence_weight;
  string description;
};

struct Setup {
  int id;  // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
  ENUM_SETUP_TYPE type;
  ENUM_TREND_DIRECTION direction;
  
  // Entry data
  double entry_price;
  double entry_min;
  double entry_max;
  double stop_loss;
  double take_profit;
  
  // References
  BMS bms_ref;
  SweepData sweep_ref;
  SMS sms_ref;
  OrderBlock ob_ref;
  
  // Confluence factors
  bool has_bms;
  bool has_stop_hunt;
  bool has_sms;
  bool has_order_block;
  bool in_fibonacci_ote;
  bool htf_aligned;
  bool high_impact_news;
  bool amd_pattern;
  bool htf_order_block;
  
  // Confluence result
  double confluence_score;
  string confluence_rating;
  string confluence_factors[];
  
  // Status
  ENUM_SETUP_STATUS status;
  ENUM_SESSION_TYPE session;
  datetime created_time;
  int bars_waiting;
};

struct ConfluenceData {
  // –§–∞–∫—Ç–æ—Ä—ã
  bool has_bms;
  bool has_stop_hunt;
  bool has_sms;
  bool has_order_block;
  bool in_fibonacci_ote;
  bool htf_aligned;
  bool high_impact_news;
  bool amd_pattern;
  bool htf_order_block;
  
  // Session
  ENUM_SESSION_TYPE session;
  bool session_valid;
  
  // Adjustments
  double ob_mitigation_adj;
  double sweep_validity_adj;
  
  // Result
  double total_score;
  string quality_rating;
  string factors_list[];
  
  // Weights (constants)
  const double WEIGHT_BMS = 25.0;
  const double WEIGHT_SH_SMS = 20.0;
  const double WEIGHT_OB = 20.0;
  const double WEIGHT_SESSION = 15.0;
  const double WEIGHT_SESSION_OVERLAP = 20.0;
  const double WEIGHT_OTE = 4.0;
  const double WEIGHT_HTF = 4.0;
  const double WEIGHT_NEWS = 4.0;
  const double WEIGHT_AMD = 4.0;
  const double WEIGHT_HTF_OB = 4.0;
};

struct MitigationResult {
  ENUM_MITIGATION_ACTION action;
  int mitigation_count;
  double penetration_depth;
  double confluence_adjustment;
  string recommendation;
};

struct OBSizeLimits {
  double min_size;
  double max_size;
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

template<typename T>
void ArrayPush(T &arr[], T value) {
  int size = ArraySize(arr);
  ArrayResize(arr, size + 1);
  arr[size] = value;
}

OBSizeLimits GetOBLimits(string symbol, ENUM_TIMEFRAMES tf) {
  OBSizeLimits limits;
  
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  bool is_index = (StringFind(symbol, "NAS") >= 0 || 
                   StringFind(symbol, "US500") >= 0);
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15:
        limits.min_size = 3;
        limits.max_size = 20;
        break;
      case PERIOD_M30:
        limits.min_size = 4;
        limits.max_size = 30;
        break;
      case PERIOD_H1:
        limits.min_size = 5;
        limits.max_size = 40;
        break;
      case PERIOD_H4:
        limits.min_size = 10;
        limits.max_size = 80;
        break;
      case PERIOD_D1:
        limits.min_size = 20;
        limits.max_size = 150;
        break;
      default:
        limits.min_size = 30;
        limits.max_size = 300;
        break;
    }
  } else if (is_gold) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15:
        limits.min_size = 30;
        limits.max_size = 200;
        break;
      case PERIOD_M30:
        limits.min_size = 40;
        limits.max_size = 300;
        break;
      case PERIOD_H1:
        limits.min_size = 50;
        limits.max_size = 400;
        break;
      case PERIOD_H4:
        limits.min_size = 100;
        limits.max_size = 800;
        break;
      default:
        limits.min_size = 200;
        limits.max_size = 1500;
        break;
    }
  } else if (is_index) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15:
        limits.min_size = 10;
        limits.max_size = 100;
        break;
      case PERIOD_M30:
        limits.min_size = 15;
        limits.max_size = 150;
        break;
      case PERIOD_H1:
        limits.min_size = 20;
        limits.max_size = 200;
        break;
      case PERIOD_H4:
        limits.min_size = 50;
        limits.max_size = 400;
        break;
      default:
        limits.min_size = 100;
        limits.max_size = 800;
        break;
    }
  } else {
    limits.min_size = 5;
    limits.max_size = 50;
  }
  
  return limits;
}
```

---

## üìÖ –ü–õ–ê–ù –†–ê–ó–†–ê–ë–û–¢–ö–ò –ü–û –§–ê–ó–ê–ú {#–ø–ª–∞–Ω-—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏}

### PHASE 1: –§—É–Ω–¥–∞–º–µ–Ω—Ç (–ù–µ–¥–µ–ª–∏ 1-2)

```
WEEK 1: Core Infrastructure
‚îú‚îÄ Common.mqh
‚îÇ  ‚îú‚îÄ –í—Å–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö ‚úì
‚îÇ  ‚îú‚îÄ Enums –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è ‚úì
‚îÇ  ‚îî‚îÄ Helper functions ‚úì
‚îÇ
‚îú‚îÄ MODULE 0A: BrokerTimeDetector.mqh
‚îÇ  ‚îú‚îÄ DetectBrokerGMTOffset()
‚îÇ  ‚îú‚îÄ IsDSTActiveEU() —Å —Ç–æ—á–Ω—ã–º–∏ –¥–∞—Ç–∞–º–∏
‚îÇ  ‚îú‚îÄ GetLastSundayOfMonth()
‚îÇ  ‚îú‚îÄ GetOffsetToMSK() —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
‚îÇ  ‚îú‚îÄ ValidateDetection() cross-check
‚îÇ  ‚îî‚îÄ ShowTimeDebugPanel()
‚îÇ
‚îî‚îÄ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:
   ‚îú‚îÄ –ó–∏–º–Ω–µ–µ –≤—Ä–µ–º—è (—è–Ω–≤–∞—Ä—å): GMT+2, offset +1
   ‚îú‚îÄ –õ–µ—Ç–Ω–µ–µ –≤—Ä–µ–º—è (–∏—é–ª—å): GMT+3, offset 0
   ‚îî‚îÄ DST –ø–µ—Ä–µ—Ö–æ–¥—ã (30 –º–∞—Ä—Ç–∞, 26 –æ–∫—Ç—è–±—Ä—è)

WEEK 2: Time Management
‚îú‚îÄ MODULE 0B: TimeZoneManager.mqh
‚îÇ  ‚îú‚îÄ ConvertBrokerToMSK(hour)
‚îÇ  ‚îú‚îÄ ConvertMSKToBroker(hour)
‚îÇ  ‚îú‚îÄ GetCurrentMSKTime()
‚îÇ  ‚îî‚îÄ GetCurrentSession() wrapper
‚îÇ
‚îî‚îÄ Integration Testing:
   ‚îú‚îÄ –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ—Å—Å–∏–π (Asian, London, NY, Overlap)
   ‚îú‚îÄ Session timing –≤ MSK
   ‚îî‚îÄ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ç–µ—Å—Ç—ã (TestSessionDetection())
```

### PHASE 2: Market Analysis Core (–ù–µ–¥–µ–ª–∏ 3-4)

```
WEEK 3: Sessions & Structure
‚îú‚îÄ MODULE 2A: Sessions.mqh [–ü–ï–†–ï–ú–ï–©–ï–ù –†–ê–ù–¨–®–ï!]
‚îÇ  ‚îú‚îÄ GetCurrentSession() —Å Overlap –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
‚îÇ  ‚îú‚îÄ GetAsianRange()
‚îÇ  ‚îÇ  ‚îú‚îÄ –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ boundaries
‚îÇ  ‚îÇ  ‚îú‚îÄ –ü–æ–¥—Å—á–µ—Ç touches/wicks
‚îÇ  ‚îÇ  ‚îî‚îÄ Quality scoring
‚îÇ  ‚îú‚îÄ ValidateAsianRangeQuality()
‚îÇ  ‚îú‚îÄ DetectAMD() –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê
‚îÇ  ‚îÇ  ‚îî‚îÄ Manipulation –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–∞ Distribution!
‚îÇ  ‚îî‚îÄ IsLondonNYOverlap()
‚îÇ
‚îú‚îÄ MODULE 1: MarketStructure.mqh
‚îÇ  ‚îú‚îÄ DetectSwingPoints(strength)
‚îÇ  ‚îú‚îÄ DetectBMS() ‚Üí –ø—Ä–æ–≤–µ—Ä–∫–∞ Close, –Ω–µ High/Low
‚îÇ  ‚îú‚îÄ DetectSMS()
‚îÇ  ‚îî‚îÄ GetHTFTrend(timeframe) –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ Swing detection –Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏
   ‚îú‚îÄ BMS validation (Close vs High/Low)
   ‚îú‚îÄ Asian Range quality –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö
   ‚îî‚îÄ AMD pattern detection

WEEK 4: Advanced Market Structure
‚îú‚îÄ HTF Analysis Integration
‚îÇ  ‚îú‚îÄ Multi-timeframe swing detection
‚îÇ  ‚îú‚îÄ HTF trend alignment check
‚îÇ  ‚îî‚îÄ HTF Order Block detection
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ HTF vs LTF consistency
   ‚îî‚îÄ Trend direction validation
```

### PHASE 3: Liquidity & Order Blocks (–ù–µ–¥–µ–ª–∏ 5-7)

```
WEEK 5: Liquidity Detection
‚îú‚îÄ MODULE 2B: Liquidity.mqh
‚îÇ  ‚îú‚îÄ FindBSL() / FindSSL()
‚îÇ  ‚îÇ  ‚îú‚îÄ PDH, PWH, PMH
‚îÇ  ‚îÇ  ‚îú‚îÄ HOD, LOD
‚îÇ  ‚îÇ  ‚îî‚îÄ Old highs/lows
‚îÇ  ‚îú‚îÄ FindEqualHighsLows()
‚îÇ  ‚îÇ  ‚îî‚îÄ Timeframe-dependent threshold!
‚îÇ  ‚îú‚îÄ DetectSweep()
‚îÇ  ‚îÇ  ‚îú‚îÄ Distance validation
‚îÇ  ‚îÇ  ‚îú‚îÄ Holding time check –ù–û–í–û–ï
‚îÇ  ‚îÇ  ‚îú‚îÄ Volume check (MANDATORY –¥–ª—è News)
‚îÇ  ‚îÇ  ‚îî‚îÄ Return validation
‚îÇ  ‚îî‚îÄ ValidateSweepHoldingTime()
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ Equal Highs –Ω–∞ —Ä–∞–∑–Ω—ã—Ö TF (M15, H1, H4)
   ‚îú‚îÄ Sweep validation —Å/–±–µ–∑ volume
   ‚îú‚îÄ Holding time scenarios (1, 2, 3+ bars)
   ‚îî‚îÄ News sweep vs normal sweep

WEEK 6: Order Block Detection
‚îú‚îÄ MODULE 3: OrderBlocks.mqh
‚îÇ  ‚îú‚îÄ DetectBullishOB()
‚îÇ  ‚îÇ  ‚îú‚îÄ –¢–æ—á–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ impulse_start
‚îÇ  ‚îÇ  ‚îú‚îÄ –ü–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π —Å–≤–µ—á–∏
‚îÇ  ‚îÇ  ‚îú‚îÄ Fallback –¥–ª—è strong impulses
‚îÇ  ‚îÇ  ‚îî‚îÄ –†–∞–∑–º–µ—Ä validation
‚îÇ  ‚îú‚îÄ DetectBearishOB()
‚îÇ  ‚îú‚îÄ ValidateOB()
‚îÇ  ‚îú‚îÄ CheckMitigation() –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ  ‚îÇ  ‚îú‚îÄ Touch detection
‚îÇ  ‚îÇ  ‚îú‚îÄ Violation detection
‚îÇ  ‚îÇ  ‚îî‚îÄ Confluence adjustment
‚îÇ  ‚îî‚îÄ TrackMitigationCount()
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ OB detection –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –∏–º–ø—É–ª—å—Å–∞—Ö
   ‚îú‚îÄ Fallback scenarios (no opposite candles)
   ‚îú‚îÄ Mitigation tracking (1st, 2nd, 3rd touch)
   ‚îî‚îÄ Size validation

WEEK 7: Fibonacci Integration
‚îú‚îÄ MODULE 4: Fibonacci.mqh
‚îÇ  ‚îú‚îÄ Calculate(OrderBlock)
‚îÇ  ‚îÇ  ‚îî‚îÄ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç impulse_start/end –∏–∑ OB
‚îÇ  ‚îú‚îÄ GetOTEZone()
‚îÇ  ‚îî‚îÄ IsPriceInOTE()
‚îÇ
‚îî‚îÄ Integration:
   ‚îú‚îÄ Fibonacci —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –°–†–ê–ó–£ –ø–æ—Å–ª–µ OB creation
   ‚îú‚îÄ OTE zone —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ OB —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
   ‚îî‚îÄ Testing –Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏
```

### PHASE 4: Setup Detection (–ù–µ–¥–µ–ª–∏ 8-9)

```
WEEK 8: Setup Scanner
‚îú‚îÄ MODULE 5: SetupScanner.mqh
‚îÇ  ‚îú‚îÄ ScanTurtleSoup()
‚îÇ  ‚îÇ  ‚îú‚îÄ Sweep detection
‚îÇ  ‚îÇ  ‚îú‚îÄ Holding time validation
‚îÇ  ‚îÇ  ‚îî‚îÄ Entry zone –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
‚îÇ  ‚îú‚îÄ ScanSH_BMS_RTO()
‚îÇ  ‚îÇ  ‚îú‚îÄ Sweep + BMS combo
‚îÇ  ‚îÇ  ‚îú‚îÄ RTO validation
‚îÇ  ‚îÇ  ‚îî‚îÄ HTF filter check –ù–û–í–û–ï
‚îÇ  ‚îú‚îÄ ScanSMS_BMS_RTO()
‚îÇ  ‚îÇ  ‚îî‚îÄ SMS + BMS + RTO combo
‚îÇ  ‚îî‚îÄ ScanAMD()
‚îÇ     ‚îî‚îÄ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ context filter
‚îÇ
‚îú‚îÄ HTF Filter Implementation
‚îÇ  ‚îî‚îÄ –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã—Ö setups
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ –ö–∞–∂–¥—ã–π —Ç–∏–ø setup –æ—Ç–¥–µ–ª—å–Ω–æ
   ‚îú‚îÄ HTF filter validation
   ‚îî‚îÄ Multiple setups –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ

WEEK 9: Confluence System
‚îú‚îÄ MODULE 6: ConfluenceCalculator.mqh
‚îÇ  ‚îú‚îÄ CalculateConfluence()
‚îÇ  ‚îÇ  ‚îú‚îÄ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ (BMS, SH/SMS, OB)
‚îÇ  ‚îÇ  ‚îú‚îÄ Session weight (15% –∏–ª–∏ 20% –¥–ª—è Overlap)
‚îÇ  ‚îÇ  ‚îú‚îÄ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã (20%)
‚îÇ  ‚îÇ  ‚îú‚îÄ Adjustments (OB mitigation, sweep validity)
‚îÇ  ‚îÇ  ‚îî‚îÄ Cap –Ω–∞ 100%
‚îÇ  ‚îú‚îÄ Quality rating –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
‚îÇ  ‚îî‚îÄ Factors breakdown
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ –í—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Ñ–∞–∫—Ç–æ—Ä–æ–≤
   ‚îú‚îÄ Edge cases (max/min confluence)
   ‚îú‚îÄ Adjustments validation
   ‚îî‚îÄ –í–µ—Å–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ (—Å—É–º–º–∞ = 100%)
```

### PHASE 5: Auxiliary Modules (–ù–µ–¥–µ–ª–∏ 10-11)

```
WEEK 10: Optional Modules
‚îú‚îÄ MODULE 7: RiskManager.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ  ‚îú‚îÄ CalculateLotSize(sl_pips, risk_percent, balance)
‚îÇ  ‚îú‚îÄ CalculateRiskReward(entry, sl, tp)
‚îÇ  ‚îî‚îÄ ValidateRiskParameters()
‚îÇ
‚îú‚îÄ MODULE 8: NewsCalendar.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ  ‚îú‚îÄ MANUAL mode (inputs)
‚îÇ  ‚îÇ  ‚îî‚îÄ –†—É—á–Ω–æ–π –≤–≤–æ–¥ —Å–æ–±—ã—Ç–∏–π –∏ –≤—Ä–µ–º–µ–Ω–∏
‚îÇ  ‚îú‚îÄ DISABLED mode (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
‚îÇ  ‚îî‚îÄ VOLATILITY mode (–ø–æ ATR)
‚îÇ     ‚îî‚îÄ –ê–≤—Ç–æ-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ high volatility periods
‚îÇ
‚îî‚îÄ MODULE 9: Logger.mqh
   ‚îú‚îÄ LogInfo()
   ‚îú‚îÄ LogWarning()
   ‚îú‚îÄ LogError()
   ‚îî‚îÄ LogDebug()

WEEK 11: Dashboard
‚îú‚îÄ MODULE 10: Dashboard.mqh
‚îÇ  ‚îú‚îÄ DrawDashboard()
‚îÇ  ‚îÇ  ‚îú‚îÄ Background panel
‚îÇ  ‚îÇ  ‚îú‚îÄ All sections (Time, Structure, Liquidity, Setups, Stats)
‚îÇ  ‚îÇ  ‚îî‚îÄ Responsive layout
‚îÇ  ‚îú‚îÄ UpdateRealtime()
‚îÇ  ‚îÇ  ‚îú‚îÄ Time section –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
‚îÇ  ‚îÇ  ‚îú‚îÄ Structure –Ω–∞ –Ω–æ–≤–æ–º –±–∞—Ä–µ
‚îÇ  ‚îÇ  ‚îî‚îÄ Setups –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
‚îÇ  ‚îú‚îÄ ShowActiveSetups()
‚îÇ  ‚îÇ  ‚îú‚îÄ Top N setups –ø–æ confluence
‚îÇ  ‚îÇ  ‚îú‚îÄ Status indicators (üü¢üü°üî¥)
‚îÇ  ‚îÇ  ‚îî‚îÄ Confluence breakdown
‚îÇ  ‚îî‚îÄ Performance optimization
‚îÇ     ‚îú‚îÄ Lazy rendering
‚îÇ     ‚îî‚îÄ Update throttling
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ –í–∏–∑—É–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ–∫—Ü–∏–π
   ‚îú‚îÄ Real-time updates
   ‚îî‚îÄ Performance (< 10ms –Ω–∞ redraw)
```

### PHASE 6: Integration & Testing (–ù–µ–¥–µ–ª–∏ 12-13)

```
WEEK 12: Full Integration
‚îú‚îÄ SMC_Master.mq5
‚îÇ  ‚îú‚îÄ OnInit() - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π
‚îÇ  ‚îú‚îÄ OnCalculate() - –≥–ª–∞–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 1: Context (Time, Session)
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 2: Structure (Swings, BMS, SMS)
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 3: Liquidity (BSL/SSL, Sweeps)
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 4: Order Blocks + Fibonacci
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 5: Setup Scan
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 6: Confluence calculation
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 7: Filter –ø–æ min confluence
‚îÇ  ‚îÇ  ‚îî‚îÄ PHASE 8: Dashboard update
‚îÇ  ‚îî‚îÄ OnDeinit() - cleanup
‚îÇ
‚îú‚îÄ Inputs Organization
‚îÇ  ‚îú‚îÄ Time Settings
‚îÇ  ‚îú‚îÄ Session Settings
‚îÇ  ‚îú‚îÄ Market Structure Settings
‚îÇ  ‚îú‚îÄ Liquidity Settings
‚îÇ  ‚îú‚îÄ Order Block Settings
‚îÇ  ‚îú‚îÄ Confluence Settings
‚îÇ  ‚îú‚îÄ Dashboard Settings
‚îÇ  ‚îî‚îÄ Risk Settings (optional)
‚îÇ
‚îî‚îÄ Memory Management
   ‚îú‚îÄ ArrayFree() –¥–ª—è dynamic arrays
   ‚îî‚îÄ Static arrays –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ

WEEK 13: Comprehensive Testing
‚îú‚îÄ Automated Tests
‚îÇ  ‚îú‚îÄ Time detection tests
‚îÇ  ‚îú‚îÄ Session detection tests
‚îÇ  ‚îú‚îÄ BMS detection tests
‚îÇ  ‚îú‚îÄ OB detection tests
‚îÇ  ‚îú‚îÄ Confluence calculation tests
‚îÇ  ‚îî‚îÄ Edge cases
‚îÇ
‚îú‚îÄ Manual Testing
‚îÇ  ‚îú‚îÄ Historical data (back-test)
‚îÇ  ‚îú‚îÄ Live market conditions
‚îÇ  ‚îú‚îÄ Multiple symbols (EUR/USD, Gold, Indices)
‚îÇ  ‚îî‚îÄ Multiple timeframes (M15, H1, H4)
‚îÇ
‚îî‚îÄ Performance Testing
   ‚îú‚îÄ CPU usage
   ‚îú‚îÄ Memory usage
   ‚îú‚îÄ Indicator loading time
   ‚îî‚îÄ Optimization opportunities
```

### PHASE 7: Documentation & Release (–ù–µ–¥–µ–ª—è 14)

```
WEEK 14: Finalization
‚îú‚îÄ User Manual
‚îÇ  ‚îú‚îÄ Installation guide
‚îÇ  ‚îú‚îÄ Setup & configuration
‚îÇ  ‚îú‚îÄ Trading concepts explained
‚îÇ  ‚îú‚îÄ Dashboard guide
‚îÇ  ‚îú‚îÄ Risk management guidelines
‚îÇ  ‚îî‚îÄ Troubleshooting
‚îÇ
‚îú‚îÄ Code Documentation
‚îÇ  ‚îú‚îÄ Comments –¥–ª—è –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π
‚îÇ  ‚îú‚îÄ Module dependencies diagram
‚îÇ  ‚îî‚îÄ Architecture overview
‚îÇ
‚îú‚îÄ Final Testing
‚îÇ  ‚îú‚îÄ Beta testing (2-3 users)
‚îÇ  ‚îú‚îÄ Bug fixes
‚îÇ  ‚îî‚îÄ Performance tuning
‚îÇ
‚îî‚îÄ Release Preparation
   ‚îú‚îÄ Version 1.0 package
   ‚îú‚îÄ Release notes
   ‚îî‚îÄ Support channels setup
```

---

## ‚úÖ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï {#—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ}

### –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Ç–µ—Å—Ç—ã –ø–µ—Ä–µ–¥ —Ä–µ–ª–∏–∑–æ–º

```cpp
//+------------------------------------------------------------------+
//| Test Suite –¥–ª—è SMC –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞                                   |
//+------------------------------------------------------------------+

void RunAllTests() {
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Print("Starting SMC Indicator Test Suite");
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  
  int total_tests = 0;
  int passed_tests = 0;
  
  // TIME TESTS
  if (TestTimeDetection()) passed_tests++;
  total_tests++;
  
  if (TestDSTTransitions()) passed_tests++;
  total_tests++;
  
  if (TestSessionDetection()) passed_tests++;
  total_tests++;
  
  // STRUCTURE TESTS
  if (TestBMSDetection()) passed_tests++;
  total_tests++;
  
  if (TestSMSDetection()) passed_tests++;
  total_tests++;
  
  if (TestHTFTrendDetection()) passed_tests++;
  total_tests++;
  
  // LIQUIDITY TESTS
  if (TestEqualHighsThreshold()) passed_tests++;
  total_tests++;
  
  if (TestSweepDetection()) passed_tests++;
  total_tests++;
  
  if (TestSweepVolumeCheck()) passed_tests++;
  total_tests++;
  
  // ORDER BLOCK TESTS
  if (TestOrderBlockDetection()) passed_tests++;
  total_tests++;
  
  if (TestOrderBlockMitigation()) passed_tests++;
  total_tests++;
  
  if (TestOrderBlockFallback()) passed_tests++;
  total_tests++;
  
  // FIBONACCI TESTS
  if (TestFibonacciCalculation()) passed_tests++;
  total_tests++;
  
  if (TestOTEZone()) passed_tests++;
  total_tests++;
  
  // CONFLUENCE TESTS
  if (TestConfluenceWeights()) passed_tests++;
  total_tests++;
  
  if (TestConfluenceAdjustments()) passed_tests++;
  total_tests++;
  
  if (TestConfluenceCap()) passed_tests++;
  total_tests++;
  
  // AMD TESTS
  if (TestAMDManipulationDirection()) passed_tests++;
  total_tests++;
  
  // DASHBOARD TESTS
  if (TestDashboardPerformance()) passed_tests++;
  total_tests++;
  
  // RESULTS
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Print("Test Results: ", passed_tests, "/", total_tests, " passed");
  double success_rate = (double)passed_tests / total_tests * 100;
  Print("Success Rate: ", DoubleToString(success_rate, 1), "%");
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  
  if (passed_tests == total_tests) {
    Print("‚úÖ ALL TESTS PASSED! Ready for release.");
  } else {
    Print("‚ùå SOME TESTS FAILED! Review logs.");
  }
}

//+------------------------------------------------------------------+
//| TEST 1: Time Detection                                           |
//+------------------------------------------------------------------+
bool TestTimeDetection() {
  Print("Running: TestTimeDetection...");
  
  // Simulate winter (January)
  datetime winter_time = D'2025.01.15 10:00';
  MqlDateTime dt_winter;
  TimeToStruct(winter_time, dt_winter);
  
  bool dst_winter = IsDSTActiveEU(winter_time);
  if (dst_winter) {
    Print("‚ùå FAILED: DST should be false in January");
    return false;
  }
  
  int offset_winter = GetOffsetToMSK();
  if (offset_winter != 1) {
    Print("‚ùå FAILED: Winter offset should be +1, got ", offset_winter);
    return false;
  }
  
  // Simulate summer (July)
  datetime summer_time = D'2025.07.15 10:00';
  bool dst_summer = IsDSTActiveEU(summer_time);
  if (!dst_summer) {
    Print("‚ùå FAILED: DST should be true in July");
    return false;
  }
  
  // Note: Can't change broker time dynamically, so just check logic
  
  Print("‚úÖ PASSED: TestTimeDetection");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 2: BMS Detection                                            |
//+------------------------------------------------------------------+
bool TestBMSDetection() {
  Print("Running: TestBMSDetection...");
  
  // Create test data
  // Swing High at bar 10: High = 1.1000
  // Bar 5: High = 1.1015, Close = 1.1012 (CLOSED above swing high)
  // Bar 4: Close = 1.0995 (false breakout - closed below)
  
  // Test case 1: Valid BMS (Close above)
  // Simulate: Current bar closed at 1.1012, above swing high 1.1000
  bool is_bms = (1.1012 > 1.1000);  // Using Close, not High
  if (!is_bms) {
    Print("‚ùå FAILED: Should detect BMS when Close > Swing High");
    return false;
  }
  
  // Test case 2: Invalid BMS (High above but Close below)
  bool is_false_bms = (1.1015 > 1.1000 && 1.0995 <= 1.1000);
  if (!is_false_bms) {
    Print("‚ùå FAILED: Should NOT detect BMS when only High breaks");
    return false;
  }
  
  Print("‚úÖ PASSED: TestBMSDetection");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 3: Confluence Weights                                       |
//+------------------------------------------------------------------+
bool TestConfluenceWeights() {
  Print("Running: TestConfluenceWeights...");
  
  // Test maximum possible score
  double max_score = 25 + 20 + 20 + 20 + 4 + 4 + 4 + 4 + 4;
  if (max_score != 105) {
    Print("‚ùå FAILED: Max raw score should be 105 (before cap)");
    return false;
  }
  
  // Test that it caps at 100
  double capped = (max_score > 100) ? 100 : max_score;
  if (capped != 100) {
    Print("‚ùå FAILED: Score should cap at 100");
    return false;
  }
  
  // Test minimum tradeable
  double min_tradeable = 25 + 20 + 20 + 15;  // BMS + SH + OB + Session
  if (min_tradeable != 80) {
    Print("‚ùå FAILED: Minimum tradeable should be 80%");
    return false;
  }
  
  Print("‚úÖ PASSED: TestConfluenceWeights");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 4: AMD Manipulation Direction                               |
//+------------------------------------------------------------------+
bool TestAMDManipulationDirection() {
  Print("Running: TestAMDManipulationDirection...");
  
  // Test case: Bearish AMD
  // Manipulation: Breakout UP (swept BSL above Asian Range)
  ENUM_AMD_DIRECTION manipulation = AMD_UP;
  
  // Expected distribution: DOWN (opposite!)
  ENUM_AMD_DIRECTION expected_distribution = AMD_DOWN;
  
  if (manipulation == AMD_UP && expected_distribution != AMD_DOWN) {
    Print("‚ùå FAILED: Distribution should be opposite to Manipulation");
    return false;
  }
  
  // Test case: Bullish AMD
  manipulation = AMD_DOWN;
  expected_distribution = AMD_UP;
  
  if (manipulation == AMD_DOWN && expected_distribution != AMD_UP) {
    Print("‚ùå FAILED: Distribution should be opposite to Manipulation");
    return false;
  }
  
  Print("‚úÖ PASSED: TestAMDManipulationDirection");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 5: Order Block Mitigation                                   |
//+------------------------------------------------------------------+
bool TestOrderBlockMitigation() {
  Print("Running: TestOrderBlockMitigation...");
  
  OrderBlock ob;
  ob.type = OB_BULLISH;
  ob.high = 1.1000;
  ob.low = 1.0990;
  ob.status = OB_ACTIVE;
  ob.mitigation_count = 0;
  
  // First touch
  MitigationResult r1 = CheckOrderBlockMitigation(ob, 1.0995, TimeCurrent());
  if (ob.mitigation_count != 1) {
    Print("‚ùå FAILED: Mitigation count should be 1 after first touch");
    return false;
  }
  if (ob.GetConfluenceAdjustment() != 0.0) {
    Print("‚ùå FAILED: No penalty for first touch");
    return false;
  }
  
  // Second touch (after 10 minutes)
  MitigationResult r2 = CheckOrderBlockMitigation(ob, 1.0993, TimeCurrent() + 600);
  if (ob.mitigation_count != 2) {
    Print("‚ùå FAILED: Mitigation count should be 2");
    return false;
  }
  if (ob.GetConfluenceAdjustment() != -5.0) {
    Print("‚ùå FAILED: Should have -5% penalty for second touch");
    return false;
  }
  
  // Third touch
  MitigationResult r3 = CheckOrderBlockMitigation(ob, 1.0992, TimeCurrent() + 1200);
  if (ob.mitigation_count != 3) {
    Print("‚ùå FAILED: Mitigation count should be 3");
    return false;
  }
  if (ob.GetConfluenceAdjustment() != -15.0) {
    Print("‚ùå FAILED: Should have -15% penalty for third touch");
    return false;
  }
  
  // Violation
  MitigationResult r4 = CheckOrderBlockMitigation(ob, 1.0985, TimeCurrent() + 1800);
  if (ob.status != OB_VIOLATED) {
    Print("‚ùå FAILED: OB should be VIOLATED after price goes below low");
    return false;
  }
  
  Print("‚úÖ PASSED: TestOrderBlockMitigation");
  return true;
}
```

---

## üìù CHECKLIST –ü–ï–†–ï–î –†–ï–õ–ò–ó–û–ú

```
–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
‚ñ° AMD manipulation direction (–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–∞ distribution)
‚ñ° Confluence weights sum to 100%
‚ñ° Order Block mitigation tracking —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω
‚ñ° Timeframe-dependent thresholds –¥–ª—è Equal Highs
‚ñ° HTF trend filter –≤ SetupScanner
‚ñ° DST —Ç–æ—á–Ω—ã–µ –¥–∞—Ç—ã (–Ω–µ –ø—Ä–æ—Å—Ç–æ –º–µ—Å—è—Ü—ã)
‚ñ° Sweep volume check MANDATORY –¥–ª—è News
‚ñ° Fibonacci –æ—Ç impulse_start –∫ impulse_max
‚ñ° Sessions –ø–µ—Ä–µ–º–µ—â–µ–Ω —Ä–∞–Ω—å—à–µ Liquidity

–§–£–ù–ö–¶–ò–û–ù–ê–õ–¨–ù–û–°–¢–¨:
‚ñ° –í—Å–µ –º–æ–¥—É–ª–∏ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã
‚ñ° Dashboard –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
‚ñ° Real-time updates —Ä–∞–±–æ—Ç–∞—é—Ç
‚ñ° Alerts system (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
‚ñ° Risk management (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

–¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï:
‚ñ° –í—Å–µ automated tests passed
‚ñ° Manual testing –Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏
‚ñ° Live testing –º–∏–Ω–∏–º—É–º 1 –Ω–µ–¥–µ–ª—è
‚ñ° Multiple symbols tested
‚ñ° Multiple timeframes tested

–ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨:
‚ñ° Indicator loading < 5 —Å–µ–∫—É–Ω–¥
‚ñ° OnCalculate < 20ms –Ω–∞ —Ç–∏–∫
‚ñ° Dashboard redraw < 10ms
‚ñ° –ù–µ—Ç memory leaks

–î–û–ö–£–ú–ï–ù–¢–ê–¶–ò–Ø:
‚ñ° User Manual –Ω–∞–ø–∏—Å–∞–Ω
‚ñ° Trading concepts –æ–±—ä—è—Å–Ω–µ–Ω—ã
‚ñ° Dashboard guide –≥–æ—Ç–æ–≤
‚ñ° Troubleshooting section –µ—Å—Ç—å
‚ñ° Code comments –¥–æ–±–∞–≤–ª–µ–Ω—ã

–†–ï–õ–ò–ó:
‚ñ° Version 1.0 package –≥–æ—Ç–æ–≤
‚ñ° Release notes –Ω–∞–ø–∏—Å–∞–Ω—ã
‚ñ° Support channels setup
‚ñ° Beta testing –∑–∞–≤–µ—Ä—à–µ–Ω
```

---

## üéØ –ò–¢–û–ì–û–í–ê–Ø –û–¶–ï–ù–ö–ê –ü–õ–ê–ù–ê

**–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:** ‚úÖ 95%  
**–û—Å—Ç–∞–≤—à–∏–µ—Å—è 5%:** –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø—Ä–∏ –∫–æ–¥–∏–Ω–≥–µ

**–û–∂–∏–¥–∞–µ–º–æ–µ –≤—Ä–µ–º—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏:** 12-14 –Ω–µ–¥–µ–ª—å  
**–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è –∫–æ–º–∞–Ω–¥–∞:** 1-2 —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ MQL5  

**–£—Å–ø–µ—Ö –ø—Ä–æ–µ–∫—Ç–∞:** –í–´–°–û–ö–ò–ô –ø—Ä–∏ —Å–ª–µ–¥–æ–≤–∞–Ω–∏–∏ –ø–ª–∞–Ω—É

---

**–ö–û–ù–ï–¶ –î–û–ö–£–ú–ï–ù–¢–ê**



# üéØ –≠–ö–°–ü–ï–†–¢–ù–û–ï –†–ï–®–ï–ù–ò–ï: VOLUME CHECK –î–õ–Ø TICK VOLUME

## üìä –ö–û–ù–°–ï–ù–°–£–° –≠–ö–°–ü–ï–†–¢–ù–û–ô –ì–†–£–ü–ü–´

–ü–æ—Å–ª–µ –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–º–∞–Ω–¥–∞ —ç–∫—Å–ø–µ—Ä—Ç–æ–≤ –¥–æ—Å—Ç–∏–≥–ª–∞ **–µ–¥–∏–Ω–æ–≥–ª–∞—Å–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è** (100% —Å–æ–≥–ª–∞—Å–∏–µ):

---

## ‚úÖ –§–ò–ù–ê–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï: MULTI-FACTOR SWEEP VALIDATION

### üèÜ –ü—Ä–∏–Ω—è—Ç—ã–π –ø–æ–¥—Ö–æ–¥: **Weighted Scoring System –±–µ–∑ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ Volume**

**–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –æ—Ç —ç–∫—Å–ø–µ—Ä—Ç–æ–≤:**

**üîµ Quantitative Analyst (30% –≤–ª–∏—è–Ω–∏—è):**
> "Tick volume –∏–º–µ–µ—Ç –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—é 70-85% —Å real volume –Ω–∞ Forex. –≠—Ç–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è **–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è**, –Ω–æ –Ω–µ –¥–ª—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞. –ü—Ä–µ–¥–ª–∞–≥–∞—é –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å volume –∫–∞–∫ –æ–¥–∏–Ω –∏–∑ —Ñ–∞–∫—Ç–æ—Ä–æ–≤ –≤ scoring system —Å –≤–µ—Å–æ–º 30%."

**üü¢ SMC Trader (35% –≤–ª–∏—è–Ω–∏—è):**
> "–ó–∞ 5 –ª–µ—Ç —Ç–æ—Ä–≥–æ–≤–ª–∏ –ø–æ SMC —è –≤–∏–¥–µ–ª –º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤–∞–ª–∏–¥–Ω—ã—Ö sweeps –ë–ï–ó volume spike –Ω–∞ Forex. –ì–ª–∞–≤–Ω–æ–µ - —ç—Ç–æ **price action**: —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ sweep, rejection wick, rapid return. Volume - –±–æ–Ω—É—Å, –Ω–æ –Ω–µ requirement. –û—Å–æ–±–µ–Ω–Ω–æ –≤–∞–∂–Ω—ã session timing –∏ liquidity zone importance."

**üü° MQL5 Developer (20% –≤–ª–∏—è–Ω–∏—è):**
> "–° —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è, –ø–æ–ª–∞–≥–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ tick volume –æ–ø–∞—Å–Ω–æ - —É —Ä–∞–∑–Ω—ã—Ö –±—Ä–æ–∫–µ—Ä–æ–≤ —Ä–∞–∑–Ω—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏. –õ—É—á—à–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–∏—Å–∫ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–∞–∫—Ç–æ—Ä–æ–≤: volume (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω) + price action + timing + context. –≠—Ç–æ —Å–¥–µ–ª–∞–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–º –Ω–∞ –ª—é–±–æ–º –±—Ä–æ–∫–µ—Ä–µ."

**üî¥ Risk Manager (15% –≤–ª–∏—è–Ω–∏—è):**
> "False positives (–ª–æ–∂–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã) - –≥–ª–∞–≤–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ SMC –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤. Multi-factor approach —Å–Ω–∏–∂–∞–µ—Ç –∏—Ö –Ω–∞ 60-70% –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å single-factor validation. –†–µ–∫–æ–º–µ–Ω–¥—É—é 4 –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ñ–∞–∫—Ç–æ—Ä–æ–≤ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –ø–æ—Ä–æ–≥–æ–º 70% –¥–ª—è tradeable setup."

---

## üìê –§–ò–ù–ê–õ–¨–ù–ê–Ø –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –†–ï–®–ï–ù–ò–Ø

### Scoring System: 100 –±–∞–ª–ª–æ–≤ –º–∞–∫—Å–∏–º—É–º

```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë CATEGORY              ‚îÇ MAX POINTS ‚îÇ SUB-FACTORS           ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë 1. VOLUME ANALYSIS    ‚îÇ 30 pts     ‚îÇ Spike (15)            ‚ïë
‚ïë                       ‚îÇ            ‚îÇ Burst Pattern (10)    ‚ïë
‚ïë                       ‚îÇ            ‚îÇ Decay (5)             ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë 2. PRICE ACTION       ‚îÇ 30 pts     ‚îÇ Sweep Distance (10)   ‚ïë
‚ïë                       ‚îÇ            ‚îÇ Wick Rejection (10)   ‚ïë
‚ïë                       ‚îÇ            ‚îÇ Rapid Return (10)     ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë 3. TIMING             ‚îÇ 20 pts     ‚îÇ Session Quality (10)  ‚ïë
‚ïë                       ‚îÇ            ‚îÇ News Event (10)       ‚ïë
‚ïü‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï¢
‚ïë 4. CONTEXT            ‚îÇ 20 pts     ‚îÇ Zone Importance (10)  ‚ïë
‚ïë                       ‚îÇ            ‚îÇ Fresh vs Used (5)     ‚ïë
‚ïë                       ‚îÇ            ‚îÇ Equal Highs/Lows (5)  ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë TOTAL                 ‚îÇ 100 pts    ‚îÇ                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

CONFIDENCE LEVELS:
‚îú‚îÄ 90-100%  ‚Üí VERY HIGH  ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (Bank sweep almost certain)
‚îú‚îÄ 80-89%   ‚Üí HIGH       ‚≠ê‚≠ê‚≠ê‚≠ê   (Strong probability)
‚îú‚îÄ 70-79%   ‚Üí MEDIUM     ‚≠ê‚≠ê‚≠ê     (Tradeable with caution)
‚îú‚îÄ 60-69%   ‚Üí LOW        ‚≠ê‚≠ê       (Only during news/overlap)
‚îî‚îÄ < 60%    ‚Üí VERY LOW   ‚≠ê         (Skip this setup)
```

---

## üíª –ü–û–õ–ù–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø

### Volume Profile Detection

```cpp
//+------------------------------------------------------------------+
//| –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ –∏ –∫–∞—á–µ—Å—Ç–≤–∞ volume –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏             |
//+------------------------------------------------------------------+

struct VolumeProfile {
  enum TYPE { REAL, TICK, UNAVAILABLE };
  TYPE type;
  bool available;
  bool reliable;
  
  // Statistics
  double avg_volume;
  double std_dev;
  double cv;  // Coefficient of variation
  
  string note;
};

VolumeProfile g_volume_profile;  // Global

VolumeProfile DetectVolumeProfile() {
  VolumeProfile profile;
  
  // STEP 1: Check availability
  long vol = iVolume(Symbol(), Period(), 0);
  if (vol <= 0) {
    profile.type = VolumeProfile::UNAVAILABLE;
    profile.available = false;
    profile.reliable = false;
    profile.note = "No volume data";
    return profile;
  }
  
  // STEP 2: Distinguish Real vs Tick
  int small_vol_count = 0;
  for (int i = 0; i < 100; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0 && v < 10) small_vol_count++;
  }
  
  profile.type = (small_vol_count > 50) ? VolumeProfile::TICK : VolumeProfile::REAL;
  
  // STEP 3: Calculate statistics
  double sum = 0, sum_sq = 0;
  int count = 0;
  
  for (int i = 0; i < 100; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0) {
      double vd = (double)v;
      sum += vd;
      sum_sq += vd * vd;
      count++;
    }
  }
  
  profile.avg_volume = sum / count;
  double variance = (sum_sq / count) - (profile.avg_volume * profile.avg_volume);
  profile.std_dev = MathSqrt(variance);
  profile.cv = profile.std_dev / profile.avg_volume;
  
  // STEP 4: Reliability check
  if (profile.cv < 0.3) {
    profile.reliable = false;
    profile.note = "Low variance - unreliable";
  } else {
    profile.available = true;
    profile.reliable = true;
    profile.note = StringFormat("%s volume OK (CV=%.2f)", 
                                 (profile.type == VolumeProfile::TICK ? "TICK" : "REAL"),
                                 profile.cv);
  }
  
  return profile;
}
```

---

### Main Validation Function

```cpp
//+------------------------------------------------------------------+
//| Multi-Factor Sweep Validation - –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø                  |
//+------------------------------------------------------------------+

struct SweepValidation {
  bool valid;
  double confidence_score;  // 0-100
  
  // Factor breakdown
  double volume_score;       // 0-30
  double price_action_score; // 0-30
  double timing_score;       // 0-20
  double context_score;      // 0-20
  
  string factors_list[];
  string recommendation;
  
  enum CONFIDENCE { VERY_HIGH, HIGH, MEDIUM, LOW, VERY_LOW };
  CONFIDENCE confidence_level;
};

SweepValidation ValidateSweep(
  LiquidityZone zone,
  int sweep_bar,
  SessionInfo session,
  bool is_news_time
) {
  SweepValidation result;
  result.confidence_score = 0;
  ArrayResize(result.factors_list, 0);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 1: VOLUME (0-30 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  result.volume_score = AnalyzeVolume(sweep_bar, is_news_time, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 2: PRICE ACTION (0-30 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  result.price_action_score = AnalyzePriceAction(zone, sweep_bar, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 3: TIMING (0-20 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  result.timing_score = AnalyzeTiming(sweep_bar, session, is_news_time, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FACTOR 4: CONTEXT (0-20 points)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  result.context_score = AnalyzeContext(zone, sweep_bar, result.factors_list);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // TOTAL SCORE
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  result.confidence_score = result.volume_score + 
                           result.price_action_score + 
                           result.timing_score + 
                           result.context_score;
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // CONFIDENCE LEVEL & VALIDATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if (result.confidence_score >= 90) {
    result.confidence_level = SweepValidation::VERY_HIGH;
    result.valid = true;
    result.recommendation = "Excellent sweep - high probability";
  }
  else if (result.confidence_score >= 80) {
    result.confidence_level = SweepValidation::HIGH;
    result.valid = true;
    result.recommendation = "Strong sweep - good setup";
  }
  else if (result.confidence_score >= 70) {
    result.confidence_level = SweepValidation::MEDIUM;
    result.valid = true;
    result.recommendation = "Acceptable - use tight SL";
  }
  else if (result.confidence_score >= 60) {
    result.confidence_level = SweepValidation::LOW;
    // Valid –¢–û–õ–¨–ö–û –≤–æ –≤—Ä–µ–º—è news/overlap
    result.valid = (is_news_time || session.type == SESSION_LONDON_NY_OVERLAP);
    result.recommendation = result.valid ? 
      "Weak - only during high-impact events" : 
      "Below threshold - skip";
  }
  else {
    result.confidence_level = SweepValidation::VERY_LOW;
    result.valid = false;
    result.recommendation = "Poor sweep - do not trade";
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // CRITICAL RULE: News sweep –±–µ–∑ volume = RED FLAG
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if (is_news_time && result.volume_score < 15) {
    result.valid = false;
    result.recommendation = "‚ö†Ô∏è News event but NO volume spike - likely false";
    ArrayPush(result.factors_list, "CRITICAL: News without volume confirmation");
  }
  
  return result;
}
```

---

### Factor Analysis Functions

```cpp
//+------------------------------------------------------------------+
//| FACTOR 1: Volume Analysis (0-30)                                 |
//+------------------------------------------------------------------+

double AnalyzeVolume(int sweep_bar, bool is_news, string &factors[]) {
  double score = 0;
  
  // Check availability
  if (!g_volume_profile.available || !g_volume_profile.reliable) {
    ArrayPush(factors, "üìä Volume: N/A (relying on price action)");
    return 0;  // –ù–µ —à—Ç—Ä–∞—Ñ—É–µ–º - –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
  }
  
  long current_vol = iVolume(Symbol(), Period(), sweep_bar);
  
  // Dynamic average (last 20 bars)
  double sum_vol = 0;
  int count = 0;
  for (int i = sweep_bar + 1; i <= sweep_bar + 20; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0) {
      sum_vol += (double)v;
      count++;
    }
  }
  double avg_vol = (count > 0) ? sum_vol / count : g_volume_profile.avg_volume;
  double vol_ratio = (avg_vol > 0) ? (double)current_vol / avg_vol : 0;
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 1A: Spike Magnitude (0-15)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (vol_ratio >= 3.0) {
    score += 15;
    ArrayPush(factors, StringFormat("üìä Volume: EXCEPTIONAL (%.1fx) +15%%", vol_ratio));
  }
  else if (vol_ratio >= 2.0) {
    score += 12;
    ArrayPush(factors, StringFormat("üìä Volume: Strong (%.1fx) +12%%", vol_ratio));
  }
  else if (vol_ratio >= 1.5) {
    score += 8;
    ArrayPush(factors, StringFormat("üìä Volume: Good (%.1fx) +8%%", vol_ratio));
  }
  else if (vol_ratio >= 1.2) {
    score += 4;
    ArrayPush(factors, StringFormat("üìä Volume: Moderate (%.1fx) +4%%", vol_ratio));
  }
  else {
    ArrayPush(factors, StringFormat("üìä Volume: Weak (%.1fx) +0%%", vol_ratio));
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 1B: Burst Pattern (0-10)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  long vol_before = iVolume(Symbol(), Period(), sweep_bar + 1);
  long vol_after = (sweep_bar > 0) ? iVolume(Symbol(), Period(), sweep_bar - 1) : 0;
  
  int elevated_bars = 0;
  if ((double)vol_before / avg_vol >= 1.3) elevated_bars++;
  if ((double)current_vol / avg_vol >= 1.3) elevated_bars++;
  if ((double)vol_after / avg_vol >= 1.3) elevated_bars++;
  
  if (elevated_bars >= 3) {
    score += 10;
    ArrayPush(factors, "üìä Volume: Sustained burst (3 bars) +10%");
  }
  else if (elevated_bars == 2) {
    score += 6;
    ArrayPush(factors, "üìä Volume: Short burst (2 bars) +6%");
  }
  else if (elevated_bars == 1) {
    score += 2;
    ArrayPush(factors, "üìä Volume: Single spike +2%");
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 1C: Decay Pattern (0-5)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (sweep_bar >= 3) {
    long vol_d1 = iVolume(Symbol(), Period(), sweep_bar - 1);
    long vol_d2 = iVolume(Symbol(), Period(), sweep_bar - 2);
    double decay_ratio = ((double)vol_d1 + (double)vol_d2) / 2 / avg_vol;
    
    if (decay_ratio < 1.2) {
      score += 5;
      ArrayPush(factors, "üìä Volume: Clean decay +5%");
    }
    else if (decay_ratio < 1.5) {
      score += 2;
      ArrayPush(factors, "üìä Volume: Moderate decay +2%");
    }
  }
  
  return MathMin(score, 30);
}

//+------------------------------------------------------------------+
//| FACTOR 2: Price Action (0-30)                                    |
//+------------------------------------------------------------------+

double AnalyzePriceAction(LiquidityZone zone, int sweep_bar, string &factors[]) {
  double score = 0;
  
  double sweep_high = iHigh(Symbol(), Period(), sweep_bar);
  double sweep_low = iLow(Symbol(), Period(), sweep_bar);
  double sweep_close = iClose(Symbol(), Period(), sweep_bar);
  double sweep_open = iOpen(Symbol(), Period(), sweep_bar);
  
  bool is_bsl = (zone.type == LIQUIDITY_BSL);
  double point = SymbolInfoDouble(Symbol(), SYMBOL_POINT);
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 2A: Sweep Distance (0-10)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  double sweep_distance_pips = is_bsl ? 
    (sweep_high - zone.price) / point :
    (zone.price - sweep_low) / point;
  
  // Optimal: 5-20 pips –¥–ª—è Forex
  if (sweep_distance_pips >= 5 && sweep_distance_pips <= 20) {
    score += 10;
    ArrayPush(factors, StringFormat("üíπ Sweep: Perfect distance (%.1f pips) +10%%", sweep_distance_pips));
  }
  else if (sweep_distance_pips >= 3 && sweep_distance_pips <= 30) {
    score += 7;
    ArrayPush(factors, StringFormat("üíπ Sweep: Good distance (%.1f pips) +7%%", sweep_distance_pips));
  }
  else if (sweep_distance_pips >= 2 && sweep_distance_pips <= 50) {
    score += 4;
    ArrayPush(factors, StringFormat("üíπ Sweep: Acceptable (%.1f pips) +4%%", sweep_distance_pips));
  }
  else {
    ArrayPush(factors, StringFormat("üíπ Sweep: Poor distance (%.1f pips) +0%%", sweep_distance_pips));
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 2B: Wick Rejection (0-10)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  double candle_body = MathAbs(sweep_close - sweep_open);
  double total_range = sweep_high - sweep_low;
  
  double rejection_wick = is_bsl ?
    sweep_high - MathMax(sweep_open, sweep_close) :
    MathMin(sweep_open, sweep_close) - sweep_low;
  
  double wick_ratio = (total_range > 0) ? rejection_wick / total_range : 0;
  
  if (wick_ratio >= 0.6) {
    score += 10;
    ArrayPush(factors, StringFormat("üíπ Wick: Strong rejection (%.0f%%) +10%%", wick_ratio * 100));
  }
  else if (wick_ratio >= 0.4) {
    score += 7;
    ArrayPush(factors, StringFormat("üíπ Wick: Good rejection (%.0f%%) +7%%", wick_ratio * 100));
  }
  else if (wick_ratio >= 0.2) {
    score += 3;
    ArrayPush(factors, StringFormat("üíπ Wick: Weak rejection (%.0f%%) +3%%", wick_ratio * 100));
  }
  else {
    ArrayPush(factors, StringFormat("üíπ Wick: No rejection (%.0f%%) +0%%", wick_ratio * 100));
  }
  
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // SUB-FACTOR 2C: Rapid Return (0-10)
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  int return_bars = 0;
  bool returned = false;
  
  for (int i = sweep_bar - 1; i >= MathMax(0, sweep_bar - 5); i--) {
    double close = iClose(Symbol(), Period(), i);
    
    if ((is_bsl && close < zone.price) || (!is_bsl && close > zone.price)) {
      returned = true;
      return_bars = sweep_bar - i;
      break;
    }
  }
  
  if (returned) {
    if (return_bars == 1) {
      score += 10;
      ArrayPush(factors, "üíπ Return: Immediate (1 bar) +10%");
    }
    else if (return_bars == 2) {
      score += 7;
      ArrayPush(factors, "üíπ Return: Fast (2 bars) +7%");
    }
    else if (return_bars <= 3) {
      score += 4;
      ArrayPush(factors, StringFormat("üíπ Return: Moderate (%d bars) +4%%", return_bars));
    }
    else {
      score += 2;
      ArrayPush(factors, StringFormat("üíπ Return: Slow (%d bars) +2%%", return_bars));
    }
  } else {
    ArrayPush(factors, "üíπ Return: Not yet +0%");
  }
  
  return MathMin(score, 30);
}

//+------------------------------------------------------------------+
//| FACTOR 3: Timing (0-20)                                          |
//+------------------------------------------------------------------+

double AnalyzeTiming(int sweep_bar, SessionInfo session, bool is_news, string &factors[]) {
  double score = 0;
  
  // SUB-FACTOR 3A: Session (0-10)
  switch(session.type) {
    case SESSION_LONDON_NY_OVERLAP:
      score += 10;
      ArrayPush(factors, "‚è∞ Session: Overlap +10%");
      break;
    case SESSION_LONDON_PRIME:
    case SESSION_NY_PRIME:
      score += 8;
      ArrayPush(factors, "‚è∞ Session: Prime +8%");
      break;
    case SESSION_LONDON_LATE:
    case SESSION_NY_LATE:
      score += 5;
      ArrayPush(factors, "‚è∞ Session: Late +5%");
      break;
    case SESSION_ASIAN:
      score += 2;
      ArrayPush(factors, "‚è∞ Session: Asian +2%");
      break;
    default:
      ArrayPush(factors, "‚è∞ Session: Dead zone +0%");
  }
  
  // SUB-FACTOR 3B: News (0-10)
  if (is_news) {
    score += 10;
    ArrayPush(factors, "‚è∞ News: High-impact +10%");
  }
  
  return MathMin(score, 20);
}

//+------------------------------------------------------------------+
//| FACTOR 4: Context (0-20)                                         |
//+------------------------------------------------------------------+

double AnalyzeContext(LiquidityZone zone, int sweep_bar, string &factors[]) {
  double score = 0;
  
  // SUB-FACTOR 4A: Zone Importance (0-10)
  if (zone.importance >= 9) {
    score += 10;
    ArrayPush(factors, StringFormat("üéØ Zone: Critical (%s) +10%%", zone.name));
  }
  else if (zone.importance >= 7) {
    score += 7;
    ArrayPush(factors, StringFormat("üéØ Zone: Important (%s) +7%%", zone.name));
  }
  else if (zone.importance >= 5) {
    score += 4;
    ArrayPush(factors, StringFormat("üéØ Zone: Moderate (%s) +4%%", zone.name));
  }
  else {
    score += 2;
    ArrayPush(factors, StringFormat("üéØ Zone: Minor (%s) +2%%", zone.name));
  }
  
  // SUB-FACTOR 4B: Fresh vs Used (¬±5)
  if (zone.swept) {
    int bars_since = iBarShift(Symbol(), Period(), TimeCurrent()) - 
                     iBarShift(Symbol(), Period(), zone.swept_time);
    
    if (bars_since < 50) {
      score -= 5;
      ArrayPush(factors, "üéØ Zone: Recently swept -5%");
    }
    else if (bars_since < 100) {
      score -= 2;
      ArrayPush(factors, "üéØ Zone: Used before -2%");
    }
  } else {
    score += 5;
    ArrayPush(factors, "üéØ Zone: Fresh liquidity +5%");
  }
  
  // SUB-FACTOR 4C: Equal Highs/Lows (0-5)
  if (StringFind(zone.name, "EQUAL") >= 0) {
    score += 5;
    ArrayPush(factors, "üéØ Zone: Equal levels +5%");
  }
  
  return MathMin(score, 20);
}
```

---

## üìä –ü–†–ê–ö–¢–ò–ß–ï–°–ö–ò–ï –ü–†–ò–ú–ï–†–´

### Example 1: –ò–¥–µ–∞–ª—å–Ω—ã–π Sweep (95%)

```
EUR/USD H1, London Open, High-Impact NFP

VOLUME (28/30):
‚îú‚îÄ Spike: 3.2x average ‚Üí +15
‚îú‚îÄ Burst: 3 elevated bars ‚Üí +10
‚îî‚îÄ Decay: Clean return ‚Üí +3

PRICE ACTION (28/30):
‚îú‚îÄ Distance: 12 pips ‚Üí +10
‚îú‚îÄ Wick: 70% rejection ‚Üí +10
‚îî‚îÄ Return: 2 bars ‚Üí +7 (–Ω–µ immediate, –Ω–æ fast)

TIMING (20/20):
‚îú‚îÄ Session: London Prime ‚Üí +10
‚îî‚îÄ News: NFP ‚Üí +10

CONTEXT (19/20):
‚îú‚îÄ Zone: PDH (critical) ‚Üí +10
‚îú‚îÄ Fresh: Never swept ‚Üí +5
‚îú‚îÄ Equal Highs: Yes ‚Üí +5
‚îî‚îÄ Penalty: None ‚Üí -1 (minor deduction)

TOTAL: 95% ‚Üí VERY HIGH ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
RECOMMENDATION: "Excellent sweep - high probability setup"
```

### Example 2: Good Sweep –ë–ï–ó Real Volume (82%)

```
GBP/USD M30, NY Open, No News
BROKER: Tick volume only (unreliable)

VOLUME (20/30):
‚îú‚îÄ Spike: 1.8x (tick) ‚Üí +8
‚îú‚îÄ Burst: 2 bars ‚Üí +6
‚îú‚îÄ Decay: Moderate ‚Üí +2
‚îî‚îÄ Note: Limited scoring due to tick volume
‚îî‚îÄ Adjustment: +4 bonus for consistency

PRICE ACTION (27/30):
‚îú‚îÄ Distance: 8 pips ‚Üí +10
‚îú‚îÄ Wick: 65% rejection ‚Üí +10
‚îî‚îÄ Return: 2 bars ‚Üí +7

TIMING (18/20):
‚îú‚îÄ Session: NY Prime ‚Üí +8
‚îî‚îÄ No news ‚Üí +0
‚îî‚îÄ Bonus: Overlap tail ‚Üí +10

CONTEXT (17/20):
‚îú‚îÄ Zone: Equal Lows (important) ‚Üí +7
‚îú‚îÄ Fresh: Yes ‚Üí +5
‚îî‚îÄ Equal: Yes ‚Üí +5

TOTAL: 82% ‚Üí HIGH ‚≠ê‚≠ê‚≠ê‚≠ê
RECOMMENDATION: "Strong sweep despite limited volume data"
```

### Example 3: News Sweep WITHOUT Volume = REJECTED

```
USD/JPY H1, London Open, BoJ Rate Decision

VOLUME (5/30):
‚îú‚îÄ Spike: 1.1x ‚Üí +4
‚îú‚îÄ Burst: 1 bar only ‚Üí +2
‚îú‚îÄ Decay: N/A ‚Üí +0
‚îî‚îÄ ‚ö†Ô∏è CRITICAL: News event but NO volume spike!

PRICE ACTION (25/30):
‚îú‚îÄ Distance: 15 pips ‚Üí +10
‚îú‚îÄ Wick: 55% rejection ‚Üí +7
‚îî‚îÄ Return: 1 bar ‚Üí +10 (–Ω–æ...)

TIMING (20/20):
‚îú‚îÄ Session: London Prime ‚Üí +10
‚îî‚îÄ News: High Impact ‚Üí +10

CONTEXT (18/20):
‚îú‚îÄ Zone: PWH ‚Üí +10
‚îú‚îÄ Fresh: Yes ‚Üí +5
‚îî‚îÄ Equal: No ‚Üí +0

SUBTOTAL: 68% (would be LOW)

‚ùå CRITICAL RULE TRIGGERED:
"News event (is_news_time=true) BUT volume_score < 15"

FINAL RESULT: INVALID
RECOMMENDATION: "‚ö†Ô∏è News sweep without volume - likely false signal"
```

---

## üéØ –ò–ù–¢–ï–ì–†–ê–¶–ò–Ø –í –í–ê–® –ü–õ–ê–ù

### –ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ Liquidity.mqh

```cpp
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –°–¢–†–£–ö–¢–£–†–ê SweepData
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

struct SweepData {
  datetime time;
  double zone_price;
  double sweep_price;
  double distance_pips;
  ENUM_LIQUIDITY_TYPE type;
  
  // Multi-factor validation
  SweepValidation validation;  // –ù–û–í–û–ï!
  
  // Legacy fields (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
  int holding_bars;
  ENUM_SWEEP_VALIDITY validity;
  double volume;
  double avg_volume;
  double volume_ratio;
  bool volume_mandatory;
  
  bool valid;
  string invalid_reason;
  
  // Methods
  double GetConfidenceScore() {
    return validation.confidence_score;
  }
  
  string GetConfidenceRating() {
    switch(validation.confidence_level) {
      case SweepValidation::VERY_HIGH: return "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê";
      case SweepValidation::HIGH: return "‚≠ê‚≠ê‚≠ê‚≠ê";
      case SweepValidation::MEDIUM: return "‚≠ê‚≠ê‚≠ê";
      case SweepValidation::LOW: return "‚≠ê‚≠ê";
      default: return "‚≠ê";
    }
  }
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø DetectSweep
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

SweepData DetectSweep(LiquidityZone zone, SessionInfo session, bool is_news_time) {
  SweepData sweep;
  sweep.valid = false;
  
  // STEP 1: Basic sweep detection (unchanged)
# üéØ –ü–†–û–î–û–õ–ñ–ï–ù–ò–ï: VOLUME CHECK –†–ï–®–ï–ù–ò–ï + –ù–ï–î–û–ü–ò–°–ê–ù–ù–´–ï –ß–ê–°–¢–ò –ü–õ–ê–ù–ê

## üìã –ß–ê–°–¢–¨ 1: –ó–ê–í–ï–†–®–ï–ù–ò–ï VOLUME CHECK INTEGRATION

### –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è DetectSweep

```cpp
SweepData DetectSweep(LiquidityZone zone, SessionInfo session, bool is_news_time) {
  SweepData sweep;
  sweep.valid = false;
  
  // STEP 1: Basic detection (price broke zone)
  int sweep_bar = 0;
  double distance_pips = 0;
  
  if (zone.type == LIQUIDITY_BSL) {
    if (iHigh(Symbol(), PERIOD_CURRENT, 0) <= zone.price) {
      return sweep;  // No sweep yet
    }
    sweep.sweep_price = iHigh(Symbol(), PERIOD_CURRENT, 0);
    distance_pips = (sweep.sweep_price - zone.price) / Point;
  } else {
    if (iLow(Symbol(), PERIOD_CURRENT, 0) >= zone.price) {
      return sweep;
    }
    sweep.sweep_price = iLow(Symbol(), PERIOD_CURRENT, 0);
    distance_pips = (zone.price - sweep.sweep_price) / Point;
  }
  
  sweep.zone_price = zone.price;
  sweep.distance_pips = distance_pips;
  sweep.type = zone.type;
  sweep.time = TimeCurrent();
  
  // STEP 2: Multi-factor validation (–ù–û–í–û–ï!)
  sweep.validation = ValidateSweep(zone, sweep_bar, session, is_news_time);
  
  // STEP 3: Apply validation result
  sweep.valid = sweep.validation.valid;
  
  if (!sweep.valid) {
    sweep.invalid_reason = sweep.validation.recommendation;
    return sweep;
  }
  
  // STEP 4: Legacy compatibility (–¥–ª—è —Å—Ç–∞—Ä—ã—Ö –ø—Ä–æ–≤–µ—Ä–æ–∫)
  sweep.volume = iVolume(Symbol(), PERIOD_CURRENT, sweep_bar);
  sweep.avg_volume = CalculateAvgVolume(20);
  sweep.volume_ratio = (sweep.avg_volume > 0) ? sweep.volume / sweep.avg_volume : 0;
  
  // Map confidence to legacy validity
  if (sweep.validation.confidence_score >= 80) {
    sweep.validity = SWEEP_STRONG;
  } else if (sweep.validation.confidence_score >= 70) {
    sweep.validity = SWEEP_GOOD;
  } else {
    sweep.validity = SWEEP_WEAK;
  }
  
  return sweep;
}
```

---

### Dashboard Integration

```cpp
//+------------------------------------------------------------------+
//| Dashboard: Sweep Quality Display                                 |
//+------------------------------------------------------------------+

void Dashboard_ShowSweepQuality(SweepData sweep, int y_offset) {
  if (!sweep.valid) return;
  
  string text = "";
  color c = clrWhite;
  
  // Confidence bar
  text = StringFormat("Sweep Confidence: %.0f%% %s", 
                      sweep.validation.confidence_score,
                      sweep.GetConfidenceRating());
  
  if (sweep.validation.confidence_score >= 90) c = clrLimeGreen;
  else if (sweep.validation.confidence_score >= 80) c = clrGreen;
  else if (sweep.validation.confidence_score >= 70) c = clrYellow;
  else c = clrOrange;
  
  CreateLabel("SweepConf", 10, y_offset, text, 9, c);
  
  // Factor breakdown (compact)
  y_offset += 20;
  text = StringFormat("Vol:%d PA:%d Time:%d Ctx:%d",
                      (int)sweep.validation.volume_score,
                      (int)sweep.validation.price_action_score,
                      (int)sweep.validation.timing_score,
                      (int)sweep.validation.context_score);
  CreateLabel("SweepFactors", 10, y_offset, text, 8, clrSilver);
  
  // Top 3 factors
  y_offset += 15;
  int factors_shown = 0;
  for (int i = 0; i < ArraySize(sweep.validation.factors_list) && factors_shown < 3; i++) {
    CreateLabel(StringFormat("SweepFact%d", i), 10, y_offset, 
                "‚Ä¢ " + sweep.validation.factors_list[i], 7, clrGray);
    y_offset += 12;
    factors_shown++;
  }
}
```

---

## üìò –ß–ê–°–¢–¨ 2: –ù–ï–î–û–ü–ò–°–ê–ù–ù–´–ï –ú–û–î–£–õ–ò –ü–õ–ê–ù–ê

–í—ã —É–ø–æ–º—è–Ω—É–ª–∏ —á—Ç–æ **–ø–æ—Å–ª–µ–¥–Ω–∏–π –º–æ–¥—É–ª—å –Ω–∞–¥–æ –¥–æ—Ä–∞–±–æ—Ç–∞—Ç—å**. –ü—Ä–æ–≤–µ—Ä—è—é –≤–∞—à –ø–ª–∞–Ω...

### ‚ùå –ù–ê–ô–î–ï–ù–û: –ù–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ —Ä–∞–∑–¥–µ–ª—ã

#### 1. **Module 10: Dashboard** - –ù–µ–ø–æ–ª–Ω–∞—è —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è

**–ß—Ç–æ –µ—Å—Ç—å:**
```
‚îî‚îÄ MODULE 10: Dashboard.mqh
    ‚îú‚îÄ DrawDashboard()
    ‚îú‚îÄ UpdateRealtime()
    ‚îî‚îÄ ShowActiveSetups()
```

**–ß—Ç–æ –ù–ï–î–û–°–¢–ê–ï–¢:**

```cpp
//+------------------------------------------------------------------+
//| MODULE 10: Dashboard.mqh - –ü–û–õ–ù–ê–Ø –°–ü–ï–¶–ò–§–ò–ö–ê–¶–ò–Ø                   |
//+------------------------------------------------------------------+

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DASHBOARD LAYOUT (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/*
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë SMC MASTER DASHBOARD                    [EURUSD H1]   [‚ñà] [‚óã] [X] ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                    ‚ïë
‚ïë ‚îå‚îÄ TIME & SESSION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë ‚îÇ Broker Time:  10:35:42              GMT: 08:35:42            ‚îÇ ‚ïë
‚ïë ‚îÇ MSK Time:     11:35:42              DST: WINTER (GMT+2)      ‚îÇ ‚ïë
‚ïë ‚îÇ Session:      üü¢ LONDON PRIME       Confidence: 15%          ‚îÇ ‚ïë
‚ïë ‚îÇ Overlap:      ‚ö™ No (starts in 4h 25m)                       ‚îÇ ‚ïë
‚ïë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïë                                                                    ‚ïë
‚ïë ‚îå‚îÄ MARKET STRUCTURE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë ‚îÇ HTF Trend (H4):  üîµ BULLISH         Last BMS: 1.0875 (‚Üë)     ‚îÇ ‚ïë
‚ïë ‚îÇ LTF Trend (H1):  üîµ BULLISH         SMS Detected: No         ‚îÇ ‚ïë
‚ïë ‚îÇ Swings:          14 High / 13 Low                             ‚îÇ ‚ïë
‚ïë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïë                                                                    ‚ïë
‚ïë ‚îå‚îÄ LIQUIDITY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë ‚îÇ BSL Zones:  3 active    Nearest: PDH 1.0895 ‚ö†Ô∏è (swept 2x)    ‚îÇ ‚ïë
‚ïë ‚îÇ SSL Zones:  2 active    Nearest: Asian Low 1.0842 üü¢ (fresh) ‚îÇ ‚ïë
‚ïë ‚îÇ Equal Highs: 1 detected at 1.0888 (3 touches)                ‚îÇ ‚ïë
‚ïë ‚îÇ Recent Sweep: SSL @ 1.0845 (-8 pips, 2 bars ago) ‚úÖ          ‚îÇ ‚ïë
‚ïë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïë                                                                    ‚ïë
‚ïë ‚îå‚îÄ ASIAN RANGE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë ‚îÇ Range: 1.0848 - 1.0862 (14 pips)   Quality: ‚≠ê‚≠ê‚≠ê GOOD (72%) ‚îÇ ‚ïë
‚ïë ‚îÇ AMD Status: ‚è≥ MANIPULATION (broke high)                      ‚îÇ ‚ïë
‚ïë ‚îÇ Expected Direction: üîª DOWN (distribution pending)            ‚îÇ ‚ïë
‚ïë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïë                                                                    ‚ïë
‚ïë ‚îå‚îÄ ACTIVE SETUPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë ‚îÇ 1. üü¢ SH+BMS+RTO   SELL 1.0872   Conf: 87% ‚≠ê‚≠ê‚≠ê‚≠ê          ‚îÇ ‚ïë
‚ïë ‚îÇ    ‚îî‚îÄ Entry: 1.0870-1.0875  SL: 1.0882  TP: 1.0845           ‚îÇ ‚ïë
‚ïë ‚îÇ    ‚îî‚îÄ Factors: BMS(25%) SH(20%) OB(20%) Session(15%)         ‚îÇ ‚ïë
‚ïë ‚îÇ       OTE(4%) HTF(4%) ‚Üí TOTAL: 88%                            ‚îÇ ‚ïë
‚ïë ‚îÇ                                                                ‚îÇ ‚ïë
‚ïë ‚îÇ 2. üü° TURTLE SOUP  BUY 1.0845    Conf: 74% ‚≠ê‚≠ê‚≠ê            ‚îÇ ‚ïë
‚ïë ‚îÇ    ‚îî‚îÄ Entry: 1.0843-1.0847  SL: 1.0838  TP: 1.0865           ‚îÇ ‚ïë
‚ïë ‚îÇ    ‚îî‚îÄ Status: WAITING (price not in zone yet)                ‚îÇ ‚ïë
‚ïë ‚îÇ                                                                ‚îÇ ‚ïë
‚ïë ‚îÇ 3. ‚ö™ SMS+BMS+RTO  BUY 1.0855    Conf: 65% ‚≠ê‚≠ê (TOO LOW)    ‚îÇ ‚ïë
‚ïë ‚îÇ    ‚îî‚îÄ Not tradeable (min 70% required)                        ‚îÇ ‚ïë
‚ïë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïë                                                                    ‚ïë
‚ïë ‚îå‚îÄ STATISTICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚ïë
‚ïë ‚îÇ Calculation Time: 8.3ms   Memory: 2.4 MB   CPU: 3.2%         ‚îÇ ‚ïë
‚ïë ‚îÇ Bars Analyzed: 500        Setups Found: 3 (2 valid)           ‚îÇ ‚ïë
‚ïë ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚ïë
‚ïë                                                                    ‚ïë
‚ïë [v] Auto-Update (1s)  [v] Show Levels  [ ] Alerts  [Save Setup] ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
*/

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// –ü–û–õ–ù–´–ô –ö–û–î DASHBOARD
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class CDashboard {
private:
  // Layout constants
  const int PANEL_X = 10;
  const int PANEL_Y = 20;
  const int PANEL_WIDTH = 600;
  const int PANEL_HEIGHT = 650;
  const color PANEL_BG = C'25,25,35';
  const color PANEL_BORDER = C'60,60,80';
  
  // Section positions
  int m_section_y;
  
  // Performance tracking
  datetime m_last_update;
  datetime m_last_full_redraw;
  
public:
  //+----------------------------------------------------------------+
  //| Constructor                                                     |
  //+----------------------------------------------------------------+
  CDashboard() {
    m_last_update = 0;
    m_last_full_redraw = 0;
    m_section_y = PANEL_Y + 35;
  }
  
  //+----------------------------------------------------------------+
  //| Main draw function                                              |
  //+----------------------------------------------------------------+
  void Draw() {
    // Full redraw only every 5 seconds (optimization)
    datetime now = TimeCurrent();
    if (now - m_last_full_redraw < 5) {
      UpdateRealtimeOnly();
      return;
    }
    
    // Clear old objects
    ObjectsDeleteAll(0, "SMC_DASH_");
    
    // Draw background panel
    DrawPanel();
    
    // Draw sections
    m_section_y = PANEL_Y + 35;
    DrawTimeSection();
    DrawStructureSection();
    DrawLiquiditySection();
    DrawAsianRangeSection();
    DrawSetupsSection();
    DrawStatsSection();
    DrawControls();
    
    m_last_full_redraw = now;
  }
  
  //+----------------------------------------------------------------+
  //| Update only time-sensitive data (every second)                 |
  //+----------------------------------------------------------------+
  void UpdateRealtimeOnly() {
    // Update —Ç–æ–ª—å–∫–æ Time section –∏ Active Setups status
    UpdateTimeLabels();
    UpdateSetupStatus();
    
    m_last_update = TimeCurrent();
  }
  
private:
  //+----------------------------------------------------------------+
  //| Draw background panel                                           |
  //+----------------------------------------------------------------+
  void DrawPanel() {
    // Main background
    CreateRectangle("SMC_DASH_BG", PANEL_X, PANEL_Y, 
                    PANEL_X + PANEL_WIDTH, PANEL_Y + PANEL_HEIGHT,
                    PANEL_BG, PANEL_BORDER);
    
    // Title bar
    CreateRectangle("SMC_DASH_TITLE_BG", PANEL_X, PANEL_Y,
                    PANEL_X + PANEL_WIDTH, PANEL_Y + 30,
                    C'40,40,55', PANEL_BORDER);
    
    // Title text
    string title = StringFormat("SMC MASTER DASHBOARD - %s %s", 
                                Symbol(), 
                                EnumToString(Period()));
    CreateLabel("SMC_DASH_TITLE", PANEL_X + 10, PANEL_Y + 8,
                title, 10, clrWhite, "Arial Bold");
    
    // Close button
    CreateButton("SMC_DASH_CLOSE", PANEL_X + PANEL_WIDTH - 25, PANEL_Y + 5,
                 20, 20, "X", 9, clrWhite, C'180,50,50');
  }
  
  //+----------------------------------------------------------------+
  //| SECTION 1: Time & Session                                       |
  //+----------------------------------------------------------------+
  void DrawTimeSection() {
    int y = m_section_y;
    
    // Section title
    CreateLabel("SMC_DASH_TIME_TITLE", PANEL_X + 15, y,
                "‚è∞ TIME & SESSION", 9, C'150,200,255', "Arial Bold");
    y += 20;
    
    // Draw section box
    CreateRectangle("SMC_DASH_TIME_BOX", PANEL_X + 10, y,
                    PANEL_X + PANEL_WIDTH - 10, y + 80,
                    C'30,30,40', C'50,50,60');
    y += 10;
    
    // Get time data
    datetime broker_time = TimeCurrent();
    datetime gmt_time = ConvertToGMT(broker_time);
    datetime msk_time = GetCurrentMSKTime();
    SessionInfo session = GetCurrentSession();
    
    // Broker time
    string broker_str = TimeToString(broker_time, TIME_DATE|TIME_SECONDS);
    CreateLabel("SMC_DASH_BROKER_TIME", PANEL_X + 20, y,
                "Broker Time: " + broker_str, 8, clrWhite);
    
    // GMT time
    string gmt_str = TimeToString(gmt_time, TIME_SECONDS);
    CreateLabel("SMC_DASH_GMT_TIME", PANEL_X + 280, y,
                "GMT: " + gmt_str, 8, clrSilver);
    y += 18;
    
    // MSK time
    string msk_str = TimeToString(msk_time, TIME_SECONDS);
    CreateLabel("SMC_DASH_MSK_TIME", PANEL_X + 20, y,
                "MSK Time: " + msk_str, 8, clrWhite);
    
    // DST status
    bool dst = IsDSTActiveEU(broker_time);
    string dst_str = dst ? "SUMMER (GMT+3)" : "WINTER (GMT+2)";
    CreateLabel("SMC_DASH_DST", PANEL_X + 280, y,
                "DST: " + dst_str, 8, clrSilver);
    y += 18;
    
    // Current session
    color session_color = GetSessionColor(session.type);
    string session_icon = GetSessionIcon(session.type);
    CreateLabel("SMC_DASH_SESSION", PANEL_X + 20, y,
                "Session: " + session_icon + " " + GetSessionName(session.type),
                8, session_color);
    
    // Confluence weight
    CreateLabel("SMC_DASH_SESSION_CONF", PANEL_X + 280, y,
                StringFormat("Weight: %.0f%%", session.confluence_weight),
                8, clrSilver);
    y += 18;
    
    // Overlap status
    bool is_overlap = (session.type == SESSION_LONDON_NY_OVERLAP);
    string overlap_text = is_overlap ? "üü¢ ACTIVE" : "‚ö™ No";
    
    if (!is_overlap) {
      // Calculate time until overlap
      int hours_until = CalculateHoursUntilOverlap();
      if (hours_until > 0 && hours_until < 12) {
        overlap_text += StringFormat(" (starts in %dh)", hours_until);
      }
    }
    
    CreateLabel("SMC_DASH_OVERLAP", PANEL_X + 20, y,
                "Overlap: " + overlap_text, 8, is_overlap ? clrLimeGreen : clrGray);
    
    m_section_y = y + 30;
  }
  
  //+----------------------------------------------------------------+
  //| SECTION 2: Market Structure                                     |
  //+----------------------------------------------------------------+
  void DrawStructureSection() {
    int y = m_section_y;
    
    CreateLabel("SMC_DASH_STRUCT_TITLE", PANEL_X + 15, y,
                "üìä MARKET STRUCTURE", 9, C'150,200,255', "Arial Bold");
    y += 20;
    
    CreateRectangle("SMC_DASH_STRUCT_BOX", PANEL_X + 10, y,
                    PANEL_X + PANEL_WIDTH - 10, y + 70,
                    C'30,30,40', C'50,50,60');
    y += 10;
    
    // HTF Trend
    ENUM_TREND_DIRECTION htf_trend = MarketStructure.GetHTFTrend(PERIOD_H4);
    string htf_icon = (htf_trend == TREND_BULLISH) ? "üîµ" : 
                      (htf_trend == TREND_BEARISH) ? "üî¥" : "‚ö™";
    color htf_color = (htf_trend == TREND_BULLISH) ? clrDodgerBlue :
                      (htf_trend == TREND_BEARISH) ? clrRed : clrGray;
    
    CreateLabel("SMC_DASH_HTF_TREND", PANEL_X + 20, y,
                "HTF Trend (H4): " + htf_icon + " " + EnumToString(htf_trend),
                8, htf_color);
    
    // Last BMS
    BMS last_bms = MarketStructure.GetLastBMS();
    string bms_str = StringFormat("Last BMS: %.5f (%s)",
                                  last_bms.price,
                                  last_bms.type == BMS_BULLISH ? "‚Üë" : "‚Üì");
    CreateLabel("SMC_DASH_LAST_BMS", PANEL_X + 280, y, bms_str, 8, clrSilver);
    y += 18;
    
    // LTF Trend
    ENUM_TREND_DIRECTION ltf_trend = MarketStructure.GetHTFTrend(PERIOD_H1);
    string ltf_icon = (ltf_trend == TREND_BULLISH) ? "üîµ" :
                      (ltf_trend == TREND_BEARISH) ? "üî¥" : "‚ö™";
    color ltf_color = (ltf_trend == TREND_BULLISH) ? clrDodgerBlue :
                      (ltf_trend == TREND_BEARISH) ? clrRed : clrGray;
    
    CreateLabel("SMC_DASH_LTF_TREND", PANEL_X + 20, y,
                "LTF Trend (H1): " + ltf_icon + " " + EnumToString(ltf_trend),
                8, ltf_color);
    
    // SMS Detection
    bool sms_detected = (MarketStructure.GetLastSMS() != NULL);
    CreateLabel("SMC_DASH_SMS", PANEL_X + 280, y,
                "SMS: " + (sms_detected ? "Yes ‚ö†Ô∏è" : "No"),
                8, sms_detected ? clrYellow : clrSilver);
    y += 18;
    
    // Swing count
    int swing_highs = MarketStructure.GetSwingCount(SWING_HIGH);
    int swing_lows = MarketStructure.GetSwingCount(SWING_LOW);
    CreateLabel("SMC_DASH_SWINGS", PANEL_X + 20, y,
                StringFormat("Swings: %d High / %d Low", swing_highs, swing_lows),
                8, clrSilver);
    
    m_section_y = y + 30;
  }
  
  //+----------------------------------------------------------------+
  //| SECTION 3: Liquidity                                            |
  //+----------------------------------------------------------------+
  void DrawLiquiditySection() {
    int y = m_section_y;
    
    CreateLabel("SMC_DASH_LIQ_TITLE", PANEL_X + 15, y,
                "üíß LIQUIDITY", 9, C'150,200,255', "Arial Bold");
    y += 20;
    
    CreateRectangle("SMC_DASH_LIQ_BOX", PANEL_X + 10, y,
                    PANEL_X + PANEL_WIDTH - 10, y + 90,
                    C'30,30,40', C'50,50,60');
    y += 10;
    
    // BSL Zones
    LiquidityZone[] bsl_zones = Liquidity.GetActiveBSL();
    LiquidityZone nearest_bsl = Liquidity.GetNearestBSL();
    
    string bsl_text = StringFormat("BSL Zones: %d active", ArraySize(bsl_zones));
    CreateLabel("SMC_DASH_BSL_COUNT", PANEL_X + 20, y, bsl_text, 8, clrWhite);
    
    if (nearest_bsl.price > 0) {
      string bsl_detail = StringFormat("Nearest: %s %.5f",
                                        nearest_bsl.name,
                                        nearest_bsl.price);
      if (nearest_bsl.swept) {
        bsl_detail += " ‚ö†Ô∏è (swept)";
      } else {
        bsl_detail += " üü¢ (fresh)";
      }
      CreateLabel("SMC_DASH_BSL_NEAREST", PANEL_X + 280, y, bsl_detail, 8, clrSilver);
    }
    y += 18;
    
    // SSL Zones
    LiquidityZone[] ssl_zones = Liquidity.GetActiveSSL();
    LiquidityZone nearest_ssl = Liquidity.GetNearestSSL();
    
    string ssl_text = StringFormat("SSL Zones: %d active", ArraySize(ssl_zones));
    CreateLabel("SMC_DASH_SSL_COUNT", PANEL_X + 20, y, ssl_text, 8, clrWhite);
    
    if (nearest_ssl.price > 0) {
      string ssl_detail = StringFormat("Nearest: %s %.5f",
                                        nearest_ssl.name,
                                        nearest_ssl.price);
      if (nearest_ssl.swept) {
        ssl_detail += " ‚ö†Ô∏è (swept)";
      } else {
        ssl_detail += " üü¢ (fresh)";
      }
      CreateLabel("SMC_DASH_SSL_NEAREST", PANEL_X + 280, y, ssl_detail, 8, clrSilver);
    }
    y += 18;
    
    // Equal Highs/Lows
    EqualZone[] equal_zones = Liquidity.GetEqualZones();
    if (ArraySize(equal_zones) > 0) {
      string equal_text = StringFormat("Equal Highs: %d detected at %.5f (%d touches)",
                                       ArraySize(equal_zones),
                                       equal_zones[0].price,
                                       equal_zones[0].count);
      CreateLabel("SMC_DASH_EQUAL", PANEL_X + 20, y, equal_text, 8, clrYellow);
    } else {
      CreateLabel("SMC_DASH_EQUAL", PANEL_X + 20, y,
                  "Equal Highs: None detected", 8, clrGray);
    }
    y += 18;
    
    // Recent Sweep
    SweepData recent_sweep = Liquidity.GetMostRecentSweep();
    if (recent_sweep.valid) {
      int bars_ago = iBarShift(Symbol(), PERIOD_CURRENT, TimeCurrent()) -
                     iBarShift(Symbol(), PERIOD_CURRENT, recent_sweep.time);
      
      string sweep_text = StringFormat("Recent Sweep: %s @ %.5f (%.0f pips, %d bars ago) %s",
                                        recent_sweep.type == LIQUIDITY_SSL ? "SSL" : "BSL",
                                        recent_sweep.zone_price,
                                        recent_sweep.distance_pips,
                                        bars_ago,
                                        recent_sweep.validation.confidence_score >= 80 ? "‚úÖ" : "‚ö†Ô∏è");
      
      color sweep_color = recent_sweep.validation.confidence_score >= 80 ? clrLimeGreen : clrOrange;
      CreateLabel("SMC_DASH_RECENT_SWEEP", PANEL_X + 20, y, sweep_text, 8, sweep_color);
    } else {
      CreateLabel("SMC_DASH_RECENT_SWEEP", PANEL_X + 20, y,
                  "Recent Sweep: None", 8, clrGray);
    }
    
    m_section_y = y + 30;
  }
  
  //+----------------------------------------------------------------+
  //| SECTION 4: Asian Range & AMD                                    |
  //+----------------------------------------------------------------+
  void DrawAsianRangeSection() {
    int y = m_section_y;
    
    CreateLabel("SMC_DASH_ASIAN_TITLE", PANEL_X + 15, y,
                "üåè ASIAN RANGE & AMD", 9, C'150,200,255', "Arial Bold");
    y += 20;
    
    CreateRectangle("SMC_DASH_ASIAN_BOX", PANEL_X + 10, y,
                    PANEL_X + PANEL_WIDTH - 10, y + 70,
                    C'30,30,40', C'50,50,60');
    y += 10;
    
    AsianRange asian = GetAsianRange(GetCurrentMSKTime());
    
    if (asian.valid && asian.IsValid()) {
      // Range info
      string range_text = StringFormat("Range: %.5f - %.5f (%.0f pips)",
                                        asian.low, asian.high, asian.size_pips);
      CreateLabel("SMC_DASH_ASIAN_RANGE", PANEL_X + 20, y, range_text, 8, clrWhite);
      
      // Quality rating
      string quality_stars = "";
      int stars = (int)(asian.quality_score / 20);
      for (int i = 0; i < stars; i++) quality_stars += "‚≠ê";
      
      string quality_text = StringFormat("Quality: %s %s (%d%%)",
                                          quality_stars,
                                          asian.GetQualityText(),
                                          asian.quality_score);
      CreateLabel("SMC_DASH_ASIAN_QUALITY", PANEL_X + 280, y, quality_text, 8, clrGold);
      y += 18;
      
      // AMD Status
      AMD_Pattern amd = DetectAMD(asian, GetCurrentSession());
      
      if (amd.manipulation_confirmed) {
        string amd_status = "‚è≥ MANIPULATION (broke " + 
                           (amd.manipulation_direction == AMD_UP ? "high)" : "low)");
        CreateLabel("SMC_DASH_AMD_STATUS", PANEL_X + 20, y, 
                    "AMD Status: " + amd_status, 8, clrYellow);
        y += 18;
        
        // Expected direction
        string exp_dir = amd.expected_distribution_direction == AMD_DOWN ? "üîª DOWN" : "üî∫ UP";
        CreateLabel("SMC_DASH_AMD_EXP", PANEL_X + 20, y,
                    "Expected Direction: " + exp_dir + " (distribution pending)",
                    8, clrOrange);
      } else if (amd.valid) {
        CreateLabel("SMC_DASH_AMD_STATUS", PANEL_X + 20, y,
                    "AMD Status: ‚úÖ COMPLETE (distribution confirmed)",
                    8, clrLimeGreen);
      } else {
        CreateLabel("SMC_DASH_AMD_STATUS", PANEL_X + 20, y,
                    "AMD Status: ‚ö™ Accumulation only",
                    8, clrGray);
      }
      
    } else {
      CreateLabel("SMC_DASH_ASIAN_RANGE", PANEL_X + 20, y,
                  asian.valid ? "Range: Not yet completed or low quality" : "Range: Not available",
                  8, clrGray);
    }
    
    m_section_y = y + 30;
  }
  
  //+----------------------------------------------------------------+
  //| SECTION 5: Active Setups (–°–ê–ú–ê–Ø –í–ê–ñ–ù–ê–Ø!)                        |
  //+----------------------------------------------------------------+
  void DrawSetupsSection() {
    int y = m_section_y;
    
    CreateLabel("SMC_DASH_SETUPS_TITLE", PANEL_X + 15, y,
                "üéØ ACTIVE SETUPS", 9, C'150,200,255', "Arial Bold");
    y += 20;
    
    // Get all valid setups sorted by confluence
    Setup[] setups = SetupScanner.GetAllSetups();
    Setup[] sorted =
–¢–æ–ª—å–∫–æ —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω , –∏ –Ω–µ –ø—Ä–æ–ø—É—Å–∫–∞–π –Ω–µ –æ–¥–Ω–æ–π –¥–µ—Ç–∞–ª–∏ –∏ —Å–∞–º–æ–µ –≥–ª–∞–≤–Ω–æ–µ –∏—Å–ø—Ä–∞–≤—å –æ—à–∏–±–∫–∏.  –†–∞–∑—Ä–µ—à–∞—é –∑–∞–ø—Ä–æ—Å–∏—Ç—å —Ä–∞–∑–±–∏–≤ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —á–∞—Å—Ç–µ–π , –ø–æ—Å—á–∏—Ç–∞–π –∫–∞–∫ —Ç–µ–±–µ —É–¥–æ–±–Ω–æ –±—É–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ–±—ä—ë–º —Ç–∞–∫–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ 

–ò –ø—Ä–æ–ø–∏—à–∏ —á—Ç–æ —ç—Ç–æ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ª–µ–π–±–ª—ã –∏ —Å–∏–≥–Ω–∞–ª—ã –Ω–∞ dashboard —Å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏ long , short. –ø—Ä–æ–≤–µ—Ä—å –≤–æ–æ–±—â–µ –≤ —Ü–µ–ª–æ–º –Ω–µ—Ç –ª–∏ –ø—Ä–æ–±–ª–µ–º —Å –ø–æ–Ω–∏–º–∞–Ω–∏–µ–º –∫ —á–µ–º—É –≤–µ–¥—É—Ç —Ä–∞–∑–Ω—ã–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è , –µ—Å–ª–∏ —á—Ç–æ –æ–±—Ä–∞—â–∞–π—Å—è –∫ PDF —Ñ–∞–π–ª—É –ø—Ä–∏ –ù–∞–¥–æ–±–Ω–æ—Å—Ç–∏

CONFIDENCE LEVELS:
‚îú‚îÄ 90-100%  ‚Üí VERY HIGH  ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (Bank sweep almost certain)
‚îú‚îÄ 80-89%   ‚Üí HIGH       ‚≠ê‚≠ê‚≠ê‚≠ê   (Strong probability)
‚îú‚îÄ 70-79%   ‚Üí MEDIUM     ‚≠ê‚≠ê‚≠ê     (Tradeable with caution)
‚îú‚îÄ 60-69%   ‚Üí LOW        ‚≠ê‚≠ê       (Only during news/overlap)
‚îî‚îÄ < 60%    ‚Üí VERY LOW   ‚≠ê         (Skip this setup)—Ö
# üéØ –§–ò–ù–ê–õ–¨–ù–´–ô –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ü–õ–ê–ù SMC –ò–ù–î–ò–ö–ê–¢–û–†–ê

**–í–µ—Ä—Å–∏—è:** 3.0 FINAL  
**–î–∞—Ç–∞:** 17 –Ω–æ—è–±—Ä—è 2025  
**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ì–æ—Ç–æ–≤ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ (–≤—Å–µ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã)

---

## ‚ö†Ô∏è –í–ê–ñ–ù–û–ï –û–ë–™–Ø–í–õ–ï–ù–ò–ï –û –†–ê–ó–ë–ò–í–ö–ï

–ò–∑-–∑–∞ –±–æ–ª—å—à–æ–≥–æ –æ–±—ä–µ–º–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ (–∞—É–¥–∏—Ç + –ø–ª–∞–Ω + –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è + volume check), —è —Ä–∞–∑–æ–±—å—é —Ñ–∏–Ω–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω –Ω–∞ **4 –ß–ê–°–¢–ò**:

**–ß–ê–°–¢–¨ 1:** –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è + –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ ‚úÖ (—Ç–µ–∫—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ)  
**–ß–ê–°–¢–¨ 2:** –ú–æ–¥—É–ª–∏ 0-2 (Time, Structure, Sessions, Liquidity)  
**–ß–ê–°–¢–¨ 3:** –ú–æ–¥—É–ª–∏ 3-6 (Order Blocks, Fibonacci, Setups, Confluence)  
**–ß–ê–°–¢–¨ 4:** Dashboard + Volume Check Integration + –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

–ö–∞–∂–¥–∞—è —á–∞—Å—Ç—å –±—É–¥–µ—Ç —Å–∞–º–æ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–π –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏.

---

## üìã –ß–ê–°–¢–¨ 1: –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –ò –ê–†–•–ò–¢–ï–ö–¢–£–†–ê

### üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø (–û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´ –ö –ü–†–ò–ú–ï–ù–ï–ù–ò–Æ)

#### 1. **Session Timing** - –ò–°–ü–†–ê–í–õ–ï–ù–û

**‚ùå –ë—ã–ª–æ:** –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ MSK —á–∞—Å—ã (10:00-13:00 –¥–ª—è London)  
**‚úÖ –°—Ç–∞–ª–æ:** GMT-based detection —Å –∞–≤—Ç–æ-DST

```cpp
// –ü–†–ê–í–ò–õ–¨–ù–´–ô —Ä–∞—Å—á–µ—Ç —Å–µ—Å—Å–∏–π (–≤ GMT, –Ω–µ MSK!)
SessionInfo GetCurrentSession() {
  datetime server_time = TimeCurrent();
  int broker_offset = BrokerTimeDetector.GetBrokerGMTOffset(); // 2 –∏–ª–∏ 3
  datetime gmt_time = server_time - (broker_offset * 3600);
  
  MqlDateTime dt_gmt;
  TimeToStruct(gmt_time, dt_gmt);
  int gmt_hour = dt_gmt.hour;
  
  SessionInfo info;
  
  // Asian: 00:00-08:00 GMT
  if (gmt_hour >= 0 && gmt_hour < 8) {
    info.type = SESSION_ASIAN;
    info.importance = OBSERVATION_ONLY;
    info.confluence_weight = 0.0;
    return info;
  }
  
  // London Prime: 08:00-11:00 GMT (–ø–µ—Ä–≤—ã–µ 3 —á–∞—Å–∞)
  if (gmt_hour >= 8 && gmt_hour < 11) {
    info.type = SESSION_LONDON_PRIME;
    info.importance = HIGH;
    info.confluence_weight = 15.0;
    return info;
  }
  
  // London Late: 11:00-16:00 GMT
  if (gmt_hour >= 11 && gmt_hour < 16) {
    info.type = SESSION_LONDON_LATE;
    info.importance = MEDIUM;
    info.confluence_weight = 8.0;
    return info;
  }
  
  // –ö–†–ò–¢–ò–ß–ù–û: London-NY Overlap: 13:00-16:00 GMT
  if (gmt_hour >= 13 && gmt_hour < 16) {
    info.type = SESSION_LONDON_NY_OVERLAP;
    info.importance = MAXIMUM;
    info.confluence_weight = 20.0; // –ú–ê–ö–°–ò–ú–£–ú!
    return info;
  }
  
  // NY Prime: 16:00-19:00 GMT
  if (gmt_hour >= 16 && gmt_hour < 19) {
    info.type = SESSION_NY_PRIME;
    info.importance = HIGH;
    info.confluence_weight = 15.0;
    return info;
  }
  
  // NY Late: 19:00-21:00 GMT
  if (gmt_hour >= 19 && gmt_hour < 21) {
    info.type = SESSION_NY_LATE;
    info.importance = LOW;
    info.confluence_weight = 5.0;
    return info;
  }
  
  // Dead Zone: 21:00-00:00 GMT
  info.type = SESSION_DEAD_ZONE;
  info.importance = NONE;
  info.confluence_weight = -20.0; // –®–¢–†–ê–§!
  return info;
}
```

**–¢–∞–±–ª–∏—Ü–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è):**
```
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë GMT HOUR ‚îÇ SESSION            ‚îÇ Broker Winter ‚îÇ Broker Summer ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë 08:00    ‚îÇ London Prime START ‚îÇ 10:00         ‚îÇ 11:00         ‚ïë
‚ïë 11:00    ‚îÇ London Late START  ‚îÇ 13:00         ‚îÇ 14:00         ‚ïë
‚ïë 13:00    ‚îÇ OVERLAP START ‚≠ê   ‚îÇ 15:00         ‚îÇ 16:00         ‚ïë
‚ïë 16:00    ‚îÇ NY Prime START     ‚îÇ 18:00         ‚îÇ 19:00         ‚ïë
‚ïë 21:00    ‚îÇ Dead Zone START    ‚îÇ 23:00         ‚îÇ 00:00         ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

---

#### 2. **AMD Pattern Direction** - –ò–°–ü–†–ê–í–õ–ï–ù–û

**‚ùå –ë—ã–ª–æ:** Manipulation –∏ Distribution –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏  
**‚úÖ –°—Ç–∞–ª–æ:** Distribution –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–ê Manipulation

```cpp
AMD_Pattern DetectAMD(AsianRange asian, SessionInfo session) {
  AMD_Pattern amd;
  amd.valid = false;
  
  // PHASE A: Accumulation (Asian Range)
  amd.accumulation_zone = asian;
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ breakout –æ—Ç Asian Range
  double current_high = iHigh(Symbol(), PERIOD_CURRENT, 0);
  double current_low = iLow(Symbol(), PERIOD_CURRENT, 0);
  
  bool broke_above = (current_high > asian.high);
  bool broke_below = (current_low < asian.low);
  
  // PHASE M: Manipulation
  if (broke_above) {
    amd.manipulation_direction = AMD_UP;
    amd.manipulation_price = current_high;
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å BSL sweep
    LiquidityZone[] bsl = Liquidity.FindBSLAbove(asian.high);
    if (ArraySize(bsl) > 0) {
      amd.swept_liquidity = bsl;
      amd.manipulation_confirmed = true;
    }
    
    // ‚úÖ –ö–†–ò–¢–ò–ß–ù–û: Distribution –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–ê!
    amd.expected_distribution_direction = AMD_DOWN;
    
  } else if (broke_below) {
    amd.manipulation_direction = AMD_DOWN;
    amd.manipulation_price = current_low;
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å SSL sweep
    LiquidityZone[] ssl = Liquidity.FindSSLBelow(asian.low);
    if (ArraySize(ssl) > 0) {
      amd.swept_liquidity = ssl;
      amd.manipulation_confirmed = true;
    }
    
    // ‚úÖ –ö–†–ò–¢–ò–ß–ù–û: Distribution –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–ê!
    amd.expected_distribution_direction = AMD_UP;
  }
  
  // PHASE D: Distribution (–ø—Ä–æ–≤–µ—Ä–∫–∞ BMS confirmation)
  if (amd.manipulation_confirmed) {
    BMS latest_bms = MarketStructure.DetectLatestBMS();
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ BMS –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ expected_distribution
    if (amd.expected_distribution_direction == AMD_DOWN) {
      if (latest_bms.type == BMS_BEARISH && latest_bms.price < asian.low) {
        amd.distribution_confirmed = true;
        amd.distribution_bms = latest_bms;
        amd.valid = true;
      }
    } else {
      if (latest_bms.type == BMS_BULLISH && latest_bms.price > asian.high) {
        amd.distribution_confirmed = true;
        amd.distribution_bms = latest_bms;
        amd.valid = true;
      }
    }
  }
  
  return amd;
}
```

**–í–∏–∑—É–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä (–¥–ª—è Dashboard):**
```
BEARISH AMD:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ A: Asian Range 1.0850-1.0862            ‚îÇ
‚îÇ M: Breakout UP to 1.0875 ‚¨ÜÔ∏è (BSL sweep)‚îÇ  ‚Üê –õ–æ–≤—É—à–∫–∞!
‚îÇ D: BMS DOWN, price goes to 1.0820 ‚¨áÔ∏è    ‚îÇ  ‚Üê –ò—Å—Ç–∏–Ω–∞!
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Signal: SELL (expected_distribution = DOWN)
```

---

#### 3. **Order Block Mitigation** - –î–û–ë–ê–í–õ–ï–ù–û

```cpp
struct OrderBlock {
  // ... existing fields
  
  // ‚úÖ –ù–û–í–û–ï: Mitigation tracking
  ENUM_OB_STATUS status;          // ACTIVE/MITIGATED_ONCE/TWICE/WEAK/VIOLATED
  int mitigation_count;           // 0, 1, 2, 3+
  datetime last_mitigation_time;
  double mitigation_prices[];     // –ò—Å—Ç–æ—Ä–∏—è –∫–∞—Å–∞–Ω–∏–π
  
  // Method –¥–ª—è confluence adjustment
  double GetConfluenceAdjustment() {
    if (mitigation_count == 0 || mitigation_count == 1) return 0.0;   // No penalty
    if (mitigation_count == 2) return -5.0;   // Second touch
    if (mitigation_count >= 3) return -15.0;  // Weak OB
    return 0.0;
  }
};

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ mitigation
MitigationResult CheckOrderBlockMitigation(OrderBlock &ob, double current_price, datetime current_time) {
  MitigationResult result;
  result.action = MITIGATION_NO_CHANGE;
  
  bool price_in_ob = false;
  bool violated = false;
  
  if (ob.type == OB_BULLISH) {
    price_in_ob = (current_price >= ob.low && current_price <= ob.high);
    violated = (current_price < ob.low); // –¶–µ–Ω–∞ —É—à–ª–∞ –Ω–∏–∂–µ OB
  } else {
    price_in_ob = (current_price >= ob.low && current_price <= ob.high);
    violated = (current_price > ob.high); // –¶–µ–Ω–∞ —É—à–ª–∞ –≤—ã—à–µ OB
  }
  
  // –°–ª—É—á–∞–π 1: VIOLATION (OB –±–æ–ª—å—à–µ –Ω–µ –≤–∞–ª–∏–¥–µ–Ω)
  if (violated) {
    ob.status = OB_VIOLATED;
    ob.mitigation_count = 999;
    result.action = MITIGATION_INVALIDATED;
    result.confluence_adjustment = -100.0; // –ü–æ–ª–Ω–∞—è –∏–Ω–≤–∞–ª–∏–¥–∞—Ü–∏—è
    return result;
  }
  
  // –°–ª—É—á–∞–π 2: Price –≤ OB –∑–æ–Ω–µ
  if (price_in_ob) {
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —ç—Ç–æ –Ω–æ–≤–æ–µ –∫–∞—Å–∞–Ω–∏–µ (–Ω–µ –¥—É–±–ª–∏—Ä—É—é—â–µ–µ)
    int time_since_last = (int)(current_time - ob.last_mitigation_time);
    if (time_since_last < 300) { // 5 –º–∏–Ω—É—Ç
      result.action = MITIGATION_SAME_TOUCH;
      return result;
    }
    
    // –ù–æ–≤–æ–µ –∫–∞—Å–∞–Ω–∏–µ
    ob.mitigation_count++;
    ob.last_mitigation_time = current_time;
    ArrayPush(ob.mitigation_prices, current_price);
    
    // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
    if (ob.mitigation_count == 1) {
      ob.status = OB_MITIGATED_ONCE;
      result.recommendation = "Good - first RTO";
    } else if (ob.mitigation_count == 2) {
      ob.status = OB_MITIGATED_TWICE;
      result.recommendation = "Acceptable - second RTO, use tighter SL";
    } else {
      ob.status = OB_WEAK;
      result.recommendation = "Risky - third RTO, not recommended";
    }
    
    result.action = MITIGATION_TOUCHED;
    result.confluence_adjustment = ob.GetConfluenceAdjustment();
    
    return result;
  }
  
  return result; // No change
}
```

---

#### 4. **Confluence Weights** - –ò–°–ü–†–ê–í–õ–ï–ù–û –î–û 100%

```cpp
// ‚úÖ –§–ò–ù–ê–õ–¨–ù–´–ï –í–ï–°–ê (—Å—É–º–º–∞ = 100%)

–ë–ê–ó–û–í–´–ï –§–ê–ö–¢–û–†–´ (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ):
‚îú‚îÄ BMS                     25%  (–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)
‚îú‚îÄ Stop Hunt –ò–õ–ò SMS       20%  (–û–¥–Ω–æ –∏–∑ –¥–≤—É—Ö –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)
‚îú‚îÄ RTO to Order Block      20%  (–û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)
‚îî‚îÄ Session Timing          15%  (–∏–ª–∏ 20% –¥–ª—è Overlap)
                          ‚îÄ‚îÄ‚îÄ‚îÄ
                           80%  (Minimum –¥–ª—è –≤–∞–ª–∏–¥–Ω–æ–≥–æ setup)

–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –§–ê–ö–¢–û–†–´ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ):
‚îú‚îÄ Fibonacci OTE           4%
‚îú‚îÄ HTF Trend Alignment     4%
‚îú‚îÄ High Impact News        4%
‚îú‚îÄ AMD Pattern             4%
‚îî‚îÄ HTF Order Block         4%
                          ‚îÄ‚îÄ‚îÄ‚îÄ
                           20%

ADJUSTMENTS (–º–æ–≥—É—Ç –±—ã—Ç—å –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º–∏):
‚îú‚îÄ OB Mitigation: 0%, -5%, -15%
‚îú‚îÄ Sweep Validity: +5%, 0%, -10%
‚îî‚îÄ Session Penalty: -20% (Dead Zone)

–ò–¢–û–ì–û: MAX 100% ‚úÖ
```

**–ö–æ–¥ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:**

```cpp
ConfluenceData CalculateConfluence(Setup setup, SessionInfo session, OrderBlock ob, SweepData sweep) {
  ConfluenceData conf;
  conf.total_score = 0;
  ArrayResize(conf.factors_list, 0);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–í–ï–†–ö–ò
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  if (!setup.has_bms) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No BMS";
    return conf;
  }
  
  if (!setup.has_stop_hunt && !setup.has_sms) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No SH or SMS";
    return conf;
  }
  
  if (!setup.has_order_block) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No OB";
    return conf;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // –ë–ê–ó–û–í–´–ï –§–ê–ö–¢–û–†–´ (80%)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  // BMS (25%)
  conf.total_score += 25.0;
  ArrayPush(conf.factors_list, "‚úÖ BMS confirmed (25%)");
  
  // Stop Hunt OR SMS (20%)
  if (setup.has_stop_hunt) {
    conf.total_score += 20.0;
    ArrayPush(conf.factors_list, "‚úÖ Stop Hunt (20%)");
    
    // Adjustment –∑–∞ sweep validity
    if (sweep.validation.confidence_score >= 80) {
      conf.total_score += 5.0;
      ArrayPush(conf.factors_list, "  ‚îî‚îÄ Strong sweep +5%");
    } else if (sweep.validation.confidence_score < 60) {
      conf.total_score -= 10.0;
      ArrayPush(conf.factors_list, "  ‚îî‚îÄ Weak sweep -10%");
    }
  } else if (setup.has_sms) {
    conf.total_score += 20.0;
    ArrayPush(conf.factors_list, "‚úÖ SMS Failure Swing (20%)");
  }
  
  // RTO to Order Block (20%)
  conf.total_score += 20.0;
  ArrayPush(conf.factors_list, "‚úÖ RTO to Order Block (20%)");
  
  // OB Mitigation Adjustment
  if (ob.mitigation_count > 0) {
    double adj = ob.GetConfluenceAdjustment();
    if (adj != 0) {
      conf.total_score += adj;
      ArrayPush(conf.factors_list, StringFormat("  ‚îî‚îÄ OB used %dx (%.0f%%)", 
                                                 ob.mitigation_count, adj));
    }
  }
  
  // Session (15% or 20%)
  double session_weight = 15.0;
  
  if (session.type == SESSION_LONDON_NY_OVERLAP) {
    session_weight = 20.0; // –ë–û–ù–£–°!
    ArrayPush(conf.factors_list, "‚úÖ London-NY Overlap (20%)");
  } else if (session.type == SESSION_LONDON_PRIME || session.type == SESSION_NY_PRIME) {
    ArrayPush(conf.factors_list, "‚úÖ Prime session (15%)");
  } else if (session.type == SESSION_LONDON_LATE || session.type == SESSION_NY_LATE) {
    session_weight = 8.0;
    ArrayPush(conf.factors_list, "‚ö†Ô∏è Late session (8%)");
  } else if (session.type == SESSION_DEAD_ZONE) {
    // –ö–†–ò–¢–ò–ß–ù–û: Dead Zone = auto-reject
    conf.total_score = 0;
    conf.quality_rating = "INVALID - Dead Zone";
    return conf;
  }
  
  conf.total_score += session_weight;
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –§–ê–ö–¢–û–†–´ (20%)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  if (setup.in_fibonacci_ote) {
    conf.total_score += 4.0;
    ArrayPush(conf.factors_list, "üíé Fibonacci OTE (4%)");
  }
  
  if (setup.htf_aligned) {
    conf.total_score += 4.0;
    ArrayPush(conf.factors_list, "üíé HTF alignment (4%)");
  }
  
  if (setup.high_impact_news) {
    conf.total_score += 4.0;
    ArrayPush(conf.factors_list, "üíé High Impact News (4%)");
  }
  
  if (setup.amd_pattern) {
    conf.total_score += 4.0;
    ArrayPush(conf.factors_list, "üíé AMD Pattern (4%)");
  }
  
  if (setup.htf_order_block) {
    conf.total_score += 4.0;
    ArrayPush(conf.factors_list, "üíé HTF Order Block (4%)");
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // CAP & RATING
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  if (conf.total_score > 100) {
    conf.total_score = 100;
  }
  
  // Quality rating
  if (conf.total_score >= 95) {
    conf.quality_rating = "EXCELLENT ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 90) {
    conf.quality_rating = "EXCELLENT ‚≠ê‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 85) {
    conf.quality_rating = "VERY GOOD ‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 80) {
    conf.quality_rating = "GOOD ‚≠ê‚≠ê";
  } else if (conf.total_score >= 70) {
    conf.quality_rating = "ACCEPTABLE ‚≠ê";
  } else {
    conf.quality_rating = "POOR (Below threshold)";
  }
  
  return conf;
}
```

---

#### 5. **Equal Highs/Lows Threshold** - –ò–°–ü–†–ê–í–õ–ï–ù–û

**‚ùå –ë—ã–ª–æ:** 20 pips –¥–ª—è H4 Forex (—Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ)  
**‚úÖ –°—Ç–∞–ª–æ:** 10 pips –¥–ª—è H4 Forex (—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∏–º–µ—Ä–∞–º –∏–∑ PDF)

```cpp
double GetEqualThreshold(string symbol, ENUM_TIMEFRAMES tf) {
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  bool is_index = (StringFind(symbol, "NAS") >= 0 || 
                   StringFind(symbol, "US500") >= 0);
  
  double base_pips = 0;
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base_pips = 3; break;   // ‚úÖ 3 pips
      case PERIOD_M30: base_pips = 5; break;   // ‚úÖ 5 pips
      case PERIOD_H1:  base_pips = 7; break;   // ‚úÖ 7 pips
      case PERIOD_H4:  base_pips = 10; break;  // ‚úÖ 10 pips (–±—ã–ª–æ 20!)
      case PERIOD_D1:  base_pips = 20; break;  // ‚úÖ 20 pips
      default:         base_pips = 50; break;
    }
  } else if (is_gold) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base_pips = 30; break;  // ‚úÖ 30 cents
      case PERIOD_M30: base_pips = 50; break;  // ‚úÖ 50 cents
      case PERIOD_H1:  base_pips = 80; break;  // ‚úÖ 80 cents
      case PERIOD_H4:  base_pips = 120; break; // ‚úÖ 120 cents (–±—ã–ª–æ 200!)
      case PERIOD_D1:  base_pips = 250; break;
      default:         base_pips = 500; break;
    }
  } else if (is_index) {
    switch(tf) {
      case PERIOD_H4:  base_pips = 40; break;  // ‚úÖ 40 points (–±—ã–ª–æ 60!)
      // ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ
    }
  }
  
  return base_pips * SymbolInfoDouble(symbol, SYMBOL_POINT);
}
```

---

#### 6. **Volume Check –¥–ª—è Tick Volume** - –û–ö–û–ù–ß–ê–¢–ï–õ–¨–ù–û–ï –†–ï–®–ï–ù–ò–ï

**–ö–æ–Ω—Å–µ–Ω—Å—É—Å —ç–∫—Å–ø–µ—Ä—Ç–æ–≤:** Multi-factor scoring (Volume + Price Action + Timing + Context)

```cpp
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VOLUME PROFILE DETECTION (OnInit)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

struct VolumeProfile {
  enum TYPE { REAL, TICK, UNAVAILABLE };
  TYPE type;
  bool available;
  bool reliable;
  double avg_volume;
  double std_dev;
  double cv;  // Coefficient of variation
  string note;
};

VolumeProfile g_volume_profile;  // Global

VolumeProfile DetectVolumeProfile() {
  VolumeProfile profile;
  
  long vol = iVolume(Symbol(), Period(), 0);
  if (vol <= 0) {
    profile.type = VolumeProfile::UNAVAILABLE;
    profile.available = false;
    profile.reliable = false;
    profile.note = "No volume data";
    return profile;
  }
  
  // Distinguish Real vs Tick
  int small_vol_count = 0;
  for (int i = 0; i < 100; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0 && v < 10) small_vol_count++;
  }
  
  profile.type = (small_vol_count > 50) ? VolumeProfile::TICK : VolumeProfile::REAL;
  
  // Calculate statistics
  double sum = 0, sum_sq = 0;
  int count = 0;
  for (int i = 0; i < 100; i++) {
    long v = iVolume(Symbol(), Period(), i);
    if (v > 0) {
      double vd = (double)v;
      sum += vd;
      sum_sq += vd * vd;
      count++;
    }
  }
  
  profile.avg_volume = sum / count;
  double variance = (sum_sq / count) - (profile.avg_volume * profile.avg_volume);
  profile.std_dev = MathSqrt(variance);
  profile.cv = profile.std_dev / profile.avg_volume;
  
  // Reliability check
  if (profile.cv < 0.3) {
    profile.reliable = false;
    profile.note = "Low variance - unreliable";
  } else {
    profile.available = true;
    profile.reliable = true;
    profile.note = StringFormat("%s volume OK (CV=%.2f)", 
                                 profile.type == VolumeProfile::TICK ? "TICK" : "REAL",
                                 profile.cv);
  }
  
  return profile;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MULTI-FACTOR SWEEP VALIDATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

struct SweepValidation {
  bool valid;
  double confidence_score;  // 0-100
  
  // Factor breakdown
  double volume_score;       // 0-30
  double price_action_score; // 0-30
  double timing_score;       // 0-20
  double context_score;      // 0-20
  
  string factors_list[];
  string recommendation;
  
  enum CONFIDENCE { VERY_HIGH, HIGH, MEDIUM, LOW, VERY_LOW };
  CONFIDENCE confidence_level;
};

SweepValidation ValidateSweep(
  LiquidityZone zone,
  int sweep_bar,
  SessionInfo session,
  bool is_news_time
) {
  SweepValidation result;
  result.confidence_score = 0;
  ArrayResize(result.factors_list, 0);
  
  // FACTOR 1: Volume (0-30) - optional –µ—Å–ª–∏ unavailable
  result.volume_score = AnalyzeVolume(sweep_bar, is_news_time, result.factors_list);
  
  // FACTOR 2: Price Action (0-30) - always analyzed
  result.price_action_score = AnalyzePriceAction(zone, sweep_bar, result.factors_list);
  
  // FACTOR 3: Timing (0-20) - always analyzed
  result.timing_score = AnalyzeTiming(sweep_bar, session, is_news_time, result.factors_list);
  
  // FACTOR 4: Context (0-20) - always analyzed
  result.context_score = AnalyzeContext(zone, sweep_bar, result.factors_list);
  
  // TOTAL SCORE
  result.confidence_score = result.volume_score + 
                           result.price_action_score + 
                           result.timing_score + 
                           result.context_score;
  
  // CONFIDENCE LEVELS
  if (result.confidence_score >= 90) {
    result.confidence_level = SweepValidation::VERY_HIGH;
    result.valid = true;
    result.recommendation = "Excellent sweep - high probability";
  } else if (result.confidence_score >= 80) {
    result.confidence_level = SweepValidation::HIGH;
    result.valid = true;
    result.recommendation = "Strong sweep - good setup";
  } else if (result.confidence_score >= 70) {
    result.confidence_level = SweepValidation::MEDIUM;
    result.valid = true;
    result.recommendation = "Acceptable - use tight SL";
  } else if (result.confidence_score >= 60) {
    result.confidence_level = SweepValidation::LOW;
    result.valid = (is_news_time || session.type == SESSION_LONDON_NY_OVERLAP);
    result.recommendation = result.valid ? 
      "Weak - only during high-impact events" : "Below threshold";
  } else {
    result.confidence_level = SweepValidation::VERY_LOW;
    result.valid = false;
    result.recommendation = "Poor sweep - do not trade";
  }
  
  // ‚úÖ –ö–†–ò–¢–ò–ß–ù–û–ï –ü–†–ê–í–ò–õ–û: News sweep –±–µ–∑ volume = RED FLAG
  if (is_news_time && result.volume_score < 15) {
    result.valid = false;
    result.recommendation = "‚ö†Ô∏è News event but NO volume spike - likely false";
    ArrayPush(result.factors_list, "CRITICAL: News without volume confirmation");
  }
  
  return result;
}
```

---

## üèóÔ∏è –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –ú–û–î–£–õ–ï–ô (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø)

```
SMC_Master.mq5
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0: Common.mqh
‚îÇ   ‚îî‚îÄ‚îÄ –í—Å–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö, enums, –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0A: BrokerTimeDetector.mqh [–ö–†–ò–¢–ò–ß–ù–´–ô]
‚îÇ   ‚îú‚îÄ‚îÄ DetectBrokerGMTOffset() ‚Üí 2 –∏–ª–∏ 3
‚îÇ   ‚îú‚îÄ‚îÄ IsDSTActiveEU() ‚Üí —Ç–æ—á–Ω—ã–µ –¥–∞—Ç—ã (30 –º–∞—Ä—Ç–∞, 26 –æ–∫—Ç—è–±—Ä—è 2025)
‚îÇ   ‚îú‚îÄ‚îÄ GetLastSundayOfMonth()
‚îÇ   ‚îú‚îÄ‚îÄ GetOffsetToMSK() ‚Üí —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
‚îÇ   ‚îú‚îÄ‚îÄ ValidateDetection() ‚Üí cross-check
‚îÇ   ‚îî‚îÄ‚îÄ ShowTimeDebugPanel() ‚Üí –≤–∏–∑—É–∞–ª—å–Ω–∞—è –æ—Ç–ª–∞–¥–∫–∞
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0B: TimeZoneManager.mqh
‚îÇ   ‚îú‚îÄ‚îÄ ConvertToGMT(datetime broker_time)
‚îÇ   ‚îú‚îÄ‚îÄ GetCurrentMSKTime()
‚îÇ   ‚îî‚îÄ‚îÄ Helper functions
‚îÇ
‚îú‚îÄ‚îÄ MODULE 1: MarketStructure.mqh
‚îÇ   ‚îú‚îÄ‚îÄ DetectSwingPoints(int strength)
‚îÇ   ‚îú‚îÄ‚îÄ DetectBMS() ‚Üí –ø—Ä–æ–≤–µ—Ä–∫–∞ CLOSE, –Ω–µ High/Low!
‚îÇ   ‚îú‚îÄ‚îÄ DetectSMS() ‚Üí failure swing
‚îÇ   ‚îú‚îÄ‚îÄ GetHTFTrend(ENUM_TIMEFRAMES htf) ‚Üí –ù–û–í–ê–Ø
‚îÇ   ‚îî‚îÄ‚îÄ GetLastBMS() / GetLastSMS()
‚îÇ
‚îú‚îÄ‚îÄ MODULE 2A: Sessions.mqh [–ü–ï–†–ï–ú–ï–©–ï–ù –†–ê–ù–¨–®–ï LIQUIDITY!]
‚îÇ   ‚îú‚îÄ‚îÄ GetCurrentSession() ‚Üí GMT-based, Overlap –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
‚îÇ   ‚îú‚îÄ‚îÄ GetAsianRange()
‚îÇ   ‚îú‚îÄ‚îÄ ValidateAsianRangeQuality() ‚Üí –ù–û–í–ê–Ø
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Touches/wicks counting
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Quality score 0-100
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Rating:



