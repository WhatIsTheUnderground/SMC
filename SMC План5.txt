# üìò –ü–û–õ–ù–´–ô –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ü–õ–ê–ù –†–ê–ó–†–ê–ë–û–¢–ö–ò SMC –ò–ù–î–ò–ö–ê–¢–û–†–ê –î–õ–Ø MT5

**–í–µ—Ä—Å–∏—è:** 2.0 (–ü–æ—Å–ª–µ –∞—É–¥–∏—Ç–∞)  
**–î–∞—Ç–∞:** 17 –Ω–æ—è–±—Ä—è 2025  
**–°—Ç–∞—Ç—É—Å:** ‚úÖ –ì–æ—Ç–æ–≤ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏  

---

## üìã –°–û–î–ï–†–ñ–ê–ù–ò–ï

1. [–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Å–ª–µ –∞—É–¥–∏—Ç–∞](#–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ-–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è)
2. [–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª–µ–π](#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-–º–æ–¥—É–ª–µ–π)
3. [–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã](#–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ-–∞–ª–≥–æ—Ä–∏—Ç–º—ã)
4. [–°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö](#—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-–¥–∞–Ω–Ω—ã—Ö)
5. [–ü–ª–∞–Ω —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –ø–æ —Ñ–∞–∑–∞–º](#–ø–ª–∞–Ω-—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏)
6. [–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ](#—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)

---

## üéØ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø –ü–û–°–õ–ï –ê–£–î–ò–¢–ê {#–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ-–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è}

### ‚ö†Ô∏è –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–´–ï –ò–ó–ú–ï–ù–ï–ù–ò–Ø

#### 1. Time Zone Conversion (–£–ø—Ä–æ—â–µ–Ω–∞)
**–ë—ã–ª–æ:** –°–ª–æ–∂–Ω—ã–π —Ä–∞—Å—á–µ—Ç —Å DST  
**–°—Ç–∞–ª–æ:** `BrokerTimeDetector.GetOffsetToMSK()`

```cpp
int GetOffsetToMSK() {
  int broker_gmt = DetectBrokerGMTOffset();  // 2 –∏–ª–∏ 3
  bool dst_active = IsDSTActiveEU(TimeCurrent());
  int msk_gmt = 3;  // MSK –≤—Å–µ–≥–¥–∞ GMT+3
  
  if (dst_active) {
    return msk_gmt - 3;  // –õ–µ—Ç–æ–º: 0 —á–∞—Å–æ–≤ —Ä–∞–∑–Ω–∏—Ü—ã
  } else {
    return msk_gmt - 2;  // –ó–∏–º–æ–π: +1 —á–∞—Å –∫ broker time
  }
}
```

#### 2. AMD Pattern Direction (–ö–†–ò–¢–ò–ß–ù–û!)
**–ë—ã–ª–æ:** Manipulation –∏ Distribution –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏  
**–°—Ç–∞–ª–æ:** Manipulation –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–ê Distribution

```cpp
// BEARISH AMD (–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–æ):
// Asian Range: 1.0848-1.0862
// Manipulation: Breakout UP (swept BSL 1.0875) ‚Üê –õ–æ–≤—É—à–∫–∞!
// Distribution: BMS DOWN, —Ü–µ–Ω–∞ –∏–¥–µ—Ç –í–ù–ò–ó ‚Üê –ò—Å—Ç–∏–Ω–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ

if (manipulation_direction == UP) {
  expected_distribution_direction = DOWN;
}
```

#### 3. Order Block Mitigation Tracking
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –°—á–µ—Ç—á–∏–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–π OB

```cpp
struct OrderBlock {
  // ... existing fields
  int mitigation_count;           // –ù–û–í–û–ï
  ENUM_OB_STATUS status;          // ACTIVE/MITIGATED_ONCE/TWICE/WEAK/VIOLATED
  
  double GetConfluenceAdjustment() {
    if (mitigation_count <= 1) return 0.0;
    if (mitigation_count == 2) return -5.0;
    if (mitigation_count >= 3) return -15.0;
    return 0.0;
  }
};
```

#### 4. Confluence Weights (–î–æ 100%)
**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ:** –°—É–º–º–∞ —Ç–µ–ø–µ—Ä—å —Ä–æ–≤–Ω–æ 100%

```
–ë–ê–ó–û–í–´–ï:
‚úÖ BMS                     25%
‚úÖ Stop Hunt –ò–õ–ò SMS       20%
‚úÖ RTO to Order Block      20%
‚úÖ Session Timing          15% (–∏–ª–∏ 20% –¥–ª—è Overlap)
                          ----
                           80%

–î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï:
‚úÖ Fibonacci OTE           4%
‚úÖ HTF Trend Alignment     4%
‚úÖ High Impact News        4%
‚úÖ AMD Pattern             4%
‚úÖ HTF Order Block         4%
                          ----
                           20%
                          ====
–ò–¢–û–ì–û:                    100% ‚úÖ
```

#### 5. Sweep Volume Check
**–ë—ã–ª–æ:** Volume –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ –≤–µ–∑–¥–µ  
**–°—Ç–∞–ª–æ:** MANDATORY –¥–ª—è High Impact News sweeps

```cpp
if (is_news_time) {
  // –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–ê–Ø –ø—Ä–æ–≤–µ—Ä–∫–∞!
  if (volume < avg_volume * 1.5) {
    return INVALID_SWEEP;  // –ù–µ –Ω–∞—Å—Ç–æ—è—â–∏–π –±–∞–Ω–∫–æ–≤—Å–∫–∏–π sweep
  }
}
```

#### 6. Equal Highs Threshold (Timeframe-–∑–∞–≤–∏—Å–∏–º—ã–π)
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –†–∞–∑–Ω—ã–µ –ø–æ—Ä–æ–≥–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö TF

```cpp
// FOREX (EUR/USD):
M15:  2-5 pips
H1:   5-10 pips
H4:   10-20 pips
Daily: 20-50 pips

// GOLD (XAU/USD):
M15:  20-50 cents
H1:   50-100 cents
H4:   100-200 cents
```

#### 7. Fibonacci Integration
**–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ:** –†–∞—Å—á–µ—Ç —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è OB

```cpp
// Module 3: –ü–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è Order Block
OrderBlock ob = DetectBullishOB(...);
ob.impulse_start_bar = impulse_start;
ob.impulse_start_price = Low[impulse_start];
ob.impulse_end_price = High[bms_bar];

// –°–†–ê–ó–£ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å Fibonacci!
ob.fibonacci_data = Fibonacci.Calculate(ob);
ob.ote_zone = ob.fibonacci_data.ote_zone;
```

#### 8. Module Order (Sessions –ø–µ—Ä–µ–º–µ—â–µ–Ω)
**–ò–∑–º–µ–Ω–µ–Ω–æ:** Sessions —Ç–µ–ø–µ—Ä—å Module 2A (–¥–æ Liquidity!)

```
–ü–†–ê–í–ò–õ–¨–ù–´–ô –ü–û–†–Ø–î–û–ö:
0A. BrokerTimeDetector
0B. TimeZoneManager
1.  MarketStructure
2A. Sessions           ‚Üê –ü–ï–†–ï–ú–ï–©–ï–ù –†–ê–ù–¨–®–ï!
2B. Liquidity          ‚Üê –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Sessions data
3.  OrderBlocks
4.  Fibonacci
5.  SetupScanner
6.  ConfluenceCalculator
```

#### 9. HTF Trend Filter
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –ü—Ä–æ–≤–µ—Ä–∫–∞ HTF –ø–µ—Ä–µ–¥ LTF –≤—Ö–æ–¥–∞–º–∏

```cpp
ENUM_TREND_DIRECTION htf_trend = MarketStructure.GetHTFTrend(PERIOD_H4);

if (setup.direction == BUY && htf_trend == BEARISH) {
  return SKIP_SETUP;  // –ù–µ –≤—Ö–æ–¥–∏—Ç—å –ø—Ä–æ—Ç–∏–≤ HTF!
}
```

#### 10. Asian Range Quality Scoring
**–î–æ–±–∞–≤–ª–µ–Ω–æ:** –û—Ü–µ–Ω–∫–∞ –∫–∞—á–µ—Å—Ç–≤–∞ Asian Range

```cpp
struct AsianRange {
  // ... existing
  int touches_high;      // –ù–û–í–û–ï
  int touches_low;       // –ù–û–í–û–ï
  int wicks_above;       // –ù–û–í–û–ï
  int wicks_below;       // –ù–û–í–û–ï
  int quality_score;     // 0-100
  ENUM_ASIAN_QUALITY quality_rating;  // EXCELLENT/GOOD/ACCEPTABLE/WEAK
};
```

---

## üìä –ê–†–•–ò–¢–ï–ö–¢–£–†–ê –ú–û–î–£–õ–ï–ô {#–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞-–º–æ–¥—É–ª–µ–π}

```
SMC_Master.mq5
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0: Common.mqh
‚îÇ   ‚îî‚îÄ‚îÄ –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö, enums, –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0A: BrokerTimeDetector.mqh [–ö–†–ò–¢–ò–ß–ù–´–ô]
‚îÇ   ‚îú‚îÄ‚îÄ DetectBrokerGMTOffset() ‚Üí 2 –∏–ª–∏ 3
‚îÇ   ‚îú‚îÄ‚îÄ IsDSTActiveEU() ‚Üí —Ç–æ—á–Ω—ã–µ –¥–∞—Ç—ã –ø–µ—Ä–µ—Ö–æ–¥–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ GetOffsetToMSK() ‚Üí —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
‚îÇ   ‚îú‚îÄ‚îÄ ValidateDetection() ‚Üí cross-check
‚îÇ   ‚îî‚îÄ‚îÄ ShowTimeDebugPanel() ‚Üí –≤–∏–∑—É–∞–ª—å–Ω–∞—è –æ—Ç–ª–∞–¥–∫–∞
‚îÇ
‚îú‚îÄ‚îÄ MODULE 0B: TimeZoneManager.mqh
‚îÇ   ‚îú‚îÄ‚îÄ ConvertBrokerToMSK()
‚îÇ   ‚îú‚îÄ‚îÄ ConvertMSKToBroker()
‚îÇ   ‚îî‚îÄ‚îÄ GetCurrentMSKTime()
‚îÇ
‚îú‚îÄ‚îÄ MODULE 1: MarketStructure.mqh
‚îÇ   ‚îú‚îÄ‚îÄ DetectSwingPoints(strength)
‚îÇ   ‚îú‚îÄ‚îÄ DetectBMS() ‚Üí –ø—Ä–æ–≤–µ—Ä–∫–∞ CLOSE, –Ω–µ High/Low
‚îÇ   ‚îú‚îÄ‚îÄ DetectSMS() ‚Üí failure swing
‚îÇ   ‚îî‚îÄ‚îÄ GetHTFTrend(timeframe) ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 2A: Sessions.mqh [–ü–ï–†–ï–ú–ï–©–ï–ù –†–ê–ù–¨–®–ï]
‚îÇ   ‚îú‚îÄ‚îÄ GetCurrentSession() ‚Üí —Å Overlap –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
‚îÇ   ‚îú‚îÄ‚îÄ GetAsianRange()
‚îÇ   ‚îú‚îÄ‚îÄ ValidateAsianRangeQuality() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ   ‚îú‚îÄ‚îÄ DetectAMD() ‚Üí –ò–°–ü–†–ê–í–õ–ï–ù (manipulation –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–∞)
‚îÇ   ‚îî‚îÄ‚îÄ IsLondonNYOverlap() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 2B: Liquidity.mqh
‚îÇ   ‚îú‚îÄ‚îÄ FindBSL() / FindSSL()
‚îÇ   ‚îú‚îÄ‚îÄ FindEqualHighsLows() ‚Üí timeframe-dependent threshold
‚îÇ   ‚îú‚îÄ‚îÄ DetectSweep() ‚Üí volume MANDATORY –¥–ª—è News
‚îÇ   ‚îî‚îÄ‚îÄ ValidateSweepHoldingTime() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 3: OrderBlocks.mqh [–ò–°–ü–†–ê–í–õ–ï–ù]
‚îÇ   ‚îú‚îÄ‚îÄ DetectBullishOB() ‚Üí —Ç–æ—á–Ω—ã–π impulse start + fallback
‚îÇ   ‚îú‚îÄ‚îÄ DetectBearishOB()
‚îÇ   ‚îú‚îÄ‚îÄ ValidateOB()
‚îÇ   ‚îú‚îÄ‚îÄ CheckMitigation() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ   ‚îî‚îÄ‚îÄ TrackMitigationCount() ‚Üí –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îú‚îÄ‚îÄ MODULE 4: Fibonacci.mqh
‚îÇ   ‚îú‚îÄ‚îÄ Calculate(OrderBlock) ‚Üí –∏—Å–ø–æ–ª—å–∑—É–µ—Ç impulse data
‚îÇ   ‚îú‚îÄ‚îÄ GetOTEZone()
‚îÇ   ‚îî‚îÄ‚îÄ IsPriceInOTE()
‚îÇ
‚îú‚îÄ‚îÄ MODULE 5: SetupScanner.mqh
‚îÇ   ‚îú‚îÄ‚îÄ ScanTurtleSoup() ‚Üí —Å holding time check
‚îÇ   ‚îú‚îÄ‚îÄ ScanSH_BMS_RTO() ‚Üí —Å HTF filter
‚îÇ   ‚îú‚îÄ‚îÄ ScanSMS_BMS_RTO()
‚îÇ   ‚îî‚îÄ‚îÄ ScanAMD() ‚Üí –∫–∞–∫ context filter
‚îÇ
‚îú‚îÄ‚îÄ MODULE 6: ConfluenceCalculator.mqh [–ò–°–ü–†–ê–í–õ–ï–ù]
‚îÇ   ‚îî‚îÄ‚îÄ CalculateConfluence() ‚Üí –≤–µ—Å–∞ –¥–æ 100%
‚îÇ
‚îú‚îÄ‚îÄ MODULE 7: RiskManager.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ   ‚îî‚îÄ‚îÄ CalculateLotSize()
‚îÇ
‚îú‚îÄ‚îÄ MODULE 8: NewsCalendar.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ   ‚îú‚îÄ‚îÄ MANUAL mode (—Ä—É—á–Ω–æ–π –≤–≤–æ–¥)
‚îÇ   ‚îú‚îÄ‚îÄ DISABLED mode (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
‚îÇ   ‚îî‚îÄ‚îÄ VOLATILITY mode (–ø–æ ATR)
‚îÇ
‚îú‚îÄ‚îÄ MODULE 9: Logger.mqh
‚îÇ   ‚îî‚îÄ‚îÄ –¶–µ–Ω—Ç—Ä–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
‚îÇ
‚îî‚îÄ‚îÄ MODULE 10: Dashboard.mqh [–ù–û–í–´–ô]
    ‚îú‚îÄ‚îÄ DrawDashboard()
    ‚îú‚îÄ‚îÄ UpdateRealtime()
    ‚îî‚îÄ‚îÄ ShowActiveSetups()
```

---

## üîç –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ï –ê–õ–ì–û–†–ò–¢–ú–´ {#–∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ-–∞–ª–≥–æ—Ä–∏—Ç–º—ã}

### –ê–õ–ì–û–†–ò–¢–ú 0A: Broker Time Detection

```cpp
// –£–ü–†–û–©–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø
int GetOffsetToMSK() {
  int broker_gmt = DetectBrokerGMTOffset();
  bool dst_active = IsDSTActiveEU(TimeCurrent());
  int msk_gmt = 3;
  
  if (dst_active) {
    return msk_gmt - 3;  // 3 - 3 = 0 (–ª–µ—Ç–æ–º)
  } else {
    return msk_gmt - 2;  // 3 - 2 = +1 (–∑–∏–º–æ–π)
  }
}

// –¢–û–ß–ù–ê–Ø DST –ü–†–û–í–ï–†–ö–ê
bool IsDSTActiveEU(datetime time) {
  MqlDateTime dt;
  TimeToStruct(time, dt);
  
  if (dt.mon < 3 || dt.mon > 10) return false;
  if (dt.mon > 3 && dt.mon < 10) return true;
  
  // –ì—Ä–∞–Ω–∏—á–Ω—ã–µ –º–µ—Å—è—Ü—ã
  if (dt.mon == 3) {
    int last_sunday = GetLastSundayOfMonth(dt.year, 3);
    if (dt.day < last_sunday) return false;
    if (dt.day > last_sunday) return true;
    return (dt.hour >= 2);
  }
  
  if (dt.mon == 10) {
    int last_sunday = GetLastSundayOfMonth(dt.year, 10);
    if (dt.day < last_sunday) return true;
    if (dt.day > last_sunday) return false;
    return (dt.hour < 3);
  }
  
  return false;
}

int GetLastSundayOfMonth(int year, int month) {
  MqlDateTime dt_end;
  dt_end.year = year;
  dt_end.mon = month;
  dt_end.day = 31;
  dt_end.hour = 12;
  
  datetime time_end = StructToTime(dt_end);
  if (time_end == 0) {
    dt_end.day = 30;
    time_end = StructToTime(dt_end);
  }
  if (time_end == 0) {
    dt_end.day = 28;
    time_end = StructToTime(dt_end);
  }
  
  TimeToStruct(time_end, dt_end);
  while (dt_end.day_of_week != 0) {
    time_end -= 86400;
    TimeToStruct(time_end, dt_end);
  }
  
  return dt_end.day;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 1: HTF Trend Detection (–ù–û–í–´–ô)

```cpp
ENUM_TREND_DIRECTION GetHTFTrend(ENUM_TIMEFRAMES htf_period) {
  // –ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ HTF
  int htf_bars = iBars(Symbol(), htf_period);
  
  // –ù–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 2 BMS
  BMS latest_bms = NULL;
  BMS previous_bms = NULL;
  
  for (int i = 1; i < MathMin(100, htf_bars); i++) {
    BMS bms = DetectBMSAtBar(i, htf_period);
    if (bms != NULL) {
      if (latest_bms == NULL) {
        latest_bms = bms;
      } else if (previous_bms == NULL) {
        previous_bms = bms;
        break;
      }
    }
  }
  
  // –ê–Ω–∞–ª–∏–∑ —Ç—Ä–µ–Ω–¥–∞
  if (latest_bms == NULL) {
    return TREND_RANGING;
  }
  
  if (latest_bms.type == BMS_BULLISH) {
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —Ü–µ–Ω–∞ –≤—ã—à–µ BMS
    double current_price = iClose(Symbol(), htf_period, 0);
    if (current_price > latest_bms.price) {
      return TREND_BULLISH;
    }
  }
  
  if (latest_bms.type == BMS_BEARISH) {
    double current_price = iClose(Symbol(), htf_period, 0);
    if (current_price < latest_bms.price) {
      return TREND_BEARISH;
    }
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å consistency (–¥–≤–∞ BMS –ø–æ–¥—Ä—è–¥ –≤ –æ–¥–Ω–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏)
  if (previous_bms != NULL) {
    if (latest_bms.type == previous_bms.type) {
      return (latest_bms.type == BMS_BULLISH) ? TREND_BULLISH : TREND_BEARISH;
    }
  }
  
  return TREND_RANGING;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2A: Sessions Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
SessionInfo GetCurrentSession(datetime msk_time) {
  MqlDateTime dt;
  TimeToStruct(msk_time, dt);
  int hour = dt.hour;
  
  SessionInfo info;
  
  // –ü–†–ò–û–†–ò–¢–ï–¢ #1: London-NY Overlap (—Å–∞–º–∞—è –≤–∞–∂–Ω–∞—è –∑–æ–Ω–∞!)
  if (hour >= 16 && hour < 18) {
    info.type = SESSION_LONDON_NY_OVERLAP;
    info.importance = MAXIMUM;
    info.confluence_weight = 20.0;  // –ë–æ–ª—å—à–µ –æ–±—ã—á–Ω—ã—Ö!
    info.description = "Maximum liquidity - both centers active";
    return info;
  }
  
  // London Prime
  if (hour >= 10 && hour < 13) {
    info.type = SESSION_LONDON_PRIME;
    info.importance = HIGH;
    info.confluence_weight = 15.0;
    info.description = "London first 3 hours";
    return info;
  }
  
  // London Late
  if (hour >= 13 && hour < 15) {
    info.type = SESSION_LONDON_LATE;
    info.importance = MEDIUM;
    info.confluence_weight = 8.0;
    return info;
  }
  
  // NY Prime
  if (hour >= 15 && hour < 18) {
    info.type = SESSION_NY_PRIME;
    info.importance = HIGH;
    info.confluence_weight = 15.0;
    return info;
  }
  
  // NY Late
  if (hour >= 18 && hour < 21) {
    info.type = SESSION_NY_LATE;
    info.importance = LOW;
    info.confluence_weight = 5.0;
    return info;
  }
  
  // Asian
  if (hour >= 3 && hour < 9) {
    info.type = SESSION_ASIAN;
    info.importance = OBSERVATION_ONLY;
    info.confluence_weight = 0.0;
    info.description = "Accumulation phase only";
    return info;
  }
  
  // Dead Zone
  info.type = SESSION_DEAD_ZONE;
  info.importance = NONE;
  info.confluence_weight = -20.0;  // –®–¢–†–ê–§!
  info.description = "Do not trade";
  return info;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2A.1: Asian Range Quality (–ù–û–í–´–ô)

```cpp
AsianRange ValidateAsianRangeQuality(AsianRange range) {
  int quality_score = 0;
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 1: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Å–∞–Ω–∏–π –≥—Ä–∞–Ω–∏—Ü (30 points)
  int total_touches = range.touches_high + range.touches_low;
  if (total_touches >= 6) {
    quality_score += 30;
  } else if (total_touches >= 4) {
    quality_score += 20;
  } else if (total_touches >= 2) {
    quality_score += 10;
  }
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 2: Wicks –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ range (20 points)
  int total_wicks = range.wicks_above + range.wicks_below;
  if (total_wicks >= 3) {
    quality_score += 20;
  } else if (total_wicks >= 1) {
    quality_score += 10;
  }
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 3: –§–ª—ç—Ç —Ö–∞—Ä–∞–∫—Ç–µ—Ä (30 points)
  if (range.flat_ratio >= 0.40 && range.flat_ratio <= 0.60) {
    quality_score += 30;
  } else if (range.flat_ratio >= 0.35 && range.flat_ratio <= 0.65) {
    quality_score += 20;
  } else if (range.flat_ratio >= 0.30 && range.flat_ratio <= 0.70) {
    quality_score += 10;
  }
  
  // –ö—Ä–∏—Ç–µ—Ä–∏–π 4: –†–∞–≤–Ω–æ–º–µ—Ä–Ω–æ—Å—Ç—å (20 points)
  double coverage = CalculateCoverage(range);
  if (coverage > 0.4) {
    quality_score += 20;
  } else if (coverage > 0.3) {
    quality_score += 10;
  }
  
  range.quality_score = quality_score;
  
  // –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ä–µ–π—Ç–∏–Ω–≥
  if (quality_score >= 80) {
    range.quality_rating = ASIAN_EXCELLENT;
  } else if (quality_score >= 60) {
    range.quality_rating = ASIAN_GOOD;
  } else if (quality_score >= 40) {
    range.quality_rating = ASIAN_ACCEPTABLE;
  } else {
    range.quality_rating = ASIAN_WEAK;
  }
  
  return range;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2A.2: AMD Pattern Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
AMD_Pattern DetectAMD(AsianRange asian_range, SessionInfo session) {
  AMD_Pattern amd;
  amd.valid = false;
  
  // PHASE A: Accumulation (—É–∂–µ –µ—Å—Ç—å Asian Range)
  amd.accumulation_zone = asian_range;
  
  // PHASE M: Manipulation (London Open –æ–±—ã—á–Ω–æ)
  if (session.type != SESSION_LONDON_PRIME && session.type != SESSION_NY_PRIME) {
    return amd;  // –†–∞–Ω–æ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å breakout –æ—Ç Asian Range
  double current_high = iHigh(Symbol(), PERIOD_CURRENT, 0);
  double current_low = iLow(Symbol(), PERIOD_CURRENT, 0);
  
  bool broke_above = (current_high > asian_range.high);
  bool broke_below = (current_low < asian_range.low);
  
  if (broke_above) {
    amd.manipulation_direction = AMD_UP;
    amd.manipulation_price = current_high;
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ swept BSL
    LiquidityZone[] bsl = Liquidity.FindBSLAbove(asian_range.high);
    if (ArraySize(bsl) > 0) {
      amd.swept_liquidity = bsl;
      amd.manipulation_confirmed = true;
    }
    
    // –û–ñ–ò–î–ê–ï–ú–û–ï –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï DISTRIBUTION - –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–û!
    amd.expected_distribution_direction = AMD_DOWN;
    
  } else if (broke_below) {
    amd.manipulation_direction = AMD_DOWN;
    amd.manipulation_price = current_low;
    
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ swept SSL
    LiquidityZone[] ssl = Liquidity.FindSSLBelow(asian_range.low);
    if (ArraySize(ssl) > 0) {
      amd.swept_liquidity = ssl;
      amd.manipulation_confirmed = true;
    }
    
    // –û–ñ–ò–î–ê–ï–ú–û–ï –ù–ê–ü–†–ê–í–õ–ï–ù–ò–ï - –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–û!
    amd.expected_distribution_direction = AMD_UP;
  }
  
  // PHASE D: Distribution (–ø—Ä–æ–≤–µ—Ä–∫–∞ BMS –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è)
  if (amd.manipulation_confirmed) {
    // –ñ–¥–µ–º BMS –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ expected_distribution
    BMS latest_bms = MarketStructure.DetectLatestBMS();
    
    if (amd.expected_distribution_direction == AMD_DOWN) {
      if (latest_bms.type == BMS_BEARISH && 
          latest_bms.price < asian_range.low) {
        amd.distribution_confirmed = true;
        amd.distribution_bms = latest_bms;
        amd.valid = true;
      }
    } else {
      if (latest_bms.type == BMS_BULLISH && 
          latest_bms.price > asian_range.high) {
        amd.distribution_confirmed = true;
        amd.distribution_bms = latest_bms;
        amd.valid = true;
      }
    }
  }
  
  return amd;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2B: Equal Highs/Lows (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
double GetEqualThreshold(string symbol, ENUM_TIMEFRAMES tf) {
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  bool is_index = (StringFind(symbol, "NAS") >= 0 || 
                   StringFind(symbol, "US500") >= 0);
  
  double base = 0;
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 5; break;
      case PERIOD_M30: base = 7; break;
      case PERIOD_H1:  base = 10; break;
      case PERIOD_H4:  base = 20; break;
      case PERIOD_D1:  base = 50; break;
      default:         base = 100; break;
    }
  } else if (is_gold) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 50; break;
      case PERIOD_M30: base = 70; break;
      case PERIOD_H1:  base = 100; break;
      case PERIOD_H4:  base = 200; break;
      case PERIOD_D1:  base = 500; break;
      default:         base = 1000; break;
    }
  } else if (is_index) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15: base = 15; break;
      case PERIOD_M30: base = 20; break;
      case PERIOD_H1:  base = 30; break;
      case PERIOD_H4:  base = 60; break;
      case PERIOD_D1:  base = 150; break;
      default:         base = 300; break;
    }
  } else {
    base = 10;  // Default
  }
  
  return base * SymbolInfoDouble(symbol, SYMBOL_POINT);
}

EqualZone[] FindEqualHighs(SwingPoint[] swings) {
  EqualZone[] zones;
  double threshold = GetEqualThreshold(Symbol(), Period());
  
  for (int i = 0; i < ArraySize(swings); i++) {
    if (swings[i].type != SWING_HIGH) continue;
    
    for (int j = i + 1; j < ArraySize(swings); j++) {
      if (swings[j].type != SWING_HIGH) continue;
      
      double distance = MathAbs(swings[i].price - swings[j].price);
      
      if (distance < threshold) {
        EqualZone zone;
        zone.price = (swings[i].price + swings[j].price) / 2;
        zone.type = LIQUIDITY_BSL;
        zone.count = 2;
        zone.importance = HIGH;
        zone.swing_indices.Add(i);
        zone.swing_indices.Add(j);
        
        // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –±–æ–ª—å—à–µ swings –≤ —ç—Ç–æ–π –∑–æ–Ω–µ
        for (int k = j + 1; k < ArraySize(swings); k++) {
          if (swings[k].type != SWING_HIGH) continue;
          double dist_k = MathAbs(swings[k].price - zone.price);
          if (dist_k < threshold) {
            zone.count++;
            zone.swing_indices.Add(k);
          }
        }
        
        ArrayPush(zones, zone);
        break;
      }
    }
  }
  
  return zones;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 2B.1: Sweep Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
SweepData DetectSweep(LiquidityZone zone, SessionInfo session, bool is_news_time) {
  SweepData sweep;
  sweep.valid = false;
  
  // STEP 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–±–æ—è
  double distance = 0;
  int sweep_bar = 0;
  
  if (zone.type == LIQUIDITY_BSL) {
    distance = iHigh(Symbol(), PERIOD_CURRENT, 0) - zone.price;
    sweep_bar = 0;
  } else {
    distance = zone.price - iLow(Symbol(), PERIOD_CURRENT, 0);
    sweep_bar = 0;
  }
  
  double distance_pips = distance / Point;
  
  if (distance_pips < 5 || distance_pips > 50) {
    return sweep;  // –ó–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –¥–æ–ø—É—Å—Ç–∏–º–æ–≥–æ –¥–∏–∞–ø–∞–∑–æ–Ω–∞
  }
  
  // STEP 2: Holding Time Check (–ù–û–í–û–ï)
  int holding_bars = 0;
  int check_bar = sweep_bar;
  
  for (int i = 0; i < 5; i++) {
    double close = iClose(Symbol(), PERIOD_CURRENT, check_bar);
    bool still_beyond = false;
    
    if (zone.type == LIQUIDITY_BSL) {
      still_beyond = (close > zone.price);
    } else {
      still_beyond = (close < zone.price);
    }
    
    if (still_beyond) {
      holding_bars++;
      check_bar++;
    } else {
      break;
    }
  }
  
  sweep.holding_bars = holding_bars;
  
  // –û—Ü–µ–Ω–∫–∞ –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
  if (holding_bars < 2) {
    sweep.validity = SWEEP_WEAK;
  } else if (holding_bars == 2) {
    sweep.validity = SWEEP_GOOD;
  } else {
    sweep.validity = SWEEP_STRONG;
  }
  
  // STEP 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞
  int max_return_bars = 3 + holding_bars;
  bool return_detected = false;
  
  for (int i = sweep_bar + holding_bars; i < sweep_bar + max_return_bars; i++) {
    double close = iClose(Symbol(), PERIOD_CURRENT, i);
    
    if (zone.type == LIQUIDITY_BSL) {
      if (close < zone.price) {
        return_detected = true;
        sweep.return_bars = i - sweep_bar;
        break;
      }
    } else {
      if (close > zone.price) {
        return_detected = true;
        sweep.return_bars = i - sweep_bar;
        break;
      }
    }
  }
  
  if (!return_detected) {
    return sweep;  // –ù–µ –≤–µ—Ä–Ω—É–ª–∞—Å—å - —ç—Ç–æ breakout, –Ω–µ sweep
  }
  
  // STEP 4: Volume Check
  double volume = iVolume(Symbol(), PERIOD_CURRENT, sweep_bar);
  double avg_volume = CalculateAvgVolume(20);
  sweep.volume = volume;
  sweep.avg_volume = avg_volume;
  sweep.volume_ratio = volume / avg_volume;
  
  // –î–ª—è News sweeps - MANDATORY volume check!
  if (is_news_time) {
    sweep.volume_mandatory = true;
    if (sweep.volume_ratio < 1.5) {
      // –ù–ï–î–û–°–¢–ê–¢–û–ß–ù–´–ô –æ–±—ä–µ–º –¥–ª—è news sweep
      sweep.valid = false;
      sweep.invalid_reason = "Insufficient volume for news sweep";
      return sweep;
    }
  } else {
    // –î–ª—è –æ–±—ã—á–Ω—ã—Ö —Å–µ—Å—Å–∏–π - optional
    sweep.volume_mandatory = false;
  }
  
  // STEP 5: Session validation
  if (session.type != SESSION_LONDON_PRIME && 
      session.type != SESSION_NY_PRIME && 
      session.type != SESSION_LONDON_NY_OVERLAP) {
    if (!is_news_time) {
      sweep.valid = false;
      sweep.invalid_reason = "Wrong session for sweep";
      return sweep;
    }
  }
  
  // –í—Å–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã
  sweep.valid = true;
  sweep.zone_price = zone.price;
  sweep.sweep_price = (zone.type == LIQUIDITY_BSL) ? iHigh(Symbol(), PERIOD_CURRENT, sweep_bar) : iLow(Symbol(), PERIOD_CURRENT, sweep_bar);
  sweep.distance_pips = distance_pips;
  sweep.type = zone.type;
  sweep.session = session.type;
  sweep.is_news_time = is_news_time;
  sweep.time = iTime(Symbol(), PERIOD_CURRENT, sweep_bar);
  
  return sweep;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 3: Order Block Detection (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
OrderBlock DetectBullishOB(BMS bms, SwingPoint[] swings) {
  OrderBlock ob;
  ob.valid = false;
  
  int bms_bar = iBarShift(Symbol(), PERIOD_CURRENT, bms.time);
  
  // STEP 1: –û–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–∞—á–∞–ª–æ –∏–º–ø—É–ª—å—Å–∞ (–¢–û–ß–ù–û)
  int impulse_start_bar = -1;
  
  // a) –ü–æ—Å–ª–µ–¥–Ω–∏–π swing low
  for (int i = 0; i < ArraySize(swings); i++) {
    if (swings[i].type == SWING_LOW && swings[i].bar_index < bms_bar) {
      if (impulse_start_bar == -1 || swings[i].bar_index > impulse_start_bar) {
        impulse_start_bar = swings[i].bar_index;
      }
    }
  }
  
  // b) –¢–æ—á–∫–∞ –ø–æ—Å–ª–µ Stop Hunt/Sweep SSL
  SweepData[] recent_sweeps = Liquidity.GetRecentSweeps(bms.time);
  for (int i = 0; i < ArraySize(recent_sweeps); i++) {
    if (recent_sweeps[i].type == LIQUIDITY_SSL) {
      int sweep_bar = iBarShift(Symbol(), PERIOD_CURRENT, recent_sweeps[i].time);
      if (sweep_bar < bms_bar && sweep_bar > impulse_start_bar) {
        impulse_start_bar = sweep_bar;
      }
    }
  }
  
  // c) –í—ã—Ö–æ–¥ –∏–∑ –∫–æ–Ω—Å–æ–ª–∏–¥–∞—Ü–∏–∏
  int consolidation_end = DetectConsolidationEnd(bms_bar);
  if (consolidation_end > impulse_start_bar) {
    impulse_start_bar = consolidation_end;
  }
  
  // d) –ü—Ä–µ–¥—ã–¥—É—â–∏–π BMS –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–≥–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
  BMS prev_bearish_bms = FindPreviousBMS(BMS_BEARISH, bms.time);
  if (prev_bearish_bms != NULL) {
    int prev_bms_bar = iBarShift(Symbol(), PERIOD_CURRENT, prev_bearish_bms.time);
    if (prev_bms_bar < bms_bar && prev_bms_bar > impulse_start_bar) {
      impulse_start_bar = prev_bms_bar;
    }
  }
  
  // STEP 2: –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞—á–∞–ª–∞ –∏–º–ø—É–ª—å—Å–∞
  int distance_from_bms = bms_bar - impulse_start_bar;
  
  if (distance_from_bms < 3) {
    ob.valid = false;
    ob.invalid_reason = "Impulse too short";
    return ob;
  }
  
  if (distance_from_bms > 100) {
    impulse_start_bar = bms_bar - 50;
    Print("Warning: Impulse start too far, using default lookback");
  }
  
  // STEP 3: –ü–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–µ–π bearish —Å–≤–µ—á–∏
  int ob_bar = -1;
  
  for (int i = bms_bar - 3; i >= impulse_start_bar; i--) {
    double open = iOpen(Symbol(), PERIOD_CURRENT, i);
    double close = iClose(Symbol(), PERIOD_CURRENT, i);
    
    if (close < open) {  // Bearish candle
      ob_bar = i;
      break;  // –ü–ï–†–í–ê–Ø –Ω–∞–π–¥–µ–Ω–Ω–∞—è = –ü–û–°–õ–ï–î–ù–Ø–Ø –ø–µ—Ä–µ–¥ BMS
    }
  }
  
  // STEP 4: Fallback –µ—Å–ª–∏ –Ω–µ—Ç –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã—Ö —Å–≤–µ—á–µ–π
  if (ob_bar == -1) {
    ob_bar = impulse_start_bar;
    ob.note = "Using impulse start as OB (no opposite candles found)";
  }
  
  // STEP 5: –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –≥—Ä–∞–Ω–∏—Ü Order Block
  double ob_high = iHigh(Symbol(), PERIOD_CURRENT, ob_bar);
  double ob_low = iLow(Symbol(), PERIOD_CURRENT, ob_bar);
  double ob_size = (ob_high - ob_low) / Point;
  
  // –í–∞–ª–∏–¥–∞—Ü–∏—è —Ä–∞–∑–º–µ—Ä–∞
  OBSizeLimits limits = GetOBLimits(Symbol(), Period());
  
  if (ob_size < limits.min_size) {
    // –†–∞—Å—à–∏—Ä–∏—Ç—å –Ω–∞ —Å–æ—Å–µ–¥–Ω–∏–µ —Å–≤–µ—á–∏
    ob_high = MathMax(iHigh(Symbol(), PERIOD_CURRENT, ob_bar - 1), 
                      MathMax(ob_high, iHigh(Symbol(), PERIOD_CURRENT, ob_bar + 1)));
    ob_low = MathMin(iLow(Symbol(), PERIOD_CURRENT, ob_bar - 1), 
                     MathMin(ob_low, iLow(Symbol(), PERIOD_CURRENT, ob_bar + 1)));
    ob_size = (ob_high - ob_low) / Point;
  }
  
  if (ob_size > limits.max_size) {
    // –£–º–µ–Ω—å—à–∏—Ç—å –¥–æ 50% —Å–≤–µ—á–∏
    double ob_midpoint = (ob_high + ob_low) / 2;
    double ob_range = (ob_high - ob_low) * 0.5;
    ob_high = ob_midpoint + ob_range / 2;
    ob_low = ob_midpoint - ob_range / 2;
  }
  
  // STEP 6: –ù–∞–π—Ç–∏ –º–∞–∫—Å–∏–º—É–º –∏–º–ø—É–ª—å—Å–∞ –¥–ª—è Fibonacci
  double impulse_max = iHigh(Symbol(), PERIOD_CURRENT, impulse_start_bar);
  for (int i = impulse_start_bar; i >= bms_bar; i--) {
    double high = iHigh(Symbol(), PERIOD_CURRENT, i);
    if (high > impulse_max) {
      impulse_max = high;
    }
  }
  
  // STEP 7: –ó–∞–ø–æ–ª–Ω–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É Order Block
  ob.time = iTime(Symbol(), PERIOD_CURRENT, ob_bar);
  ob.high = ob_high;
  ob.low = ob_low;
  ob.bar_index = ob_bar;
  ob.type = OB_BULLISH;
  
  ob.bms_ref.time = bms.time;
  ob.bms_ref.price = bms.price;
  
  // –î–∞–Ω–Ω—ã–µ –∏–º–ø—É–ª—å—Å–∞ –¥–ª—è Fibonacci
  ob.impulse_start_bar = impulse_start_bar;
  ob.impulse_start_price = iLow(Symbol(), PERIOD_CURRENT, impulse_start_bar);
  ob.impulse_end_price = impulse_max;
  
  // Mitigation tracking
  ob.status = OB_ACTIVE;
  ob.mitigation_count = 0;
  ob.last_mitigation_time = 0;
  
  ob.valid = true;
  
  return ob;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 3.1: Order Block Mitigation Check (–ù–û–í–´–ô)

```cpp
MitigationResult CheckOrderBlockMitigation(OrderBlock &ob, double current_price, datetime current_time) {
  MitigationResult result;
  result.action = MITIGATION_NO_CHANGE;
  
  double ob_midpoint = (ob.high + ob.low) / 2;
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞—Å–∞–Ω–∏—è OB –∑–æ–Ω—ã
  bool price_in_ob = false;
  bool violated = false;
  
  if (ob.type == OB_BULLISH) {
    price_in_ob = (current_price >= ob.low && current_price <= ob.high);
    violated = (current_price < ob.low);
  } else {
    price_in_ob = (current_price >= ob.low && current_price <= ob.high);
    violated = (current_price > ob.high);
  }
  
  // –°–ª—É—á–∞–π 1: VIOLATION
  if (violated) {
    ob.status = OB_VIOLATED;
    ob.mitigation_count = 999;
    result.action = MITIGATION_INVALIDATED;
    result.confluence_adjustment = -100.0;
    return result;
  }
  
  // –°–ª—É—á–∞–π 2: –í –∑–æ–Ω–µ OB
  if (price_in_ob) {
    // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —á—Ç–æ —ç—Ç–æ –Ω–æ–≤–æ–µ –∫–∞—Å–∞–Ω–∏–µ
    int time_since_last = (int)(current_time - ob.last_mitigation_time);
    if (time_since_last < 300) {  // 5 –º–∏–Ω—É—Ç
      result.action = MITIGATION_SAME_TOUCH;
      return result;
    }
    
    // –ù–æ–≤–æ–µ –∫–∞—Å–∞–Ω–∏–µ
    ob.mitigation_count++;
    ob.last_mitigation_time = current_time;
    ArrayPush(ob.mitigation_prices, current_price);
    
    // –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å
    if (ob.mitigation_count == 1) {
      ob.status = OB_MITIGATED_ONCE;
      result.confluence_adjustment = 0.0;
      result.recommendation = "Good - first RTO";
    } else if (ob.mitigation_count == 2) {
      ob.status = OB_MITIGATED_TWICE;
      result.confluence_adjustment = -5.0;
      result.recommendation = "Acceptable - second RTO, use tighter SL";
    } else if (ob.mitigation_count >= 3) {
      ob.status = OB_WEAK;
      result.confluence_adjustment = -15.0;
      result.recommendation = "Risky - third RTO, not recommended";
      Print("Warning: OB used 3+ times - consider invalid");
    }
    
    result.action = MITIGATION_TOUCHED;
    result.mitigation_count = ob.mitigation_count;
    
    return result;
  }
  
  // –°–ª—É—á–∞–π 3: –¶–µ–Ω–∞ –≤–Ω–µ OB
  return result;
}
```

### –ê–õ–ì–û–†–ò–¢–ú 4: Fibonacci Calculation (–ò–°–ü–†–ê–í–õ–ï–ù)

```cpp
FibonacciLevels CalculateFibonacci(OrderBlock ob) {
  FibonacciLevels fibo;
  
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ Order Block —Å—Ç—Ä—É–∫—Ç—É—Ä—ã!
  fibo.impulse_start = ob.impulse_start_price;
  fibo.impulse_end = ob.impulse_end_price;
  fibo.range = fibo.impulse_end - fibo.impulse_start;
  
  // –†–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω–µ–π (–¥–ª—è Bullish - –æ—Ç–∫–∞—Ç –æ—Ç HIGH –∫ LOW)
  if (ob.type == OB_BULLISH) {
    fibo.L0 = fibo.impulse_end;  // 100%
    fibo.L236 = fibo.impulse_end - (fibo.range * 0.236);
    fibo.L382 = fibo.impulse_end - (fibo.range * 0.382);
    fibo.L50 = fibo.impulse_end - (fibo.range * 0.5);
    fibo.L618 = fibo.impulse_end - (fibo.range * 0.618);
    fibo.L705 = fibo.impulse_end - (fibo.range * 0.705);
    fibo.L79 = fibo.impulse_end - (fibo.range * 0.79);
    fibo.L886 = fibo.impulse_end - (fibo.range * 0.886);
    fibo.L100 = fibo.impulse_start;  // 0%
  } else {
    // –î–ª—è Bearish - –æ—Ç–∫–∞—Ç –æ—Ç LOW –∫ HIGH
    fibo.L0 = fibo.impulse_start;  // –ù–∞—á–∞–ª–æ (–Ω–∏–∑ –¥–ª—è bearish)
    fibo.L236 = fibo.impulse_start + (fibo.range * 0.236);
    fibo.L382 = fibo.impulse_start + (fibo.range * 0.382);
    fibo.L50 = fibo.impulse_start + (fibo.range * 0.5);
    fibo.L618 = fibo.impulse_start + (fibo.range * 0.618);
    fibo.L705 = fibo.impulse_start + (fibo.range * 0.705);
    fibo.L79 = fibo.impulse_start + (fibo.range * 0.79);
    fibo.L886 = fibo.impulse_start + (fibo.range * 0.886);
    fibo.L100 = fibo.impulse_end;  // –ö–æ–Ω–µ—Ü (–≤–µ—Ä—Ö –¥–ª—è bearish)
  }
  
  // OTE Zone
  fibo.ote_zone.high = fibo.L618;
  fibo.ote_zone.low = fibo.L79;
  
  return fibo;
}

bool IsPriceInOTE(FibonacciLevels fibo, double price) {
  return (price >= fibo.ote_zone.low && price <= fibo.ote_zone.high);
}
```

### –ê–õ–ì–û–†–ò–¢–ú 6: Confluence Calculation (–§–ò–ù–ê–õ–¨–ù–ê–Ø –í–ï–†–°–ò–Ø)

```cpp
ConfluenceData CalculateConfluence(Setup setup, SessionInfo session, OrderBlock ob, SweepData sweep) {
  ConfluenceData conf;
  conf.total_score = 0;
  ArrayResize(conf.factors_list, 0);
  
  // –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–í–ï–†–ö–ò
  if (!setup.has_bms) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No BMS";
    return conf;
  }
  
  if (!setup.has_stop_hunt && !setup.has_sms) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No SH or SMS";
    return conf;
  }
  
  if (!setup.has_order_block) {
    conf.total_score = 0;
    conf.quality_rating = "INVALID - No OB";
    return conf;
  }
  
  // –ë–ê–ó–û–í–´–ï –§–ê–ö–¢–û–†–´ (65%)
  conf.total_score += 25.0;  // BMS
  ArrayPush(conf.factors_list, "BMS confirmed (25%)");
  
  if (setup.has_stop_hunt) {
    conf.total_score += 20.0;
    ArrayPush(conf.factors_list, "Stop Hunt (20%)");
    
    // Adjustment –∑–∞ sweep validity
    if (sweep.validity == SWEEP_STRONG) {
      conf.sweep_validity_adj = 5.0;
      conf.total_score += 5.0;
      ArrayPush(conf.factors_list, "Strong sweep +5%");
    } else if (sweep.validity == SWEEP_WEAK) {
      conf.sweep_validity_adj = -10.0;
      conf.total_score -= 10.0;
      ArrayPush(conf.factors_list, "Weak sweep -10%");
    }
  } else if (setup.has_sms) {
    conf.total_score += 20.0;
    ArrayPush(conf.factors_list, "SMS Failure Swing (20%)");
  }
  
  conf.total_score += 20.0;  // RTO
  ArrayPush(conf.factors_list, "RTO to Order Block (20%)");
  
  // OB Mitigation Adjustment
  if (ob.mitigation_count > 0) {
    double adj = ob.GetConfluenceAdjustment();
    conf.ob_mitigation_adj = adj;
    conf.total_score += adj;
    if (adj < 0) {
      ArrayPush(conf.factors_list, StringFormat("OB mitigation penalty (%.0f%%)", adj));
    }
  }
  
  // SESSION (15-20%)
  conf.session = session.type;
  
  if (session.type == SESSION_DEAD_ZONE || session.type == SESSION_ASIAN) {
    conf.session_valid = false;
    conf.quality_rating = "INVALID - Wrong session";
    return conf;
  }
  
  conf.session_valid = true;
  double session_weight = 15.0;
  
  if (session.type == SESSION_LONDON_NY_OVERLAP) {
    session_weight = 20.0;  // –ë–û–ù–£–° –¥–ª—è Overlap!
    ArrayPush(conf.factors_list, "London-NY Overlap (20%)");
  } else if (session.type == SESSION_LONDON_PRIME || session.type == SESSION_NY_PRIME) {
    ArrayPush(conf.factors_list, "Prime session (15%)");
  } else {
    session_weight = 8.0;  // Late sessions
    ArrayPush(conf.factors_list, "Late session (8%)");
  }
  
  conf.total_score += session_weight;
  
  // –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –§–ê–ö–¢–û–†–´ (20%)
  if (setup.in_fibonacci_ote) {
    conf.total_score += 4.0;
    conf.in_fibonacci_ote = true;
    ArrayPush(conf.factors_list, "Fibonacci OTE (4%)");
  }
  
  if (setup.htf_aligned) {
    conf.total_score += 4.0;
    conf.htf_aligned = true;
    ArrayPush(conf.factors_list, "HTF alignment (4%)");
  }
  
  if (setup.high_impact_news) {
    conf.total_score += 4.0;
    conf.high_impact_news = true;
    ArrayPush(conf.factors_list, "High Impact News (4%)");
  }
  
  if (setup.amd_pattern) {
    conf.total_score += 4.0;
    conf.amd_pattern = true;
    ArrayPush(conf.factors_list, "AMD Pattern (4%)");
  }
  
  if (setup.htf_order_block) {
    conf.total_score += 4.0;
    conf.htf_order_block = true;
    ArrayPush(conf.factors_list, "HTF Order Block (4%)");
  }
  
  // CAP –Ω–∞ 100%
  if (conf.total_score > 100) {
    conf.total_score = 100;
  }
  
  // –†–ï–ô–¢–ò–ù–ì
  if (conf.total_score >= 95) {
    conf.quality_rating = "EXCELLENT ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 90) {
    conf.quality_rating = "EXCELLENT ‚≠ê‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 85) {
    conf.quality_rating = "VERY GOOD ‚≠ê‚≠ê‚≠ê";
  } else if (conf.total_score >= 80) {
    conf.quality_rating = "GOOD ‚≠ê‚≠ê";
  } else if (conf.total_score >= 70) {
    conf.quality_rating = "ACCEPTABLE ‚≠ê";
  } else {
    conf.quality_rating = "POOR";
  }
  
  return conf;
}
```

---

## üì¶ –°–¢–†–£–ö–¢–£–†–´ –î–ê–ù–ù–´–• {#—Å—Ç—Ä—É–∫—Ç—É—Ä—ã-–¥–∞–Ω–Ω—ã—Ö}

### Common.mqh - –ü–æ–ª–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```cpp
//+------------------------------------------------------------------+
//| Common.mqh - –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –∞—É–¥–∏—Ç–∞                       |
//+------------------------------------------------------------------+

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ENUMS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

enum ENUM_SESSION_TYPE {
  SESSION_DEAD_ZONE,
  SESSION_ASIAN,
  SESSION_LONDON_PRIME,
  SESSION_LONDON_LATE,
  SESSION_NY_PRIME,
  SESSION_NY_LATE,
  SESSION_LONDON_NY_OVERLAP  // –û—Å–æ–±–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å!
};

enum ENUM_OB_TYPE {
  OB_BULLISH,
  OB_BEARISH
};

enum ENUM_OB_STATUS {
  OB_ACTIVE,
  OB_MITIGATED_ONCE,
  OB_MITIGATED_TWICE,
  OB_WEAK,
  OB_VIOLATED
};

enum ENUM_BMS_TYPE {
  BMS_BULLISH,
  BMS_BEARISH
};

enum ENUM_SWING_TYPE {
  SWING_HIGH,
  SWING_LOW
};

enum ENUM_LIQUIDITY_TYPE {
  LIQUIDITY_BSL,  // Buy Stops Liquidity
  LIQUIDITY_SSL   // Sell Stops Liquidity
};

enum ENUM_ASIAN_QUALITY {
  ASIAN_EXCELLENT,  // 80-100
  ASIAN_GOOD,       // 60-79
  ASIAN_ACCEPTABLE, // 40-59
  ASIAN_WEAK        // < 40
};

enum ENUM_SWEEP_VALIDITY {
  SWEEP_STRONG,     // 3+ bars holding
  SWEEP_GOOD,       // 2 bars
  SWEEP_WEAK,       // 1 bar
  SWEEP_INVALID
};

enum ENUM_TREND_DIRECTION {
  TREND_BULLISH,
  TREND_BEARISH,
  TREND_RANGING
};

enum ENUM_AMD_DIRECTION {
  AMD_UP,
  AMD_DOWN,
  AMD_NONE
};

enum ENUM_SETUP_TYPE {
  SETUP_TURTLE_SOUP,
  SETUP_SH_BMS_RTO,
  SETUP_SMS_BMS_RTO,
  SETUP_AMD
};

enum ENUM_SETUP_STATUS {
  SETUP_READY,      // –¶–µ–Ω–∞ –≤ entry zone
  SETUP_WAITING,    // –ñ–¥–µ–º RTO
  SETUP_EXPIRED     // Setup –∏—Å—Ç–µ–∫
};

enum ENUM_MITIGATION_ACTION {
  MITIGATION_NO_CHANGE,
  MITIGATION_TOUCHED,
  MITIGATION_SAME_TOUCH,
  MITIGATION_INVALIDATED
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STRUCTURES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

struct SwingPoint {
  datetime time;
  double price;
  int bar_index;
  ENUM_SWING_TYPE type;
  int strength;  // –°–∫–æ–ª—å–∫–æ –±–∞—Ä–æ–≤ —Å–ª–µ–≤–∞/—Å–ø—Ä–∞–≤–∞ –ø—Ä–æ–≤–µ—Ä—è–ª–æ—Å—å
};

struct BMS {
  datetime time;
  double price;
  int bar_index;
  ENUM_BMS_TYPE type;
  SwingPoint swing_ref;  // Swing –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –ø—Ä–æ–±–∏—Ç
};

struct SMS {
  datetime time;
  double failed_price;    // –¶–µ–Ω–∞ –∫–æ—Ç–æ—Ä—É—é –Ω–µ —Å–º–æ–≥–ª–∏ –ø—Ä–æ–±–∏—Ç—å
  double reversal_price;  // –¶–µ–Ω–∞ –≥–¥–µ –ø—Ä–æ–∏–∑–æ—à–µ–ª —Ä–∞–∑–≤–æ—Ä–æ—Ç
  int bar_index;
  ENUM_BMS_TYPE expected_direction;  // –û–∂–∏–¥–∞–µ–º–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ SMS
};

struct LiquidityZone {
  double price;
  ENUM_LIQUIDITY_TYPE type;
  string name;  // "PDH", "HOD", "Equal Highs", etc
  int importance;  // 1-10
  datetime created_time;
  bool swept;
  datetime swept_time;
};

struct SweepData {
  datetime time;
  double zone_price;
  double sweep_price;
  double distance_pips;
  ENUM_LIQUIDITY_TYPE type;
  
  // Holding time validation
  int holding_bars;
  ENUM_SWEEP_VALIDITY validity;
  
  // Volume data
  double volume;
  double avg_volume;
  double volume_ratio;
  bool volume_mandatory;
  
  // Return data
  int return_bars;
  double return_price;
  
  // Context
  ENUM_SESSION_TYPE session;
  bool is_news_time;
  
  // Validation
  bool valid;
  string invalid_reason;
  
  // Methods
  double GetConfidenceAdjustment() {
    if (validity == SWEEP_STRONG) return 5.0;
    if (validity == SWEEP_WEAK) return -10.0;
    return 0.0;
  }
};

struct OrderBlock {
  datetime time;
  double high;
  double low;
  int bar_index;
  ENUM_OB_TYPE type;
  
  struct {
    datetime time;
    double price;
  } bms_ref;
  
  // Impulse data –¥–ª—è Fibonacci
  int impulse_start_bar;
  double impulse_start_price;
  double impulse_end_price;
  
  // Fibonacci data (—Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è —Å—Ä–∞–∑—É)
  FibonacciLevels fibonacci_data;
  struct {
    double high;
    double low;
  } ote_zone;
  
  // Mitigation tracking
  ENUM_OB_STATUS status;
  int mitigation_count;
  datetime last_mitigation_time;
  double mitigation_prices[];
  
  // Validation
  bool valid;
  string note;
  string invalid_reason;
  
  // Methods
  double GetConfluenceAdjustment() {
    if (mitigation_count == 0 || mitigation_count == 1) return 0.0;
    if (mitigation_count == 2) return -5.0;
    if (mitigation_count >= 3) return -15.0;
    return 0.0;
  }
};

struct FibonacciLevels {
  double impulse_start;
  double impulse_end;
  double range;
  
  double L0;
  double L236;
  double L382;
  double L50;
  double L618;
  double L705;
  double L79;
  double L886;
  double L100;
  
  struct {
    double high;
    double low;
  } ote_zone;
  
  // Methods
  bool IsPriceInOTE(double price) {
    return (price >= ote_zone.low && price <= ote_zone.high);
  }
  
  double GetClosestLevel(double price) {
    double levels[] = {L0, L236, L382, L50, L618, L705, L79, L886, L100};
    double min_distance = DBL_MAX;
    double closest = 0;
    
    for (int i = 0; i < 9; i++) {
      double dist = MathAbs(price - levels[i]);
      if (dist < min_distance) {
        min_distance = dist;
        closest = levels[i];
      }
    }
    return closest;
  }
};

struct AsianRange {
  datetime start_time;
  datetime end_time;
  double high;
  double low;
  double size_pips;
  
  // Quality metrics
  int touches_high;
  int touches_low;
  int wicks_above;
  int wicks_below;
  double flat_ratio;
  int quality_score;  // 0-100
  ENUM_ASIAN_QUALITY quality_rating;
  
  bool IsValid() {
    return (quality_score >= 40);
  }
  
  string GetQualityText() {
    switch(quality_rating) {
      case ASIAN_EXCELLENT: return "EXCELLENT";
      case ASIAN_GOOD: return "GOOD";
      case ASIAN_ACCEPTABLE: return "ACCEPTABLE";
      case ASIAN_WEAK: return "WEAK";
    }
    return "UNKNOWN";
  }
};

struct AMD_Pattern {
  bool valid;
  
  // Phase A
  AsianRange accumulation_zone;
  
  // Phase M
  ENUM_AMD_DIRECTION manipulation_direction;
  double manipulation_price;
  bool manipulation_confirmed;
  LiquidityZone swept_liquidity[];
  
  // Phase D
  ENUM_AMD_DIRECTION expected_distribution_direction;  // –ü—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ M!
  bool distribution_confirmed;
  BMS distribution_bms;
};

struct SessionInfo {
  ENUM_SESSION_TYPE type;
  int importance;  // 0-10
  double confluence_weight;
  string description;
};

struct Setup {
  int id;  // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
  ENUM_SETUP_TYPE type;
  ENUM_TREND_DIRECTION direction;
  
  // Entry data
  double entry_price;
  double entry_min;
  double entry_max;
  double stop_loss;
  double take_profit;
  
  // References
  BMS bms_ref;
  SweepData sweep_ref;
  SMS sms_ref;
  OrderBlock ob_ref;
  
  // Confluence factors
  bool has_bms;
  bool has_stop_hunt;
  bool has_sms;
  bool has_order_block;
  bool in_fibonacci_ote;
  bool htf_aligned;
  bool high_impact_news;
  bool amd_pattern;
  bool htf_order_block;
  
  // Confluence result
  double confluence_score;
  string confluence_rating;
  string confluence_factors[];
  
  // Status
  ENUM_SETUP_STATUS status;
  ENUM_SESSION_TYPE session;
  datetime created_time;
  int bars_waiting;
};

struct ConfluenceData {
  // –§–∞–∫—Ç–æ—Ä—ã
  bool has_bms;
  bool has_stop_hunt;
  bool has_sms;
  bool has_order_block;
  bool in_fibonacci_ote;
  bool htf_aligned;
  bool high_impact_news;
  bool amd_pattern;
  bool htf_order_block;
  
  // Session
  ENUM_SESSION_TYPE session;
  bool session_valid;
  
  // Adjustments
  double ob_mitigation_adj;
  double sweep_validity_adj;
  
  // Result
  double total_score;
  string quality_rating;
  string factors_list[];
  
  // Weights (constants)
  const double WEIGHT_BMS = 25.0;
  const double WEIGHT_SH_SMS = 20.0;
  const double WEIGHT_OB = 20.0;
  const double WEIGHT_SESSION = 15.0;
  const double WEIGHT_SESSION_OVERLAP = 20.0;
  const double WEIGHT_OTE = 4.0;
  const double WEIGHT_HTF = 4.0;
  const double WEIGHT_NEWS = 4.0;
  const double WEIGHT_AMD = 4.0;
  const double WEIGHT_HTF_OB = 4.0;
};

struct MitigationResult {
  ENUM_MITIGATION_ACTION action;
  int mitigation_count;
  double penetration_depth;
  double confluence_adjustment;
  string recommendation;
};

struct OBSizeLimits {
  double min_size;
  double max_size;
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

template<typename T>
void ArrayPush(T &arr[], T value) {
  int size = ArraySize(arr);
  ArrayResize(arr, size + 1);
  arr[size] = value;
}

OBSizeLimits GetOBLimits(string symbol, ENUM_TIMEFRAMES tf) {
  OBSizeLimits limits;
  
  bool is_forex = (StringFind(symbol, "USD") >= 0 || 
                   StringFind(symbol, "EUR") >= 0 ||
                   StringFind(symbol, "GBP") >= 0);
  
  bool is_gold = (StringFind(symbol, "XAU") >= 0 || 
                  StringFind(symbol, "GOLD") >= 0);
  
  bool is_index = (StringFind(symbol, "NAS") >= 0 || 
                   StringFind(symbol, "US500") >= 0);
  
  if (is_forex) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15:
        limits.min_size = 3;
        limits.max_size = 20;
        break;
      case PERIOD_M30:
        limits.min_size = 4;
        limits.max_size = 30;
        break;
      case PERIOD_H1:
        limits.min_size = 5;
        limits.max_size = 40;
        break;
      case PERIOD_H4:
        limits.min_size = 10;
        limits.max_size = 80;
        break;
      case PERIOD_D1:
        limits.min_size = 20;
        limits.max_size = 150;
        break;
      default:
        limits.min_size = 30;
        limits.max_size = 300;
        break;
    }
  } else if (is_gold) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15:
        limits.min_size = 30;
        limits.max_size = 200;
        break;
      case PERIOD_M30:
        limits.min_size = 40;
        limits.max_size = 300;
        break;
      case PERIOD_H1:
        limits.min_size = 50;
        limits.max_size = 400;
        break;
      case PERIOD_H4:
        limits.min_size = 100;
        limits.max_size = 800;
        break;
      default:
        limits.min_size = 200;
        limits.max_size = 1500;
        break;
    }
  } else if (is_index) {
    switch(tf) {
      case PERIOD_M5:
      case PERIOD_M15:
        limits.min_size = 10;
        limits.max_size = 100;
        break;
      case PERIOD_M30:
        limits.min_size = 15;
        limits.max_size = 150;
        break;
      case PERIOD_H1:
        limits.min_size = 20;
        limits.max_size = 200;
        break;
      case PERIOD_H4:
        limits.min_size = 50;
        limits.max_size = 400;
        break;
      default:
        limits.min_size = 100;
        limits.max_size = 800;
        break;
    }
  } else {
    limits.min_size = 5;
    limits.max_size = 50;
  }
  
  return limits;
}
```

---

## üìÖ –ü–õ–ê–ù –†–ê–ó–†–ê–ë–û–¢–ö–ò –ü–û –§–ê–ó–ê–ú {#–ø–ª–∞–Ω-—Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏}

### PHASE 1: –§—É–Ω–¥–∞–º–µ–Ω—Ç (–ù–µ–¥–µ–ª–∏ 1-2)

```
WEEK 1: Core Infrastructure
‚îú‚îÄ Common.mqh
‚îÇ  ‚îú‚îÄ –í—Å–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö ‚úì
‚îÇ  ‚îú‚îÄ Enums –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è ‚úì
‚îÇ  ‚îî‚îÄ Helper functions ‚úì
‚îÇ
‚îú‚îÄ MODULE 0A: BrokerTimeDetector.mqh
‚îÇ  ‚îú‚îÄ DetectBrokerGMTOffset()
‚îÇ  ‚îú‚îÄ IsDSTActiveEU() —Å —Ç–æ—á–Ω—ã–º–∏ –¥–∞—Ç–∞–º–∏
‚îÇ  ‚îú‚îÄ GetLastSundayOfMonth()
‚îÇ  ‚îú‚îÄ GetOffsetToMSK() —É–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
‚îÇ  ‚îú‚îÄ ValidateDetection() cross-check
‚îÇ  ‚îî‚îÄ ShowTimeDebugPanel()
‚îÇ
‚îî‚îÄ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:
   ‚îú‚îÄ –ó–∏–º–Ω–µ–µ –≤—Ä–µ–º—è (—è–Ω–≤–∞—Ä—å): GMT+2, offset +1
   ‚îú‚îÄ –õ–µ—Ç–Ω–µ–µ –≤—Ä–µ–º—è (–∏—é–ª—å): GMT+3, offset 0
   ‚îî‚îÄ DST –ø–µ—Ä–µ—Ö–æ–¥—ã (30 –º–∞—Ä—Ç–∞, 26 –æ–∫—Ç—è–±—Ä—è)

WEEK 2: Time Management
‚îú‚îÄ MODULE 0B: TimeZoneManager.mqh
‚îÇ  ‚îú‚îÄ ConvertBrokerToMSK(hour)
‚îÇ  ‚îú‚îÄ ConvertMSKToBroker(hour)
‚îÇ  ‚îú‚îÄ GetCurrentMSKTime()
‚îÇ  ‚îî‚îÄ GetCurrentSession() wrapper
‚îÇ
‚îî‚îÄ Integration Testing:
   ‚îú‚îÄ –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ—Å—Å–∏–π (Asian, London, NY, Overlap)
   ‚îú‚îÄ Session timing –≤ MSK
   ‚îî‚îÄ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ç–µ—Å—Ç—ã (TestSessionDetection())
```

### PHASE 2: Market Analysis Core (–ù–µ–¥–µ–ª–∏ 3-4)

```
WEEK 3: Sessions & Structure
‚îú‚îÄ MODULE 2A: Sessions.mqh [–ü–ï–†–ï–ú–ï–©–ï–ù –†–ê–ù–¨–®–ï!]
‚îÇ  ‚îú‚îÄ GetCurrentSession() —Å Overlap –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
‚îÇ  ‚îú‚îÄ GetAsianRange()
‚îÇ  ‚îÇ  ‚îú‚îÄ –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ boundaries
‚îÇ  ‚îÇ  ‚îú‚îÄ –ü–æ–¥—Å—á–µ—Ç touches/wicks
‚îÇ  ‚îÇ  ‚îî‚îÄ Quality scoring
‚îÇ  ‚îú‚îÄ ValidateAsianRangeQuality()
‚îÇ  ‚îú‚îÄ DetectAMD() –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê
‚îÇ  ‚îÇ  ‚îî‚îÄ Manipulation –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–∞ Distribution!
‚îÇ  ‚îî‚îÄ IsLondonNYOverlap()
‚îÇ
‚îú‚îÄ MODULE 1: MarketStructure.mqh
‚îÇ  ‚îú‚îÄ DetectSwingPoints(strength)
‚îÇ  ‚îú‚îÄ DetectBMS() ‚Üí –ø—Ä–æ–≤–µ—Ä–∫–∞ Close, –Ω–µ High/Low
‚îÇ  ‚îú‚îÄ DetectSMS()
‚îÇ  ‚îî‚îÄ GetHTFTrend(timeframe) –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ Swing detection –Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏
   ‚îú‚îÄ BMS validation (Close vs High/Low)
   ‚îú‚îÄ Asian Range quality –Ω–∞ –ø—Ä–∏–º–µ—Ä–∞—Ö
   ‚îî‚îÄ AMD pattern detection

WEEK 4: Advanced Market Structure
‚îú‚îÄ HTF Analysis Integration
‚îÇ  ‚îú‚îÄ Multi-timeframe swing detection
‚îÇ  ‚îú‚îÄ HTF trend alignment check
‚îÇ  ‚îî‚îÄ HTF Order Block detection
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ HTF vs LTF consistency
   ‚îî‚îÄ Trend direction validation
```

### PHASE 3: Liquidity & Order Blocks (–ù–µ–¥–µ–ª–∏ 5-7)

```
WEEK 5: Liquidity Detection
‚îú‚îÄ MODULE 2B: Liquidity.mqh
‚îÇ  ‚îú‚îÄ FindBSL() / FindSSL()
‚îÇ  ‚îÇ  ‚îú‚îÄ PDH, PWH, PMH
‚îÇ  ‚îÇ  ‚îú‚îÄ HOD, LOD
‚îÇ  ‚îÇ  ‚îî‚îÄ Old highs/lows
‚îÇ  ‚îú‚îÄ FindEqualHighsLows()
‚îÇ  ‚îÇ  ‚îî‚îÄ Timeframe-dependent threshold!
‚îÇ  ‚îú‚îÄ DetectSweep()
‚îÇ  ‚îÇ  ‚îú‚îÄ Distance validation
‚îÇ  ‚îÇ  ‚îú‚îÄ Holding time check –ù–û–í–û–ï
‚îÇ  ‚îÇ  ‚îú‚îÄ Volume check (MANDATORY –¥–ª—è News)
‚îÇ  ‚îÇ  ‚îî‚îÄ Return validation
‚îÇ  ‚îî‚îÄ ValidateSweepHoldingTime()
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ Equal Highs –Ω–∞ —Ä–∞–∑–Ω—ã—Ö TF (M15, H1, H4)
   ‚îú‚îÄ Sweep validation —Å/–±–µ–∑ volume
   ‚îú‚îÄ Holding time scenarios (1, 2, 3+ bars)
   ‚îî‚îÄ News sweep vs normal sweep

WEEK 6: Order Block Detection
‚îú‚îÄ MODULE 3: OrderBlocks.mqh
‚îÇ  ‚îú‚îÄ DetectBullishOB()
‚îÇ  ‚îÇ  ‚îú‚îÄ –¢–æ—á–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ impulse_start
‚îÇ  ‚îÇ  ‚îú‚îÄ –ü–æ–∏—Å–∫ –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–æ–π —Å–≤–µ—á–∏
‚îÇ  ‚îÇ  ‚îú‚îÄ Fallback –¥–ª—è strong impulses
‚îÇ  ‚îÇ  ‚îî‚îÄ –†–∞–∑–º–µ—Ä validation
‚îÇ  ‚îú‚îÄ DetectBearishOB()
‚îÇ  ‚îú‚îÄ ValidateOB()
‚îÇ  ‚îú‚îÄ CheckMitigation() –ù–û–í–ê–Ø –§–£–ù–ö–¶–ò–Ø
‚îÇ  ‚îÇ  ‚îú‚îÄ Touch detection
‚îÇ  ‚îÇ  ‚îú‚îÄ Violation detection
‚îÇ  ‚îÇ  ‚îî‚îÄ Confluence adjustment
‚îÇ  ‚îî‚îÄ TrackMitigationCount()
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ OB detection –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –∏–º–ø—É–ª—å—Å–∞—Ö
   ‚îú‚îÄ Fallback scenarios (no opposite candles)
   ‚îú‚îÄ Mitigation tracking (1st, 2nd, 3rd touch)
   ‚îî‚îÄ Size validation

WEEK 7: Fibonacci Integration
‚îú‚îÄ MODULE 4: Fibonacci.mqh
‚îÇ  ‚îú‚îÄ Calculate(OrderBlock)
‚îÇ  ‚îÇ  ‚îî‚îÄ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç impulse_start/end –∏–∑ OB
‚îÇ  ‚îú‚îÄ GetOTEZone()
‚îÇ  ‚îî‚îÄ IsPriceInOTE()
‚îÇ
‚îî‚îÄ Integration:
   ‚îú‚îÄ Fibonacci —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –°–†–ê–ó–£ –ø–æ—Å–ª–µ OB creation
   ‚îú‚îÄ OTE zone —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ OB —Å—Ç—Ä—É–∫—Ç—É—Ä–µ
   ‚îî‚îÄ Testing –Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏
```

### PHASE 4: Setup Detection (–ù–µ–¥–µ–ª–∏ 8-9)

```
WEEK 8: Setup Scanner
‚îú‚îÄ MODULE 5: SetupScanner.mqh
‚îÇ  ‚îú‚îÄ ScanTurtleSoup()
‚îÇ  ‚îÇ  ‚îú‚îÄ Sweep detection
‚îÇ  ‚îÇ  ‚îú‚îÄ Holding time validation
‚îÇ  ‚îÇ  ‚îî‚îÄ Entry zone –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
‚îÇ  ‚îú‚îÄ ScanSH_BMS_RTO()
‚îÇ  ‚îÇ  ‚îú‚îÄ Sweep + BMS combo
‚îÇ  ‚îÇ  ‚îú‚îÄ RTO validation
‚îÇ  ‚îÇ  ‚îî‚îÄ HTF filter check –ù–û–í–û–ï
‚îÇ  ‚îú‚îÄ ScanSMS_BMS_RTO()
‚îÇ  ‚îÇ  ‚îî‚îÄ SMS + BMS + RTO combo
‚îÇ  ‚îî‚îÄ ScanAMD()
‚îÇ     ‚îî‚îÄ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ context filter
‚îÇ
‚îú‚îÄ HTF Filter Implementation
‚îÇ  ‚îî‚îÄ –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã—Ö setups
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ –ö–∞–∂–¥—ã–π —Ç–∏–ø setup –æ—Ç–¥–µ–ª—å–Ω–æ
   ‚îú‚îÄ HTF filter validation
   ‚îî‚îÄ Multiple setups –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ

WEEK 9: Confluence System
‚îú‚îÄ MODULE 6: ConfluenceCalculator.mqh
‚îÇ  ‚îú‚îÄ CalculateConfluence()
‚îÇ  ‚îÇ  ‚îú‚îÄ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ (BMS, SH/SMS, OB)
‚îÇ  ‚îÇ  ‚îú‚îÄ Session weight (15% –∏–ª–∏ 20% –¥–ª—è Overlap)
‚îÇ  ‚îÇ  ‚îú‚îÄ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã (20%)
‚îÇ  ‚îÇ  ‚îú‚îÄ Adjustments (OB mitigation, sweep validity)
‚îÇ  ‚îÇ  ‚îî‚îÄ Cap –Ω–∞ 100%
‚îÇ  ‚îú‚îÄ Quality rating –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ
‚îÇ  ‚îî‚îÄ Factors breakdown
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ –í—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ —Ñ–∞–∫—Ç–æ—Ä–æ–≤
   ‚îú‚îÄ Edge cases (max/min confluence)
   ‚îú‚îÄ Adjustments validation
   ‚îî‚îÄ –í–µ—Å–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ (—Å—É–º–º–∞ = 100%)
```

### PHASE 5: Auxiliary Modules (–ù–µ–¥–µ–ª–∏ 10-11)

```
WEEK 10: Optional Modules
‚îú‚îÄ MODULE 7: RiskManager.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ  ‚îú‚îÄ CalculateLotSize(sl_pips, risk_percent, balance)
‚îÇ  ‚îú‚îÄ CalculateRiskReward(entry, sl, tp)
‚îÇ  ‚îî‚îÄ ValidateRiskParameters()
‚îÇ
‚îú‚îÄ MODULE 8: NewsCalendar.mqh [–û–ü–¶–ò–û–ù–ê–õ–¨–ù–´–ô]
‚îÇ  ‚îú‚îÄ MANUAL mode (inputs)
‚îÇ  ‚îÇ  ‚îî‚îÄ –†—É—á–Ω–æ–π –≤–≤–æ–¥ —Å–æ–±—ã—Ç–∏–π –∏ –≤—Ä–µ–º–µ–Ω–∏
‚îÇ  ‚îú‚îÄ DISABLED mode (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)
‚îÇ  ‚îî‚îÄ VOLATILITY mode (–ø–æ ATR)
‚îÇ     ‚îî‚îÄ –ê–≤—Ç–æ-–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ high volatility periods
‚îÇ
‚îî‚îÄ MODULE 9: Logger.mqh
   ‚îú‚îÄ LogInfo()
   ‚îú‚îÄ LogWarning()
   ‚îú‚îÄ LogError()
   ‚îî‚îÄ LogDebug()

WEEK 11: Dashboard
‚îú‚îÄ MODULE 10: Dashboard.mqh
‚îÇ  ‚îú‚îÄ DrawDashboard()
‚îÇ  ‚îÇ  ‚îú‚îÄ Background panel
‚îÇ  ‚îÇ  ‚îú‚îÄ All sections (Time, Structure, Liquidity, Setups, Stats)
‚îÇ  ‚îÇ  ‚îî‚îÄ Responsive layout
‚îÇ  ‚îú‚îÄ UpdateRealtime()
‚îÇ  ‚îÇ  ‚îú‚îÄ Time section –∫–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
‚îÇ  ‚îÇ  ‚îú‚îÄ Structure –Ω–∞ –Ω–æ–≤–æ–º –±–∞—Ä–µ
‚îÇ  ‚îÇ  ‚îî‚îÄ Setups –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
‚îÇ  ‚îú‚îÄ ShowActiveSetups()
‚îÇ  ‚îÇ  ‚îú‚îÄ Top N setups –ø–æ confluence
‚îÇ  ‚îÇ  ‚îú‚îÄ Status indicators (üü¢üü°üî¥)
‚îÇ  ‚îÇ  ‚îî‚îÄ Confluence breakdown
‚îÇ  ‚îî‚îÄ Performance optimization
‚îÇ     ‚îú‚îÄ Lazy rendering
‚îÇ     ‚îî‚îÄ Update throttling
‚îÇ
‚îî‚îÄ Testing:
   ‚îú‚îÄ –í–∏–∑—É–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Å–µ–∫—Ü–∏–π
   ‚îú‚îÄ Real-time updates
   ‚îî‚îÄ Performance (< 10ms –Ω–∞ redraw)
```

### PHASE 6: Integration & Testing (–ù–µ–¥–µ–ª–∏ 12-13)

```
WEEK 12: Full Integration
‚îú‚îÄ SMC_Master.mq5
‚îÇ  ‚îú‚îÄ OnInit() - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π
‚îÇ  ‚îú‚îÄ OnCalculate() - –≥–ª–∞–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 1: Context (Time, Session)
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 2: Structure (Swings, BMS, SMS)
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 3: Liquidity (BSL/SSL, Sweeps)
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 4: Order Blocks + Fibonacci
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 5: Setup Scan
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 6: Confluence calculation
‚îÇ  ‚îÇ  ‚îú‚îÄ PHASE 7: Filter –ø–æ min confluence
‚îÇ  ‚îÇ  ‚îî‚îÄ PHASE 8: Dashboard update
‚îÇ  ‚îî‚îÄ OnDeinit() - cleanup
‚îÇ
‚îú‚îÄ Inputs Organization
‚îÇ  ‚îú‚îÄ Time Settings
‚îÇ  ‚îú‚îÄ Session Settings
‚îÇ  ‚îú‚îÄ Market Structure Settings
‚îÇ  ‚îú‚îÄ Liquidity Settings
‚îÇ  ‚îú‚îÄ Order Block Settings
‚îÇ  ‚îú‚îÄ Confluence Settings
‚îÇ  ‚îú‚îÄ Dashboard Settings
‚îÇ  ‚îî‚îÄ Risk Settings (optional)
‚îÇ
‚îî‚îÄ Memory Management
   ‚îú‚îÄ ArrayFree() –¥–ª—è dynamic arrays
   ‚îî‚îÄ Static arrays –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ

WEEK 13: Comprehensive Testing
‚îú‚îÄ Automated Tests
‚îÇ  ‚îú‚îÄ Time detection tests
‚îÇ  ‚îú‚îÄ Session detection tests
‚îÇ  ‚îú‚îÄ BMS detection tests
‚îÇ  ‚îú‚îÄ OB detection tests
‚îÇ  ‚îú‚îÄ Confluence calculation tests
‚îÇ  ‚îî‚îÄ Edge cases
‚îÇ
‚îú‚îÄ Manual Testing
‚îÇ  ‚îú‚îÄ Historical data (back-test)
‚îÇ  ‚îú‚îÄ Live market conditions
‚îÇ  ‚îú‚îÄ Multiple symbols (EUR/USD, Gold, Indices)
‚îÇ  ‚îî‚îÄ Multiple timeframes (M15, H1, H4)
‚îÇ
‚îî‚îÄ Performance Testing
   ‚îú‚îÄ CPU usage
   ‚îú‚îÄ Memory usage
   ‚îú‚îÄ Indicator loading time
   ‚îî‚îÄ Optimization opportunities
```

### PHASE 7: Documentation & Release (–ù–µ–¥–µ–ª—è 14)

```
WEEK 14: Finalization
‚îú‚îÄ User Manual
‚îÇ  ‚îú‚îÄ Installation guide
‚îÇ  ‚îú‚îÄ Setup & configuration
‚îÇ  ‚îú‚îÄ Trading concepts explained
‚îÇ  ‚îú‚îÄ Dashboard guide
‚îÇ  ‚îú‚îÄ Risk management guidelines
‚îÇ  ‚îî‚îÄ Troubleshooting
‚îÇ
‚îú‚îÄ Code Documentation
‚îÇ  ‚îú‚îÄ Comments –¥–ª—è –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π
‚îÇ  ‚îú‚îÄ Module dependencies diagram
‚îÇ  ‚îî‚îÄ Architecture overview
‚îÇ
‚îú‚îÄ Final Testing
‚îÇ  ‚îú‚îÄ Beta testing (2-3 users)
‚îÇ  ‚îú‚îÄ Bug fixes
‚îÇ  ‚îî‚îÄ Performance tuning
‚îÇ
‚îî‚îÄ Release Preparation
   ‚îú‚îÄ Version 1.0 package
   ‚îú‚îÄ Release notes
   ‚îî‚îÄ Support channels setup
```

---

## ‚úÖ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï {#—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ}

### –û–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Ç–µ—Å—Ç—ã –ø–µ—Ä–µ–¥ —Ä–µ–ª–∏–∑–æ–º

```cpp
//+------------------------------------------------------------------+
//| Test Suite –¥–ª—è SMC –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞                                   |
//+------------------------------------------------------------------+

void RunAllTests() {
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Print("Starting SMC Indicator Test Suite");
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  
  int total_tests = 0;
  int passed_tests = 0;
  
  // TIME TESTS
  if (TestTimeDetection()) passed_tests++;
  total_tests++;
  
  if (TestDSTTransitions()) passed_tests++;
  total_tests++;
  
  if (TestSessionDetection()) passed_tests++;
  total_tests++;
  
  // STRUCTURE TESTS
  if (TestBMSDetection()) passed_tests++;
  total_tests++;
  
  if (TestSMSDetection()) passed_tests++;
  total_tests++;
  
  if (TestHTFTrendDetection()) passed_tests++;
  total_tests++;
  
  // LIQUIDITY TESTS
  if (TestEqualHighsThreshold()) passed_tests++;
  total_tests++;
  
  if (TestSweepDetection()) passed_tests++;
  total_tests++;
  
  if (TestSweepVolumeCheck()) passed_tests++;
  total_tests++;
  
  // ORDER BLOCK TESTS
  if (TestOrderBlockDetection()) passed_tests++;
  total_tests++;
  
  if (TestOrderBlockMitigation()) passed_tests++;
  total_tests++;
  
  if (TestOrderBlockFallback()) passed_tests++;
  total_tests++;
  
  // FIBONACCI TESTS
  if (TestFibonacciCalculation()) passed_tests++;
  total_tests++;
  
  if (TestOTEZone()) passed_tests++;
  total_tests++;
  
  // CONFLUENCE TESTS
  if (TestConfluenceWeights()) passed_tests++;
  total_tests++;
  
  if (TestConfluenceAdjustments()) passed_tests++;
  total_tests++;
  
  if (TestConfluenceCap()) passed_tests++;
  total_tests++;
  
  // AMD TESTS
  if (TestAMDManipulationDirection()) passed_tests++;
  total_tests++;
  
  // DASHBOARD TESTS
  if (TestDashboardPerformance()) passed_tests++;
  total_tests++;
  
  // RESULTS
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Print("Test Results: ", passed_tests, "/", total_tests, " passed");
  double success_rate = (double)passed_tests / total_tests * 100;
  Print("Success Rate: ", DoubleToString(success_rate, 1), "%");
  Print("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  
  if (passed_tests == total_tests) {
    Print("‚úÖ ALL TESTS PASSED! Ready for release.");
  } else {
    Print("‚ùå SOME TESTS FAILED! Review logs.");
  }
}

//+------------------------------------------------------------------+
//| TEST 1: Time Detection                                           |
//+------------------------------------------------------------------+
bool TestTimeDetection() {
  Print("Running: TestTimeDetection...");
  
  // Simulate winter (January)
  datetime winter_time = D'2025.01.15 10:00';
  MqlDateTime dt_winter;
  TimeToStruct(winter_time, dt_winter);
  
  bool dst_winter = IsDSTActiveEU(winter_time);
  if (dst_winter) {
    Print("‚ùå FAILED: DST should be false in January");
    return false;
  }
  
  int offset_winter = GetOffsetToMSK();
  if (offset_winter != 1) {
    Print("‚ùå FAILED: Winter offset should be +1, got ", offset_winter);
    return false;
  }
  
  // Simulate summer (July)
  datetime summer_time = D'2025.07.15 10:00';
  bool dst_summer = IsDSTActiveEU(summer_time);
  if (!dst_summer) {
    Print("‚ùå FAILED: DST should be true in July");
    return false;
  }
  
  // Note: Can't change broker time dynamically, so just check logic
  
  Print("‚úÖ PASSED: TestTimeDetection");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 2: BMS Detection                                            |
//+------------------------------------------------------------------+
bool TestBMSDetection() {
  Print("Running: TestBMSDetection...");
  
  // Create test data
  // Swing High at bar 10: High = 1.1000
  // Bar 5: High = 1.1015, Close = 1.1012 (CLOSED above swing high)
  // Bar 4: Close = 1.0995 (false breakout - closed below)
  
  // Test case 1: Valid BMS (Close above)
  // Simulate: Current bar closed at 1.1012, above swing high 1.1000
  bool is_bms = (1.1012 > 1.1000);  // Using Close, not High
  if (!is_bms) {
    Print("‚ùå FAILED: Should detect BMS when Close > Swing High");
    return false;
  }
  
  // Test case 2: Invalid BMS (High above but Close below)
  bool is_false_bms = (1.1015 > 1.1000 && 1.0995 <= 1.1000);
  if (!is_false_bms) {
    Print("‚ùå FAILED: Should NOT detect BMS when only High breaks");
    return false;
  }
  
  Print("‚úÖ PASSED: TestBMSDetection");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 3: Confluence Weights                                       |
//+------------------------------------------------------------------+
bool TestConfluenceWeights() {
  Print("Running: TestConfluenceWeights...");
  
  // Test maximum possible score
  double max_score = 25 + 20 + 20 + 20 + 4 + 4 + 4 + 4 + 4;
  if (max_score != 105) {
    Print("‚ùå FAILED: Max raw score should be 105 (before cap)");
    return false;
  }
  
  // Test that it caps at 100
  double capped = (max_score > 100) ? 100 : max_score;
  if (capped != 100) {
    Print("‚ùå FAILED: Score should cap at 100");
    return false;
  }
  
  // Test minimum tradeable
  double min_tradeable = 25 + 20 + 20 + 15;  // BMS + SH + OB + Session
  if (min_tradeable != 80) {
    Print("‚ùå FAILED: Minimum tradeable should be 80%");
    return false;
  }
  
  Print("‚úÖ PASSED: TestConfluenceWeights");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 4: AMD Manipulation Direction                               |
//+------------------------------------------------------------------+
bool TestAMDManipulationDirection() {
  Print("Running: TestAMDManipulationDirection...");
  
  // Test case: Bearish AMD
  // Manipulation: Breakout UP (swept BSL above Asian Range)
  ENUM_AMD_DIRECTION manipulation = AMD_UP;
  
  // Expected distribution: DOWN (opposite!)
  ENUM_AMD_DIRECTION expected_distribution = AMD_DOWN;
  
  if (manipulation == AMD_UP && expected_distribution != AMD_DOWN) {
    Print("‚ùå FAILED: Distribution should be opposite to Manipulation");
    return false;
  }
  
  // Test case: Bullish AMD
  manipulation = AMD_DOWN;
  expected_distribution = AMD_UP;
  
  if (manipulation == AMD_DOWN && expected_distribution != AMD_UP) {
    Print("‚ùå FAILED: Distribution should be opposite to Manipulation");
    return false;
  }
  
  Print("‚úÖ PASSED: TestAMDManipulationDirection");
  return true;
}

//+------------------------------------------------------------------+
//| TEST 5: Order Block Mitigation                                   |
//+------------------------------------------------------------------+
bool TestOrderBlockMitigation() {
  Print("Running: TestOrderBlockMitigation...");
  
  OrderBlock ob;
  ob.type = OB_BULLISH;
  ob.high = 1.1000;
  ob.low = 1.0990;
  ob.status = OB_ACTIVE;
  ob.mitigation_count = 0;
  
  // First touch
  MitigationResult r1 = CheckOrderBlockMitigation(ob, 1.0995, TimeCurrent());
  if (ob.mitigation_count != 1) {
    Print("‚ùå FAILED: Mitigation count should be 1 after first touch");
    return false;
  }
  if (ob.GetConfluenceAdjustment() != 0.0) {
    Print("‚ùå FAILED: No penalty for first touch");
    return false;
  }
  
  // Second touch (after 10 minutes)
  MitigationResult r2 = CheckOrderBlockMitigation(ob, 1.0993, TimeCurrent() + 600);
  if (ob.mitigation_count != 2) {
    Print("‚ùå FAILED: Mitigation count should be 2");
    return false;
  }
  if (ob.GetConfluenceAdjustment() != -5.0) {
    Print("‚ùå FAILED: Should have -5% penalty for second touch");
    return false;
  }
  
  // Third touch
  MitigationResult r3 = CheckOrderBlockMitigation(ob, 1.0992, TimeCurrent() + 1200);
  if (ob.mitigation_count != 3) {
    Print("‚ùå FAILED: Mitigation count should be 3");
    return false;
  }
  if (ob.GetConfluenceAdjustment() != -15.0) {
    Print("‚ùå FAILED: Should have -15% penalty for third touch");
    return false;
  }
  
  // Violation
  MitigationResult r4 = CheckOrderBlockMitigation(ob, 1.0985, TimeCurrent() + 1800);
  if (ob.status != OB_VIOLATED) {
    Print("‚ùå FAILED: OB should be VIOLATED after price goes below low");
    return false;
  }
  
  Print("‚úÖ PASSED: TestOrderBlockMitigation");
  return true;
}
```

---

## üìù CHECKLIST –ü–ï–†–ï–î –†–ï–õ–ò–ó–û–ú

```
–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
‚ñ° AMD manipulation direction (–ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω–∞ distribution)
‚ñ° Confluence weights sum to 100%
‚ñ° Order Block mitigation tracking —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω
‚ñ° Timeframe-dependent thresholds –¥–ª—è Equal Highs
‚ñ° HTF trend filter –≤ SetupScanner
‚ñ° DST —Ç–æ—á–Ω—ã–µ –¥–∞—Ç—ã (–Ω–µ –ø—Ä–æ—Å—Ç–æ –º–µ—Å—è—Ü—ã)
‚ñ° Sweep volume check MANDATORY –¥–ª—è News
‚ñ° Fibonacci –æ—Ç impulse_start –∫ impulse_max
‚ñ° Sessions –ø–µ—Ä–µ–º–µ—â–µ–Ω —Ä–∞–Ω—å—à–µ Liquidity

–§–£–ù–ö–¶–ò–û–ù–ê–õ–¨–ù–û–°–¢–¨:
‚ñ° –í—Å–µ –º–æ–¥—É–ª–∏ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã
‚ñ° Dashboard –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
‚ñ° Real-time updates —Ä–∞–±–æ—Ç–∞—é—Ç
‚ñ° Alerts system (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
‚ñ° Risk management (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)

–¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï:
‚ñ° –í—Å–µ automated tests passed
‚ñ° Manual testing –Ω–∞ –∏—Å—Ç–æ—Ä–∏–∏
‚ñ° Live testing –º–∏–Ω–∏–º—É–º 1 –Ω–µ–¥–µ–ª—è
‚ñ° Multiple symbols tested
‚ñ° Multiple timeframes tested

–ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨:
‚ñ° Indicator loading < 5 —Å–µ–∫—É–Ω–¥
‚ñ° OnCalculate < 20ms –Ω–∞ —Ç–∏–∫
‚ñ° Dashboard redraw < 10ms
‚ñ° –ù–µ—Ç memory leaks

–î–û–ö–£–ú–ï–ù–¢–ê–¶–ò–Ø:
‚ñ° User Manual –Ω–∞–ø–∏—Å–∞–Ω
‚ñ° Trading concepts –æ–±—ä—è—Å–Ω–µ–Ω—ã
‚ñ° Dashboard guide –≥–æ—Ç–æ–≤
‚ñ° Troubleshooting section –µ—Å—Ç—å
‚ñ° Code comments –¥–æ–±–∞–≤–ª–µ–Ω—ã

–†–ï–õ–ò–ó:
‚ñ° Version 1.0 package –≥–æ—Ç–æ–≤
‚ñ° Release notes –Ω–∞–ø–∏—Å–∞–Ω—ã
‚ñ° Support channels setup
‚ñ° Beta testing –∑–∞–≤–µ—Ä—à–µ–Ω
```

---

## üéØ –ò–¢–û–ì–û–í–ê–Ø –û–¶–ï–ù–ö–ê –ü–õ–ê–ù–ê

**–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏:** ‚úÖ 95%  
**–û—Å—Ç–∞–≤—à–∏–µ—Å—è 5%:** –ú–µ–ª–∫–∏–µ –¥–µ—Ç–∞–ª–∏ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—è–≤—è—Ç—Å—è –ø—Ä–∏ –∫–æ–¥–∏–Ω–≥–µ

**–û–∂–∏–¥–∞–µ–º–æ–µ –≤—Ä–µ–º—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏:** 12-14 –Ω–µ–¥–µ–ª—å  
**–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è –∫–æ–º–∞–Ω–¥–∞:** 1-2 —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞ MQL5  

**–£—Å–ø–µ—Ö –ø—Ä–æ–µ–∫—Ç–∞:** –í–´–°–û–ö–ò–ô –ø—Ä–∏ —Å–ª–µ–¥–æ–≤–∞–Ω–∏–∏ –ø–ª–∞–Ω—É

---

**–ö–û–ù–ï–¶ –î–û–ö–£–ú–ï–ù–¢–ê**